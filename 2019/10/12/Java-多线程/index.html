<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java 多线程"><meta name="keywords" content="java,学习java"><meta name="author" content="pangzibo243"><meta name="copyright" content="pangzibo243"><title>Java 多线程 | pangzibo243's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-多线程"><span class="toc-text">Java 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程"><span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建多线程"><span class="toc-text">创建多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例变量和线程安全"><span class="toc-text">实例变量和线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步锁-synchronized"><span class="toc-text">同步锁(synchronized)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#停止线程"><span class="toc-text">停止线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程优先级"><span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#守护线程"><span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程让步"><span class="toc-text">线程让步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join-方法"><span class="toc-text">join()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-方法"><span class="toc-text">sleep()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-和notify"><span class="toc-text">wait()和notify()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的生命周期"><span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_faceQ.png"></div><div class="author-info__name text-center">pangzibo243</div><div class="author-info__description text-center">pangzibo243's blog</div><div class="follow-button"><a href="https://github.com/litianbo243">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pangzibo243's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Java 多线程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><strong>什么是进程?</strong></p>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe文件的运行）。</p>
<p><strong>什么是线程?</strong></p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>什么是多线程?</strong></p>
<p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>
<p><strong>为什么多线程是必要的?</strong></p>
<p>开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p>
<p><strong>为什么提倡多线程而不是多进程?</strong></p>
<p>线程就是轻量级进程，是程序执行的最小单位。使用多线程而不是用多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</p>
<h2 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h2><p><strong>1. 继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreateDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Mythread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start(); <span class="comment">// 该方法调用多次,出现IllegalThreadStateException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"通过继承Thread创建的线程!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.实现Runnable接口(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过Runnable创建的线程!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上述两种创建方式,工作时性质一样。但是建议使用实现Runable接口方式。解决单继承的局限性。</strong></p>
<h2 id="实例变量和线程安全"><a href="#实例变量和线程安全" class="headerlink" title="实例变量和线程安全"></a>实例变量和线程安全</h2><p><strong>不共享数据的情况下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.setName(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			count--;</span><br><span class="line">			System.out.println(<span class="string">"由 "</span> + MyThread.currentThread().getName() + <span class="string">" 计算，count="</span> + count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread a = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">		MyThread b = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">		MyThread c = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://img-blog.csdnimg.cn/20190630111434786.jpg" alt="在这里插入图片描述"></p>
<p>可以看出每个线程都有一个属于自己的实例变量count，它们之间互不影响。我们再来看看另一种情况。</p>
<p><strong>共享数据的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedVariableThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(<span class="string">"由 "</span> + SharedVariableThread.currentThread().getName() + <span class="string">" 计算，count="</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		SharedVariableThread mythread = <span class="keyword">new</span> SharedVariableThread();</span><br><span class="line">		<span class="comment">// 下列线程都是通过mythread对象创建的</span></span><br><span class="line">		Thread a = <span class="keyword">new</span> Thread(mythread, <span class="string">"A"</span>);</span><br><span class="line">		Thread b = <span class="keyword">new</span> Thread(mythread, <span class="string">"B"</span>);</span><br><span class="line">		Thread c = <span class="keyword">new</span> Thread(mythread, <span class="string">"C"</span>);</span><br><span class="line">		Thread d = <span class="keyword">new</span> Thread(mythread, <span class="string">"D"</span>);</span><br><span class="line">		Thread e = <span class="keyword">new</span> Thread(mythread, <span class="string">"E"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">		d.start();</span><br><span class="line">		e.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://img-blog.csdnimg.cn/20190630111511584.jpg" alt="在这里插入图片描述"></p>
<p>可以看出这里已经出现了错误。</p>
<p><strong>如何解决</strong></p>
<p>利用 synchronized 关键字（保证任意时刻只能有一个线程执行该方法）</p>
<h2 id="同步锁-synchronized"><a href="#同步锁-synchronized" class="headerlink" title="同步锁(synchronized)"></a>同步锁(synchronized)</h2><p><strong>synchronized修饰实例方法</strong></p>
<p>这样的含义是锁住当前实例对象，多个线程运行该方法，只有一个线程能够获得该实例的锁，执行方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"function同步锁中"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronized修饰静态方法</strong></p>
<p>这样的含义是锁住当前类对象，此时与创建的对象无关，只有一个线程能够该类对象的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"staticFunction同步锁中"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronized锁住代码块</strong></p>
<p>对指定的对象加锁，那么多个线程中，只有一个线程能够获得该对象的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    System.out.println(<span class="string">"我在obj对象锁中"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>终止正在运行的线程方法有三种：</p>
<ol>
<li>使用退出表示,是线程正常的执行完run方法终止.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadVariableStopDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VariableStopThread thread = <span class="keyword">new</span> VariableStopThread(<span class="string">"thread_1"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableStopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VariableStopThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":线程开始运行!"</span>);</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted()) &#123; </span><br><span class="line">            System.out.println(<span class="string">""</span> + (i++));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"我停止了! timer:"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16015052-9752cb03dbb6b220.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/436/format/webp" alt="img"></p>
<ol>
<li>使用interrupt方法,使线程异常,线程进行捕获或抛异常,正常执行完run方法终止.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> InterruptThread(<span class="string">"thread_1"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">"线程设置:interrupt"</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterruptThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"线程开始!"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span> + (i + <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"线程捕获异常,退出循环!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"线程结束!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16015052-2710bc9e54ea438e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/438/format/webp" alt="img"></p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级范围为1-10，API提供等级分为：</p>
<p>低（MIN_PRIORITY = 1)，</p>
<p>中（NORM_PRIORITY=5），</p>
<p>高（MAX_PRIORITY=10）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> ThreadPriority(<span class="string">"thread_1&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        Thread thread_1 = <span class="keyword">new</span> ThreadPriority(<span class="string">"&gt;&gt;&gt;thread_2"</span>);</span><br><span class="line">        thread_1.setPriority(Thread.MIN_PRIORITY); <span class="comment">//&lt;设置线程优先级</span></span><br><span class="line">        thread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        thread_1.start();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPriority</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">""</span> + Thread.currentThread().getName() + <span class="string">",number:"</span> + i + <span class="string">",Priority:"</span> + Thread.currentThread().getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16015052-5f1f1c8a0ad15ee8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/404/format/webp" alt="img"></p>
<p>运行的很给力，以下体现了两个问题:<strong>①线程运行顺序与代码执行顺序无关。②线程优先级具有随机性，不是优先级高的就先完成。</strong></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>用户线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>
<p>守护线程：运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 “佣人”。</p>
<p>特点：一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</p>
<p>应用：数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</p>
<p>最常见的守护线程：垃圾回收线程</p>
<p>守护线程顾名思义是一个线程守护另一个线程【此线程为非守护线程】，故守护的线程称为守护线程，被守护的线程称为非守护线程。作用是为其他线程运行提供便利服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">""</span> + Thread.currentThread().getName() + <span class="string">"停止运行!"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"DaemonThread 正在运行!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16015052-d3d8d7b138d19f49.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/227/format/webp" alt="img"></p>
<p>从上图可以看出，主线程停止DaemonThread线程也相应的停止了，但不是立即停止。</p>
<h2 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h2><p>线程让步【yield方法】让当前线程释放CPU资源，让其他线程抢占。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time_start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            Math.random();</span><br><span class="line"><span class="comment">//          Thread.yield();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time_end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"用时："</span> + (time_end - time_start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不让步:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16015052-527a7196e0454f5c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/119/format/webp" alt="img"></p>
<p>让步:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16015052-65d0884869bf6cd5.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/149/format/webp" alt="img"></p>
<p>从以上两图可以看出，线程的让步操作比不让步耗时长。</p>
<h2 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h2><p><strong>Java对Thread的Join方法解释：等待当前线程终止。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">"A"</span>);</span><br><span class="line">		ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">"B"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">				System.out.println(name+<span class="string">"-"</span>+i);</span><br><span class="line">		&#125;		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>显然，使用t1.join()之后，B线程需要等A线程执行完毕之后才能执行。</p>
<h2 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multi</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Multi t1 = <span class="keyword">new</span> Multi();</span><br><span class="line">        Multi t2 = <span class="keyword">new</span> Multi();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1: <span class="number">1</span></span><br><span class="line">t2: <span class="number">1</span></span><br><span class="line">t1: <span class="number">2</span></span><br><span class="line">t2: <span class="number">2</span></span><br><span class="line">t1: <span class="number">3</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>这是因为Sleep()使得当前线程进入阻塞状态，系统便调用了另一线程，循环往复，便出现了上面的输出结果。</p>
<h2 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h2><p>java的wait/notify的通知机制可以用来实现线程间通信。</p>
<p>wait表示线程的等待，调用该方法会导致线程阻塞，直至另一线程调用notify或notifyAll方法才可另其继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread consume = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consume(), <span class="string">"Consume"</span>);</span><br><span class="line">        Thread produce = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Produce(), <span class="string">"Produce"</span>);</span><br><span class="line">        consume.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        produce.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            produce.join();</span><br><span class="line">            consume.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Produce</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">"进入生产者线程"</span>);</span><br><span class="line">                System.out.println(<span class="string">"生产"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);  <span class="comment">//模拟生产过程</span></span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    obj.notify();  <span class="comment">//通知消费者</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);  <span class="comment">//模拟其他耗时操作</span></span><br><span class="line">                    System.out.println(<span class="string">"退出生产者线程"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consume</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">"进入消费者线程"</span>);</span><br><span class="line">                System.out.println(<span class="string">"wait flag 1:"</span> + flag);</span><br><span class="line">                <span class="keyword">while</span> (!flag) &#123;  <span class="comment">//判断条件是否满足，若不满足则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"还没生产，进入等待"</span>);</span><br><span class="line">                        obj.wait();</span><br><span class="line">                        System.out.println(<span class="string">"结束等待"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"wait flag 2:"</span> + flag);</span><br><span class="line">                System.out.println(<span class="string">"消费"</span>);</span><br><span class="line">                System.out.println(<span class="string">"退出消费者线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入消费者线程</span><br><span class="line"></span><br><span class="line">wait flag <span class="number">1</span>:<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">还没生产，进入等待</span><br><span class="line"></span><br><span class="line">进入生产者线程</span><br><span class="line"></span><br><span class="line">生产</span><br><span class="line"></span><br><span class="line">退出生产者线程</span><br><span class="line"></span><br><span class="line">结束等待</span><br><span class="line"></span><br><span class="line">wait flag <span class="number">2</span>:<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">消费</span><br><span class="line"></span><br><span class="line">退出消费者线程</span><br></pre></td></tr></table></figure>
<p>在示例中没有体现但很重要的是，wait/notify方法的调用必须处在该对象的锁（Monitor）中，也即，在调用这些方法时首先需要获得该对象的锁。否则会抛出IllegalMonitorStateException异常。</p>
<p>从输出结果来看，在生产者调用notify()后，消费者并没有立即被唤醒，而是等到生产者退出同步块后才唤醒执行。（这点其实也好理解，synchronized同步方法（块）同一时刻只允许一个线程在里面，生产者不退出，消费者也进不去）</p>
<p>注意，消费者被唤醒后是从wait()方法（被阻塞的地方）后面执行，而不是重新从同步块开头。</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt="img"></p>
<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态:</p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/d901b25e0d4a" target="_blank" rel="noopener">https://www.jianshu.com/p/d901b25e0d4a</a></p>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/79640870#__10" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/79640870#__10</a></p>
<p><a href="https://www.runoob.com/java/java-multithreading.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-multithreading.html</a></p>
<p><a href="https://blog.csdn.net/u013425438/article/details/80205693" target="_blank" rel="noopener">https://blog.csdn.net/u013425438/article/details/80205693</a></p>
<p><a href="https://www.cnblogs.com/hqinglau/p/10053564.html" target="_blank" rel="noopener">https://www.cnblogs.com/hqinglau/p/10053564.html</a></p>
<p><a href="https://blog.csdn.net/jianiuqi/article/details/53448849" target="_blank" rel="noopener">https://blog.csdn.net/jianiuqi/article/details/53448849</a></p>
<p><a href="https://blog.csdn.net/wthfeng/article/details/78762343" target="_blank" rel="noopener">https://blog.csdn.net/wthfeng/article/details/78762343</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1630613830514012483&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1630613830514012483&amp;wfr=spider&amp;for=pc</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">pangzibo243</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://litianbo243.github.io/2019/10/12/Java-多线程/">https://litianbo243.github.io/2019/10/12/Java-多线程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/学习java/">学习java</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_zhifubao_code.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_weixin_code.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/10/12/Java-Socket/"><i class="fa fa-chevron-left">  </i><span>Java Socket</span></a></div><div class="next-post pull-right"><a href="/2019/10/10/Java-注解/"><span>Java 注解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By pangzibo243</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>