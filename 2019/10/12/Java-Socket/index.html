<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java Socket"><meta name="keywords" content="java,学习java"><meta name="author" content="pangzibo243"><meta name="copyright" content="pangzibo243"><title>Java Socket | pangzibo243's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Socket"><span class="toc-text">Java Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-Echo-Request-实例"><span class="toc-text">TCP Echo Request 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-Echo-Request-实例"><span class="toc-text">UDP Echo Request 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-Socket-与-TCP-Socket-区别"><span class="toc-text">UDP Socket 与 TCP Socket 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_faceQ.png"></div><div class="author-info__name text-center">pangzibo243</div><div class="author-info__description text-center">pangzibo243's blog</div><div class="follow-button"><a href="https://github.com/litianbo243">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">56</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pangzibo243's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Java Socket</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Java-Socket"><a href="#Java-Socket" class="headerlink" title="Java Socket"></a>Java Socket</h1><p>Socket，即套接字，是一种介于应用和传输层之间的抽象层，可实现同网络内不同应用之间相互发送和接收数据。</p>
<p>对于 Socket，有以下三个关键问题：</p>
<p><strong>1. 如何定位到目标应用</strong></p>
<p>在发送和接收数据时，关键在于如何定位到应用，而定位到应用首先需要定位到主机。</p>
<p>在同一子网内，每台主机的 IP 地址是唯一的，故可以借助 IP 地址定位主机，而在每一台主机上，不同的程序往往监听在不同的端口号上，因此，可以利用端口号来定位应用。</p>
<p>因此，一个 socket 由一个 url 地址和一个 port 端口号唯一确定。</p>
<p><strong>2. 与TCP/IP的关系</strong></p>
<p>socket 与 TCP/IP 协议簇无关，其本质是编程接口，<strong>用于向应用提供数据传输服务的接口</strong>。Java 中的 socket 主要是基于 TCP/IP 的封装，在使用过程中，应用可借助socket接口，建立基于TCP或UDP的数据传输机制，从而实现同网络跨应用之间的数据传输功能，从而将应用与传输层的具体协议分离开来，使得上层应用无需关注过多细节，只专注数据传输即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20181107154831435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5emlkdQ==,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>3. Socket的工作过程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181107155311405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5emlkdQ==,size_16,color_FFFFFF,t_70" alt></p>
<ol>
<li>根据传输类型选择 socket 接口进行调用，以 TCP/IP 协议簇为例，主要包括两种socket，即针对 TCP 的流 socket 和针对 UDP 的数据报 socket。</li>
<li>根据目的应用主机、所在端口号等信息实现寻址过程。</li>
<li>链接建立与数据传输。</li>
<li>关闭链接。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181107164104757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5emlkdQ==,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="TCP-Echo-Request-实例"><a href="#TCP-Echo-Request-实例" class="headerlink" title="TCP Echo Request 实例"></a>TCP Echo Request 实例</h2><p><strong>Server端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFSIZE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 参数校验，传入参数 端口号</span></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parameter(s): &lt;Port&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> servPort = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ServerSocket 实例，并监听给定端口号 servPort</span></span><br><span class="line">        ServerSocket servSock = <span class="keyword">new</span> ServerSocket(servPort);</span><br><span class="line">        <span class="keyword">int</span> recvMsgSize;</span><br><span class="line">        <span class="keyword">byte</span>[] receiveBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFSIZE];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 用于获取下一个客户端连接，根据连接创建 Socket 实例</span></span><br><span class="line">            Socket clntSock = servSock.accept();</span><br><span class="line">            <span class="comment">// 获取客户端地址和端口号</span></span><br><span class="line">            SocketAddress clientAddress = clntSock.getRemoteSocketAddress();</span><br><span class="line">            System.out.println(<span class="string">"Handling client at "</span> + clientAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 socket 的输入输出流</span></span><br><span class="line">            InputStream in = clntSock.getInputStream();</span><br><span class="line">            OutputStream out = clntSock.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次从输入流中读取数据并写到输出流中，直至输入流为空</span></span><br><span class="line">            <span class="keyword">while</span> ((recvMsgSize = in.read(receiveBuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receiveBuf, <span class="number">0</span>, recvMsgSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭 Socket</span></span><br><span class="line">            clntSock.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>Socket 中的输入输出流是流抽象，可看做一个字符序列，输入流支持读取字节，输出流支持取出字节。每个 Socket 实例都维护了 一个 InputStream 和一个 OutputStream 实例，数据传输也主要依靠从流中获取数据并解析的过程。</li>
<li>ServerSocket 与 Socket 区别，ServerSocket 主要用于服务端，用于为新的 TCP 连接请求提供一个新的已连接的 Socket 实例。Socket 则用于服务端和客户端，用于表示 TCP 连接的一端。因此，服务端需要同时处理 ServerSocket 和 Socket 实例，而客户端只需要处理 Socket 实例即可。</li>
</ol>
<p><strong>Client端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 参数校验，传入格式 url "info" 或 url "info" 10240</span></span><br><span class="line">        <span class="keyword">if</span> ((args.length &lt; <span class="number">2</span>) || (args.length &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parameter(s): &lt;server&gt;&lt;word&gt; [&lt;Port&gt;]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标应用 url</span></span><br><span class="line">        String server = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 将传送数据转化为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = args[<span class="number">1</span>].getBytes();</span><br><span class="line">        <span class="comment">// 解析端口号，若无则设为 10240</span></span><br><span class="line">        <span class="keyword">int</span> servPort = (args.length == <span class="number">3</span>) ? Integer.parseInt(args[<span class="number">2</span>]) : <span class="number">10240</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据参数创建 Socket 实例</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(server, servPort);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Connected to server... sending echo string"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 socket 的输入输出流</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据写入到 Socket 的输出流中，并发送数据</span></span><br><span class="line">        out.write(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalBytesRcvd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bytesRcvd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收返回信息</span></span><br><span class="line">        <span class="keyword">while</span> (totalBytesRcvd &lt; data.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((bytesRcvd = in.read(data, totalBytesRcvd, data.length - totalBytesRcvd)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Connection closed permaturely"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            totalBytesRcvd += bytesRcvd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Received: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p><strong>发送数据时只通过 write() 方法，接收时为何需要多个 read() 方法?</strong><br>TCP 协议无法确定在 read() 和 write() 方法中所发送信息的界限，而且发送过程中可能存在乱序现象，即分割成多个部分，所以无法通过一次 read() 获取到全部数据信息。</p>
<h2 id="UDP-Echo-Request-实例"><a href="#UDP-Echo-Request-实例" class="headerlink" title="UDP Echo Request 实例"></a>UDP Echo Request 实例</h2><p><strong>Server端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ECHOMAX = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 参数校验，格式 port</span></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parameter(s): &lt;Port&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取端口号</span></span><br><span class="line">        <span class="keyword">int</span> servPort = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 创建数据报文 Socket</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(servPort);</span><br><span class="line">        <span class="comment">// 创建数据报文</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[ECHOMAX], ECHOMAX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收请求报文</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            System.out.println(<span class="string">"Handling client at "</span> + packet.getAddress().getHostAddress() +</span><br><span class="line">                    <span class="string">" on port "</span> + packet.getPort());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送数据报文</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">            <span class="comment">// 重置缓存区大小</span></span><br><span class="line">            packet.setLength(ECHOMAX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>UDP服务端 与 TCP 服务端不同，TCP 对于每一个客户端请求都需要先建立连接，而 UDP 则不需要。因此，UDP 只需创建一个 Socket 等待客户端连接即可。</li>
<li>在该 UDP 服务器的实现中，只接收和发送数据报文中的前 ECHOMAX 个字符，超出部分直接丢弃。</li>
<li>在处理过接收到的消息后，数据包的内部长度会设置为刚处理过的消息长度，通常比初始长度要短，因此需重置缓冲区为初始长度。否则后续可能会使得缓冲区长度不断减小，使得数据包被截断。</li>
</ul>
<p><strong>Client端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InterruptedIOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPEchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXTRIES = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 参数解析，格式 url "info" 或 url "info" 10240</span></span><br><span class="line">        <span class="keyword">if</span> ((args.length &lt; <span class="number">2</span>) || (args.length &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parameter(s): &lt;Server&gt; &lt;Word&gt; [&lt;Port&gt;]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建目标 Server IP 地址对象</span></span><br><span class="line">        InetAddress serverAddress = InetAddress.getByName(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将需传输字符转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteToSend = args[<span class="number">1</span>].getBytes();</span><br><span class="line">        <span class="comment">// 获取服务端端口号，默认 10241</span></span><br><span class="line">        <span class="keyword">int</span> servPort = (args.length == <span class="number">3</span>) ? Integer.parseInt(args[<span class="number">2</span>]) : <span class="number">10241</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 UDP 套接字，选择本地可用的地址和可用端口号</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置超时时间，用于控制 receive() 方法调用的实际最短阻塞时间</span></span><br><span class="line">        socket.setSoTimeout(TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建发送数据报文</span></span><br><span class="line">        DatagramPacket sendPacket = <span class="keyword">new</span> DatagramPacket(byteToSend, byteToSend.length, serverAddress, servPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建接收数据报文</span></span><br><span class="line">        DatagramPacket receivePacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[byteToSend.length], byteToSend.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最大重试次数，以减少数据丢失产生的影响</span></span><br><span class="line">        <span class="keyword">int</span> tries = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 是否收到响应</span></span><br><span class="line">        <span class="keyword">boolean</span> receivedResponse = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将数据报文传输到指定服务器和端口</span></span><br><span class="line">            socket.send(sendPacket);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞等待，直到收到一个数据报文或等待超时，超时会抛出异常</span></span><br><span class="line">                socket.receive(receivePacket);</span><br><span class="line">                <span class="comment">// 校验服务端返回报文的地址和端口号</span></span><br><span class="line">                <span class="keyword">if</span> (!receivePacket.getAddress().equals(serverAddress)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Received packet from an unknown source"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                receivedResponse = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</span><br><span class="line">                tries += <span class="number">1</span>;</span><br><span class="line">                System.out.println(<span class="string">"Timed out, "</span> + (MAXTRIES - tries) + <span class="string">" more tries..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!receivedResponse &amp;&amp; (tries &lt; MAXTRIES));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (receivedResponse) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Received: "</span> + <span class="keyword">new</span> String(receivePacket.getData()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No response -- giving up."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>由于 UDP 提供的是尽最大可能的交付，所以在发送 Echo Request 请求时，无法保证一定可以送达目标地址和端口，因此考虑设置重传次数，若在超过最大等待时间后仍未收到回复，则重发当前请求，若重发次数超过最大重试次数，则可直接返回未发送成功。</p>
<h2 id="UDP-Socket-与-TCP-Socket-区别"><a href="#UDP-Socket-与-TCP-Socket-区别" class="headerlink" title="UDP Socket 与 TCP Socket 区别"></a>UDP Socket 与 TCP Socket 区别</h2><ul>
<li>UDP 保存了消息的边界信息，而 TCP 则没有。<br>在 TCP 中需通过多次 read() 来接收一次 write() 的信息，而 UDP 中对于单次 send() 的数据，最多只需一次 receive() 调用。</li>
<li>TCP 存在传输缓冲区，UDP 则无需对数据进行缓存。<br>由于 TCP 存在错误重传机制，因此需保留数据的缓存，以便于重传操作，当调用 write() 方法并返回后，数据被复制到传输缓冲区中，数据有可能处于发送过程中或还没有发生传送。而 UDP 则不存在该机制，因此无需缓存数据，当调用 send() 方法返回后，消息处于发送过程中。</li>
<li>UDP 会丢掉超过最大长度限制的数据，而 TCP 不会。<br>在 TCP 中，一旦建立连接后，对于所有数据都可以看做一个连续的字节序列。而在 UDP 中接收到的消息则可能来自于不同的源地址和端口，因此会将接收到的数据放在消息队列中，按照顺序来响应，超过最大长度的消息直接截断。Datagrampacket 所能传输的最大数据量为 65507 字节，也就是一个 UDP 报文能承载的最大数据。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/wyzidu/article/details/83826656" target="_blank" rel="noopener">https://blog.csdn.net/wyzidu/article/details/83826656</a></p>
<p><a href="https://www.jianshu.com/p/cde27461c226" target="_blank" rel="noopener">https://www.jianshu.com/p/cde27461c226</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">pangzibo243</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://litianbo243.github.io/2019/10/12/Java-Socket/">https://litianbo243.github.io/2019/10/12/Java-Socket/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/学习java/">学习java</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_zhifubao_code.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_weixin_code.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/10/13/Java-数据库/"><i class="fa fa-chevron-left">  </i><span>Java 数据库</span></a></div><div class="next-post pull-right"><a href="/2019/10/12/Java-多线程/"><span>Java 多线程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By pangzibo243</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>