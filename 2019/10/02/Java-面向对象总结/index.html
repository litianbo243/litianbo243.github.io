<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java 面向对象总结"><meta name="keywords" content="java,学习java"><meta name="author" content="pangzibo243"><meta name="copyright" content="pangzibo243"><title>Java 面向对象总结 | pangzibo243's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-面向对象总结"><span class="toc-text">Java 面向对象总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图解"><span class="toc-text">图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类和对象"><span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量和局部变量"><span class="toc-text">成员变量和局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#权限修饰符"><span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-关键字"><span class="toc-text">static 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this和super"><span class="toc-text">this和super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this和super调用构造函数"><span class="toc-text">this和super调用构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象类型的转换"><span class="toc-text">对象类型的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法重写和方法重载"><span class="toc-text">方法重写和方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重写Override"><span class="toc-text">方法重写Override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重载Overload"><span class="toc-text">方法重载Overload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object类"><span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals-方法"><span class="toc-text">equals()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone-方法"><span class="toc-text">clone()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-方法"><span class="toc-text">toString()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-方法"><span class="toc-text">finalize()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类和接口"><span class="toc-text">抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final关键字"><span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类"><span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员内部类"><span class="toc-text">成员内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局部内部类"><span class="toc-text">局部内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类"><span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态内部类"><span class="toc-text">静态内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例设计模式"><span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂方法模式"><span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_faceQ.png"></div><div class="author-info__name text-center">pangzibo243</div><div class="author-info__description text-center">pangzibo243's blog</div><div class="follow-button"><a href="https://github.com/litianbo243">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">45</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pangzibo243's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Java 面向对象总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Java-面向对象总结"><a href="#Java-面向对象总结" class="headerlink" title="Java 面向对象总结"></a>Java 面向对象总结</h1><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://images2015.cnblogs.com/blog/1081488/201704/1081488-20170425113401365-1070846569.jpg" alt></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>面向对象具有<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>、<strong>抽象</strong>等特性。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类是对一类事物的描述，是<strong>抽象的</strong>。</p>
<p>对象是一类事物的实例，是<strong>具体的</strong>。</p>
<p><strong>类是对象的模板，对象是类的实体</strong>。</p>
<p>类是封装对象的属性和行为的载体。</p>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><p><strong>成员变量的默认值</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本类型</td>
<td>整数(byte,short,int,long)</td>
<td>0</td>
</tr>
<tr>
<td>浮点数(float,double)</td>
<td>0.0</td>
<td></td>
</tr>
<tr>
<td>字符(char)</td>
<td>‘\u0000’</td>
<td></td>
</tr>
<tr>
<td>引用类型</td>
<td>布尔（boolean）</td>
<td>false</td>
</tr>
<tr>
<td>数组，类，接口</td>
<td>null</td>
</tr>
</tbody>
</table>
</div>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>Java 中主要有 <strong>private</strong>、<strong>protected</strong>、<strong>public</strong> 和 <strong>默认</strong>访问权限四种。</p>
<p><code>public</code> 修饰符，具有最大的访问权限，可以访问任何一个在<code>CLASSPATH</code> 下的类、接口、异常等。</p>
<p><code>protected</code> 修饰符，主要作用就是用来保护子类，子类可以访问这些成员变量和方法，其余类不可以。</p>
<p><code>default</code> 修饰符，主要是本包的类可以访问。</p>
<p><code>private</code> 修饰符，访问权限仅限于本类内部，在实际开发过程中，大多数的成员变量和方法都是使用 <code>private</code> 修饰的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>本包</th>
<th>外包子类</th>
<th>外包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p>随着类的加载而加载，优先于对象存在。（在静态方法中是没有this关键字的，this是随着对象的创建而存在）。</p>
<p>被类的所有对象共享，可以通过类名调用，也可以通过对象名调用，<strong>推荐使用类名调用</strong>。</p>
<p>静态变量存储于方法区的静态区，随着类的加载而加载，随着类的消失而消失。</p>
<h2 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h2><p>this是对当前对象的引用，是运行期间的对象本身。</p>
<p>super是直接父类对象的引用，可以访问弗雷中被子类覆盖的属性和方法。</p>
<h3 id="this和super调用构造函数"><a href="#this和super调用构造函数" class="headerlink" title="this和super调用构造函数"></a>this和super调用构造函数</h3><p><strong>this</strong></p>
<p>this关键字在构造函数中的应用：构造函数间调用，只能使用this进行互相调用，this函数不能用在一般函数间。</p>
<p>this语句(不是this关键字)只能定义在构造函数的第一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Person(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person(String name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>super</strong></p>
<p>在对子类对象进行初始化时，父类构造函数也会运行，是因为子类的构造函数默认第一行有一条隐式的语句super()，super()会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super()。</p>
<p>当父类中没有空参数的构造时，系统会报错，所以必须手动指定子类引用父类的哪个非空的构造函数。</p>
<p>如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式进行指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    </span><br><span class="line">    Fu()&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fu(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Zi()&#123;</span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        <span class="comment">// super(30);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Zi(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论（子类的实例化过程）：子类中所有的构造函数，默认都会访问父类中的空参数的构造函数，因为子类每一个构造函数内的第一行都有一句隐式的super()，当父类中没有空参数的构造函数时，子类必须手动通过super语句或者this语句形式来指定要访问的父类中的构造函数。子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少要有一个构造函数会访问父类中的构造函数(没写也会有默认的)。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
<p><strong>封装的步骤</strong></p>
<ol>
<li>使用 private 关键字来修饰成员变量。</li>
<li>对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。</li>
</ol>
<p><strong>标准代码——JavaBean</strong></p>
<p>JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="function">publicvoid <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>需要注意的是 Java 不支持多继承，但支持多重继承</p>
<p><strong>继承的特性</strong></p>
<p>1、子类拥有父类非 private 的属性、方法<br>2、子类可以拥有自己的属性和方法，即子类可以对父类进行扩展<br>3、子类可以用自己的方式实现父类的方法<br>4、提高了类之间的耦合性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"正在吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pig</span><span class="params">(String name, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>概念：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。</p>
<p>简单的说：就是用基类的引用指向子类的对象。</p>
<p><strong>java引用类型有两个</strong>：</p>
<p>　　<strong><em>编译时类型</em></strong></p>
<p>　　编译时类型由声明该变量时使用的类型决定</p>
<p>　　<strong><em>运行时类型</em></strong></p>
<p>　　运行时类型由实际赋给该变量的对象决定</p>
<p><strong>静态多态和动态多态的区别：</strong></p>
<p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>。<strong>其中编辑时多态是静态的，主要是指方法的重载</strong>，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。<strong>而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性</strong>。</p>
<p><strong>多态存在的三个必要条件</strong></p>
<ol>
<li>要有继承</li>
<li>要有重写</li>
<li>父类引用指向子类对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> month = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> month = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小狗吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小狗睡午觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> month = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal b = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat();</span><br><span class="line">        System.out.println(a.month);</span><br><span class="line">        <span class="comment">//下面代码编译时会出错</span></span><br><span class="line">		<span class="comment">//a.sleep();</span></span><br><span class="line">        b.eat();</span><br><span class="line">        System.out.println(b.month);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小狗吃肉</span><br><span class="line"><span class="number">2</span></span><br><span class="line">小猫吃鱼</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上例中main方法中注释了a.sleep()，由于a的编译时类型为Animal，而Animal类中没有sleep方法，因此无法在编译时调用sleep方法。</p>
<p>总的来说：</p>
<p><strong>引用变量在编译阶段只能调用编译时类型所具有的方法，但运行时则执行他运行时类型所具有的方法。</strong></p>
<h2 id="对象类型的转换"><a href="#对象类型的转换" class="headerlink" title="对象类型的转换"></a>对象类型的转换</h2><p>父子对象之间的转换分为了<strong>向上转型</strong>和<strong>向下转型</strong>,它们区别如下:</p>
<ul>
<li><strong>向上转型</strong> : 通过子类对象(小范围)实例化父类对象(大范围),这种属于自动转换</li>
<li><strong>向下转型</strong> : 通过父类对象(大范围)实例化子类对象(小范围),这种属于强制转换</li>
</ul>
<p><strong>向上转型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  System.out.println(<span class="string">"A:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                  System.out.println(<span class="string">"B:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">                  A a = <span class="keyword">new</span> B();          <span class="comment">//通过子类去实例化父类</span></span><br><span class="line">                  a.print();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// B:print</span></span><br></pre></td></tr></table></figure>
<p>可以看到打印的是<strong>class B的print</strong>,这是因为我们通过<strong>子类B去实例化</strong>的,所以父类A的print方法<strong>已经被</strong>子类B的print<strong>方法覆盖</strong>了.从而打印classB的print.</p>
<p><strong>这样做的意义在于:</strong></p>
<ul>
<li>当我们需要多个同父的对象调用某个方法时,通过向上转换后,则可以确定参数的统一.方便程序设计<strong>(参考下面示例)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  System.out.println(<span class="string">"A:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                  System.out.println(<span class="string">"B:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                  System.out.println(<span class="string">"C:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">                  a.print();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">                  func(<span class="keyword">new</span> B());  <span class="comment">//等价于 A a =new B();</span></span><br><span class="line">                  func(<span class="keyword">new</span> C());  <span class="comment">//等价于 C c =new C();</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// B:print</span></span><br><span class="line"><span class="comment">// C:print</span></span><br></pre></td></tr></table></figure>
<p><strong>PS:</strong>向上转型时,父类只能调用父类方法或者子类覆写后的方法,而子类中的单独方法则是无法调用的.</p>
<p><strong>向下转型</strong></p>
<p>在java中,向下转型则是为了,通过父类强制转换为子类,从而来调用子类<strong>独有的方法</strong>(向下转型,在工程中很少用到).</p>
<p>为了保证向下转型的顺利完成,在java中提供了一个关键字:<strong>instanceof</strong>,通过<strong>instanceof</strong>可以判断某对象是否是某类的实例,如果是则返回<strong>true</strong>,否则为<strong>false</strong>,instanceof使用如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> B();                 <span class="comment">//向上转型 (B类是A的子类)</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> A;                <span class="comment">//返回true.</span></span><br><span class="line">a <span class="keyword">instanceof</span> B;                <span class="comment">//返回true</span></span><br><span class="line">a <span class="keyword">instanceof</span> C;                <span class="comment">//返回false</span></span><br></pre></td></tr></table></figure>
<p>我们便来分析向下转型的意义.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  System.out.println(<span class="string">"A:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                  System.out.println(<span class="string">"B:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  System.out.println(<span class="string">"funcB"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                  System.out.println(<span class="string">"C:print"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funcC</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  System.out.println(<span class="string">"funcC"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">                  a.print();</span><br><span class="line">                  <span class="keyword">if</span>(a <span class="keyword">instanceof</span> B)</span><br><span class="line">                  &#123;</span><br><span class="line">                          B b = (B)a;   <span class="comment">//向下转型,通过父类实例化子类</span></span><br><span class="line">                          b.funcB();    <span class="comment">//调用B类独有的方法</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> C)</span><br><span class="line">                  &#123;</span><br><span class="line">                          C c = (C)a;  <span class="comment">//向下转型,通过父类实例化子类</span></span><br><span class="line">                          c.funcC();   <span class="comment">//调用C类独有的方法</span></span><br><span class="line">                  &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">                  func(<span class="keyword">new</span> A());   </span><br><span class="line">                  func(<span class="keyword">new</span> B());</span><br><span class="line">                  func(<span class="keyword">new</span> C());</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// A:print</span></span><br><span class="line"><span class="comment">// B:peint</span></span><br><span class="line"><span class="comment">// funcB</span></span><br><span class="line"><span class="comment">// C:print</span></span><br><span class="line"><span class="comment">// funcC</span></span><br></pre></td></tr></table></figure>
<p>从上面打印可以看到,我们成功通过<strong>向下转型</strong>来调用<strong>B类和C类独有的方法</strong>.</p>
<h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><h3 id="方法重写Override"><a href="#方法重写Override" class="headerlink" title="方法重写Override"></a>方法重写Override</h3><p>子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的。</p>
<h3 id="方法重载Overload"><a href="#方法重载Overload" class="headerlink" title="方法重载Overload"></a>方法重载Overload</h3><p>本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。</p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Java中的所有类最终都继承于Object。</p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><p>该方法用于比较两个对象，如果这两个对象引用指向的是同一个对象，那么返回true，否则返回false。</p>
<h3 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h3><p>默认的clone方法是<code>浅拷贝模式</code>。所谓浅拷贝，指的是对象内属性引用的对象只会拷贝引用地址，而不会将引用的对象重新分配内存。深拷贝则是会连引用的对象也重新创建。</p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>这个方法的使用频率非常高，用于返回一个可代表对象的字符串。</p>
<p>默认返回格式如下：<code>对象的class名称</code> + <code>@</code> + <code>hashCode的十六进制字符串</code></p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>这个方法用于在GC的时候再次被调用，如果我们实现了这个方法，对象可能在这个方法中再次<code>复活</code>，从而避免被GC回收。</p>
<p>通常情况下，我们不需要自己实现这个方法。</p>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。</p>
<p>抽象类：<code>abstract class 类名 {}</code></p>
<p>抽象方法：<code>public abstract void eat();</code></p>
<p><strong>注意：</strong></p>
<p>​            1、抽象类不能实例化，由具体的子类实例化。其实这也是多态的一种，抽象类多态。</p>
<p>　　　2、抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<p>　　　3、抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<p>　　　4、抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是猫，我吃的是猫粮呀"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是猫，我比你们人类睡的时间短！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"我是老虎，我要吃大鱼大肉！！！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"我是老虎，每天必须睡够24个小时！！！！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类的用处：</p>
<p>虽然也要在Cat和Tiger中定义sleep和eat这两个方法，看似代码上没有太多简化。但是这背后却隐藏着一个规范问题：也就是“<strong>是不是</strong>”的问题。cat和person都“是”animal，所以就必须继承animal里面的方法。相当于提供了一个大的体制。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是一个规范和抽象类比较相似。它只管做什么，不管怎么做。通俗的讲，借口就是某个事物对外提供的一些功能的声明，其定义和类比较相似，只不过是通过<strong>interface</strong>关键字来完成。</p>
<p>其中重要的几个知识点：</p>
<p>   1.接口中的所有属性默认为：public static final <em>**</em>；</p>
<p>   2.接口中的所有方法默认为：public abstract <em>**</em>；</p>
<p>   3.接口不再像类一样用关键字 extends去“继承”，而是用 implements 去“实现”，也就是说类和接口的关系叫做实现，（例如：A类实现了B接口，那么成为A为B接口的实现类。而类与类之间的继承的话，叫做A类继承了B类，其中B类即为A类的父类）。实现接口与类的继承比较相似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sleep</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioSleep</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eat</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ioEat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioStudy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Sleep</span>,<span class="title">Eat</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioSleep</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是猫，我每天都不用睡觉！！！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioEat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是猫，我吃猫粮！！！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Sleep</span>,<span class="title">Eat</span>,<span class="title">Study</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioStudy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是人，我每天都要学习"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioEat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是人，我要吃大鱼大肉还要喝酒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioSleep</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是人，我每天要睡24小时"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以也就可以列出<strong>抽象类和接口的几点区别</strong>：</p>
<p>​      <strong>1.抽象类描述的是“是不是”的问题，而接口描述的是“有没有”的问题；</strong></p>
<p>​      <strong>2.在Java中类的继承是“单继承”，可以“多对一”，但是不允许“一对多”。而一个类却可以同时实现多个接口；</strong></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>final修饰特点</strong></p>
<p>修饰类，类不能被继承</p>
<p>修饰变量，变量就变成了常量，只能被赋值一次</p>
<p>修饰方法，方法不能被重写</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>jdk 推出了「内部类」的概念，当然，内部类不仅仅弥补了 Java 不能多继承的一个不足，通过将一个类定义在另一个类的内部，也可以有效的隐藏该类的可见性，等等。</p>
<p><strong>接口 + 内部类 = 多继承</strong></p>
<p>在这之前，Java 的继承机制主要由接口和单根继承实现，通过实现多个接口里的方法，看似能够实现多继承，但是并不总是高效的，因为一旦我们继承了一个接口就必然要实现它内部定义的所有方法。</p>
<p>现在我们可以通过内部类多次继承某个具体类或者接口，省去一些不必要的实现动作。只能说 Java 的内部类完善了它的多继承机制，而不是主要实现，因为内部类终究是一种破坏封装性的设计，除非有很强的把控能力，<strong>否则还是越少用越好</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String powerFul = <span class="string">"市长"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String wealthy = <span class="string">"一百万"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Extends_Father</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Extends_Mother</span> <span class="keyword">extends</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String father = <span class="keyword">new</span> Extends_Father().powerFul;</span><br><span class="line">        String mother = <span class="keyword">new</span> Extends_Mother().wealthy;</span><br><span class="line">        System.out.println(<span class="string">"my father is:"</span> + father + <span class="string">"my mother has:"</span> + mother);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，我们的 Son 类是不可能同时继承 Father 和 Mother 的，但是我们却可以通过在其内部定义内部类继承了 Father 和 Mother，必要的情况下，我们还能够重写继承而来的各个类的属性或者方法。</p>
<p>这就是典型的一种通过内部类实现多继承的实现方式，但是同时你也会发现，单单从 Son 来外表看，你根本不知道它内部多继承了 Father 和 Mother，从而往往会给我们带来一些错觉。所以你看，内部类并不绝对是一个好东西，它破坏了封装性，用的不好反而会适得其反，让你的程序一团糟，所以谨慎！</p>
<p>当然，并不是贬低它的价值，有些情况下它也能给你一种「四两拨千斤」的感觉，省去很多麻烦。下面我们看看几种不同的内部类类型。</p>
<p>从种类上说，内部类可以分为四类：普通内部类、静态内部类、匿名内部类、局部内部类。</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p><strong>普通内部类对象依赖外部类对象而存在</strong>，即在创建一个普通内部类对象时首先需要创建其外部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> outField1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> outField2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> outField3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outField4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在外部类对象内部，直接通过 new InnerClass(); 创建内部类对象</span></span><br><span class="line">        InnerClassA innerObj = <span class="keyword">new</span> InnerClassA();</span><br><span class="line">        System.out.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field1 字段的值为: "</span> + innerObj.field1);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field2 字段的值为: "</span> + innerObj.field2);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field3 字段的值为: "</span> + innerObj.field3);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field4 字段的值为: "</span> + innerObj.field4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> field3 = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//        static int field5 = 5; // 编译错误！普通内部类中不能定义 static 属性</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClassA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField1 字段的值为: "</span> + outField1);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField2 字段的值为: "</span> + outField2);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField3 字段的值为: "</span> + outField3);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField4 字段的值为: "</span> + outField4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClassTest outerObj = <span class="keyword">new</span> InnerClassTest();</span><br><span class="line">        <span class="comment">// 不在外部类内部，使用：外部类对象. new 内部类构造器(); 的方式创建内部类对象</span></span><br><span class="line"><span class="comment">//        InnerClassA innerObj = outerObj.new InnerClassA();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的内部类就像外部类声明的一个属性字段一样，因此其的对象时依附于外部类对象而存在的，我们来看一下结果：</p>
<p><img src="https://img-blog.csdn.net/20181022125507774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="å¨è¿éæå¥å¾çæè¿°"></p>
<p>我们注意到，内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段。</p>
<p><strong>Java 不允许成员内部类中定义静态的成员。</strong></p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类就是在代码块中定义一个类，最典型的应用是在方法中定义一个类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyInnerClass</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类，顾名思义，是没有名字的类，那么既然它没有名字，自然也就无法显式的创建出其实例对象了，所以匿名内部类适合那种只使用一次的情境，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个典型的匿名内部类的使用，它等效于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObj</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> MyObj();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了一个只使用一次的类而单独创建一个 .java 文件，是否有些浪费和繁琐？</p>
<p>在我看来，匿名内部类最大的好处就在于能够<strong>简化代码块</strong>。</p>
<p>显然，我们匿名内部类的构造器会调用相对应的父类构造器进行父类成员的初始化动作。而匿名内部类的本质也就这样，只是你看不到名字而已，其实编译器还是会为它生成单独的一份 Class 文件并拥有唯一的类名的。</p>
<p>其实你从编译器的层面上看，匿名内部类和一个实际的类型相差无几，它也能继承某个类并重写其中方法，实现某个接口的所有方法等。<strong>最吸引人的可能就是它无需单独创建类文件的简便性。</strong></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类通过对定义在外部类内部的类加上关键字「static」进行修饰，以标示一个静态内部类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String myName = <span class="string">"single"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> myAge = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            <span class="comment">//编译器报错提示：不可访问的字段 age</span></span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，MyInnnerClass 作为一个内部类，它可以定义自己的静态属性，静态方法，实例属性，实例方法，和普通类一样。</p>
<p>此外，由于 MyInnerClass 作为一个内部类，它对于外部类 OuterClass 中部分成员也是可见的，但并全部可见，不同类型的内部类可见的外部类成员不尽相同，例如我们的静态内部类对于外部类的以下成员时可见的：</p>
<ul>
<li>静态属性</li>
<li>静态方法</li>
</ul>
<p>所以，我们上述的例子中，外部类 OuterClass 的实例属性 age 对于静态内部类 MyInnerClass 是不可见的。</p>
<p>那么 Java 是如何做到在一个类的内部定义另一个类的呢？</p>
<p>实际上编译器在编译我们的外部类的时候，会扫描其内部是否还存在其他类型的定义，如果有那么会「搜集」这些类的代码，并按照某种特殊名称规则单独编译这些类。正如我们上述的 MyInnerClass 内部类会被单独编译成 OuterClass$MyInnerClass.class 文件。</p>
<p><img src="https://s1.ax1x.com/2018/04/17/Cm2qpT.png" alt="image"></p>
<p>当然，这里的特殊命名规则其实就是：<strong>外部类名 + $ + 内部类名</strong>。</p>
<p>如果你想要在外部直接创建一个静态内部类的实例，也是被允许的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建静态内部类实例</span></span><br><span class="line">    OuterClass.MyInnerClass innerClass = <span class="keyword">new</span> OuterClass.MyInnerClass();</span><br><span class="line">    innerClass.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这样的操作一般也不被推荐，因为一个内部类既然被定义在某个外围类的内部，那它一定是为这个外围类服务的，而你从外部越过外围类而单独创建内部类的实现显然是不符合面向对象设计思想的。</p>
<p>静态内部类的应用场景其实还是很多的，但有一个基本的设计准则是，静态内部类不需要依赖外围类的实例，独立于外围类，为外围类提供服务。</p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式：保证类在内存中只有一个对象。</p>
<p>如何保证类在内存中只有一个对象呢？</p>
<p>(1)控制类的创建，不让其他类来创建本类的对象。private</p>
<p>(2)在本类中定义一个本类的对象 。Singleton s;</p>
<p>(3)提供公共的访问方式。 public static Singleton getInstance(){return s}</p>
<p><strong>饿汉式的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.将构造方法私有化，不允许外部直接创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.创建类的唯一实例，使用private static修饰</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.提供一个用于获取实例的方法，使用public static修饰</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>懒汉式的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.将构造方式私有化，不允许外边直接创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.声明类的唯一实例，使用private static修饰</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.提供一个用于获取实例的方法，使用public static修饰</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法是在设计模式中常用的一种模式，它属于设计模式的创造类型模式，主要用来创建对象。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>创建对象需要大量重复的代码</li>
<li>客户端(应用层)不依赖与产品类实例如何被创建、实现细节</li>
<li>一个类通过其子类来指定创建那个对象</li>
</ul>
<p><strong>定义产品接口和工厂接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冰箱接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRefrigerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取品牌名</span></span><br><span class="line">    <span class="function">String <span class="title">getBrandName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取价格</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冰箱工厂接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRefrigeratorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">IRefrigerator <span class="title">getIRefrigerator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>产品实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 海尔冰箱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaiErRefrigerator</span> <span class="keyword">implements</span> <span class="title">IRefrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrandName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"海尔冰箱"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 美的冰箱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiDiRefrigerator</span> <span class="keyword">implements</span> <span class="title">IRefrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrandName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"美的冰箱"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格力冰箱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeLiRefrigerator</span> <span class="keyword">implements</span> <span class="title">IRefrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrandName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"格力冰箱"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工厂实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 海尔冰箱工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaiErRefrigeratorFactory</span> <span class="keyword">implements</span> <span class="title">IRefrigeratorFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRefrigerator <span class="title">getIRefrigerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HaiErRefrigerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 美的冰箱工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiDiRefrigeratorFactory</span> <span class="keyword">implements</span> <span class="title">IRefrigeratorFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRefrigerator <span class="title">getIRefrigerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MeiDiRefrigerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格力冰箱工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeLiRefrigeratorFactory</span> <span class="keyword">implements</span> <span class="title">IRefrigeratorFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRefrigerator <span class="title">getIRefrigerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GeLiRefrigerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IRefrigeratorFactory refrigeratorFactory = <span class="keyword">new</span> HaiErRefrigeratorFactory();</span><br><span class="line">        IRefrigeratorFactory refrigeratorFactory2 = <span class="keyword">new</span> GeLiRefrigeratorFactory();</span><br><span class="line">        IRefrigeratorFactory refrigeratorFactory3 = <span class="keyword">new</span> MeiDiRefrigeratorFactory();</span><br><span class="line">        IRefrigerator refrigerator = refrigeratorFactory.getIRefrigerator();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"您购买了："</span> + refrigerator.getBrandName() + <span class="string">"，您需要支付："</span> + refrigerator.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">您购买了：海尔冰箱，您需要支付：<span class="number">5999.0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1127551-3bd93cba6f64fb91.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1104/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1127551-d563ad864aa14a88.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/liulyuan/p/10318732.html" target="_blank" rel="noopener">https://www.cnblogs.com/liulyuan/p/10318732.html</a></p>
<p><a href="https://images2015.cnblogs.com/blog/1081488/201704/1081488-20170425113401365-1070846569.jpg" target="_blank" rel="noopener">https://images2015.cnblogs.com/blog/1081488/201704/1081488-20170425113401365-1070846569.jpg</a></p>
<p><a href="https://www.processon.com/view/link/5c920ad7e4b0ed6b43088a87#map" target="_blank" rel="noopener">https://www.processon.com/view/link/5c920ad7e4b0ed6b43088a87#map</a></p>
<p><a href="https://www.cnblogs.com/lifexy/p/10812841.html" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/10812841.html</a></p>
<p><a href="https://blog.csdn.net/luojun13class/article/details/83043100" target="_blank" rel="noopener">https://blog.csdn.net/luojun13class/article/details/83043100</a></p>
<p><a href="https://blog.csdn.net/qq_40180411/article/details/81385518" target="_blank" rel="noopener">https://blog.csdn.net/qq_40180411/article/details/81385518</a></p>
<p><a href="https://www.cnblogs.com/haiyuexiaozu/p/10986510.html" target="_blank" rel="noopener">https://www.cnblogs.com/haiyuexiaozu/p/10986510.html</a></p>
<p><a href="https://blog.csdn.net/My_name_is_ZwZ/article/details/80001121" target="_blank" rel="noopener">https://blog.csdn.net/My_name_is_ZwZ/article/details/80001121</a></p>
<p><a href="https://www.cnblogs.com/yangming1996/p/8869081.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangming1996/p/8869081.html</a></p>
<p><a href="https://blog.csdn.net/qq_33427267/article/details/84767419" target="_blank" rel="noopener">https://blog.csdn.net/qq_33427267/article/details/84767419</a></p>
<p><a href="https://www.jianshu.com/p/4c7d0ee96094" target="_blank" rel="noopener">https://www.jianshu.com/p/4c7d0ee96094</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">pangzibo243</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://litianbo243.github.io/2019/10/02/Java-面向对象总结/">https://litianbo243.github.io/2019/10/02/Java-面向对象总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/学习java/">学习java</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_zhifubao_code.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_weixin_code.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/10/01/Java-包装类/"><span>Java 包装类</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By pangzibo243</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>