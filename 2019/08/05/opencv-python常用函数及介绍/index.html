<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="opencv-python常用函数及其介绍"><meta name="keywords" content="python,opencv"><meta name="author" content="pangzibo243"><meta name="copyright" content="pangzibo243"><title>opencv-python常用函数及其介绍 | pangzibo243's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#读取图片、显示图片、写回图片"><span class="toc-text">读取图片、显示图片、写回图片</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cv2-imwrite-‘-home-ltb-图片-cv2-tutorial-000001-png’-img"><span class="toc-text"># cv2.imwrite(‘/home/ltb/图片/cv2-tutorial/000001.png’, img)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像通道顺序转换"><span class="toc-text">图像通道顺序转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读取视频流（单摄像头）"><span class="toc-text">读取视频流（单摄像头）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读取视频流（双摄像头）"><span class="toc-text">读取视频流（双摄像头）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读取视频（影片）"><span class="toc-text">读取视频（影片）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#写回视频"><span class="toc-text">写回视频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#绘图函数"><span class="toc-text">绘图函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#拆分通道、合并通道"><span class="toc-text">拆分通道、合并通道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像相加"><span class="toc-text">图像相加</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像扩展缩放"><span class="toc-text">图像扩展缩放</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Otsu二值化"><span class="toc-text">Otsu二值化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自适应二值化"><span class="toc-text">自适应二值化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简单二值化"><span class="toc-text">简单二值化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像腐蚀"><span class="toc-text">图像腐蚀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像膨胀"><span class="toc-text">图像膨胀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像匹配"><span class="toc-text">图像匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SIFT算法"><span class="toc-text">SIFT算法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_faceQ.png"></div><div class="author-info__name text-center">pangzibo243</div><div class="author-info__description text-center">pangzibo243's blog</div><div class="follow-button"><a href="https://github.com/litianbo243">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">56</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pangzibo243's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">opencv-python常用函数及其介绍</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="读取图片、显示图片、写回图片"><a href="#读取图片、显示图片、写回图片" class="headerlink" title="读取图片、显示图片、写回图片"></a>读取图片、显示图片、写回图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">print(cv2.__version__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_COLOR)   #读入一副彩色图像。图像的透明度会被忽略   默认参数。</span><br><span class="line"># img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_GRAYSCALE)  # Load an color image in grayscale 灰度</span><br><span class="line"># img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_UNCHANGED)  # 包括图像的 alpha 通道</span><br><span class="line"></span><br><span class="line">img = cv2.resize(img, (640, 480))</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">rows, cols, ch = img.shape</span><br><span class="line">print(&apos;行/高:&apos;, rows, &apos;列/宽:&apos;, cols, &apos;通道:&apos;, ch)</span><br><span class="line"># 图像的宽对应的是列数, 高对应的是行数。</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_NORMAL)  # 可以调整窗口大小</span><br><span class="line"># cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_AUTOSIZE)#自动调整</span><br><span class="line"># cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_KEEPRATIO)#保持图片比例</span><br><span class="line"></span><br><span class="line"># cv2.resizeWindow(&apos;image&apos;, 200, 200)  # 不起作用？</span><br><span class="line"></span><br><span class="line">cv2.imshow(&apos;image&apos;, img)  # 窗口会自动调整为图像大小</span><br><span class="line"># 在窗口上按任意键退出</span><br><span class="line">cv2.waitKey(delay=0)  # 返回按键的 ASCII 码值</span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<h1 id="cv2-imwrite-‘-home-ltb-图片-cv2-tutorial-000001-png’-img"><a href="#cv2-imwrite-‘-home-ltb-图片-cv2-tutorial-000001-png’-img" class="headerlink" title="# cv2.imwrite(‘/home/ltb/图片/cv2-tutorial/000001.png’, img)"></a># cv2.imwrite(‘/home/ltb/图片/cv2-tutorial/000001.png’, img)</h1><p>颜色转化<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/1/20 17:15</span><br><span class="line"># @Author  : play4fun</span><br><span class="line"># @File    : 颜色转换.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">颜色转换.py:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_COLOR)</span><br><span class="line">cv2.imshow(&quot;BGR&quot;, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(&quot;GRAY&quot;, gray)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 灰色转RGB</span><br><span class="line">cv2.imshow(&quot;RGB&quot;, temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure></p>
<h1 id="图像通道顺序转换"><a href="#图像通道顺序转换" class="headerlink" title="图像通道顺序转换"></a>图像通道顺序转换</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">path = <span class="string">"/home/ltb/1.jpg"</span></span><br><span class="line">data = cv2.imread(path)</span><br><span class="line">data = np.array(data)</span><br><span class="line">data = np.transpose(data, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">img = Image.fromarray(data)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure>
<h1 id="读取视频流（单摄像头）"><a href="#读取视频流（单摄像头）" class="headerlink" title="读取视频流（单摄像头）"></a>读取视频流（单摄像头）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Fri Jan 3 21:06:22 2014</span><br><span class="line">@author: duan</span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"> 注意 当你的程序报错时 你 先检查的是你的摄像头是否能够在其他程 序中正常工作 比如 linux 下的 Cheese 。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line">cap = cv2.VideoCapture(0)  # 一般的笔 本电脑 有内置摄像头。所以参数就是 0。你可以  设置成 1 或 者其他的来 择别的摄像头</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">你可以使用函数 cap.get(propId) 来获得  的一些参数信息。</span><br><span class="line">propId 可以是 0 到 18 之 的任何整数。</span><br><span class="line">其中的一些值可以使用 cap.set(propId,value) 来修改 value 就是 你想  置成的新值。</span><br><span class="line">例如 我可以使用 cap.get(3) cv2.CAP_PROP_FRAME_WIDTH和 cap.get(4) cv2.CAP_PROP_FRAME_HEIGHT来查看每一帧的宽和高。</span><br><span class="line">默认情况下得到的值是 640X480。但是我可以使用 ret=cap.set(3,320) 和 ret=cap.set(4,240) 来把宽和高改成 320X240。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"># ret=cap.set(3,320)</span><br><span class="line"># ret=cap.set(4,240)</span><br><span class="line"></span><br><span class="line"># ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, 480)#避免计算量过大</span><br><span class="line"># ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 270)#</span><br><span class="line"># 等比缩放</span><br><span class="line">frame_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)  # 4 ，720</span><br><span class="line">frame_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)  # 3   ，1280</span><br><span class="line">frame_height = int(480 / frame_width * frame_height)  # 270</span><br><span class="line">ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, frame_height)  # 高</span><br><span class="line">ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, 480)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># while (True):</span><br><span class="line">while cap.isOpened():  # 检查是否成功初始化，否则就 使用函数 cap.open()</span><br><span class="line">    # Capture frame-by-frame</span><br><span class="line">    ret, frame = cap.read()  # ret 返回一个布尔值 True/False</span><br><span class="line">    # print(&apos;frame shape:&apos;,frame.shape)#(720, 1280, 3)</span><br><span class="line"></span><br><span class="line">    frame = cv2.flip(frame, flipCode=1)  # 左右翻转,使用笔记本电脑摄像头才有用。</span><br><span class="line">    # flipCode：翻转方向：1：水平翻转；0：垂直翻转；-1：水平垂直翻转</span><br><span class="line"></span><br><span class="line">    # Our operations on the frame come here</span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    # Display the resulting frame</span><br><span class="line">    cv2.imshow(&apos;frame&apos;, gray)</span><br><span class="line">    cv2.setWindowTitle(&apos;frame&apos;, &apos;COLOR_BGR2GRAY&apos;)</span><br><span class="line"></span><br><span class="line">    # Property=cv2.getWindowProperty(&apos;frame&apos;,0)#无用</span><br><span class="line"></span><br><span class="line">    # if cv2.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):#不行</span><br><span class="line">    #     break</span><br><span class="line">    key = cv2.waitKey(delay=10)</span><br><span class="line">    if key == ord(&quot;q&quot;):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># When everything done, release the capture</span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="读取视频流（双摄像头）"><a href="#读取视频流（双摄像头）" class="headerlink" title="读取视频流（双摄像头）"></a>读取视频流（双摄像头）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2017/8/15 00:19</span><br><span class="line"># @Author  : play4fun</span><br><span class="line"># @File    : two_camera.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">two_camera.py:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">cap0 = cv2.VideoCapture(0)</span><br><span class="line">cap1 = cv2.VideoCapture(1)</span><br><span class="line">ret = cap0.set(3, 320)</span><br><span class="line">ret = cap0.set(4, 240)</span><br><span class="line">ret = cap1.set(3, 320)</span><br><span class="line">ret = cap1.set(4, 240)</span><br><span class="line"></span><br><span class="line">while cap0.isOpened() and cap1.isOpened():</span><br><span class="line">    ret0, frame0 = cap0.read()</span><br><span class="line">    ret1, frame1 = cap1.read()</span><br><span class="line"></span><br><span class="line">    if ret0:</span><br><span class="line">        cv2.imshow(&apos;frame0&apos;, frame0)</span><br><span class="line">        cv2.setWindowTitle(&apos;frame0&apos;, &apos;On Top&apos;)</span><br><span class="line">    if ret1:</span><br><span class="line">        cv2.imshow(&apos;frame1&apos;, frame1)</span><br><span class="line">        # cv2.moveWindow(&apos;frame1&apos;, x=frame0.shape[1], y=0)</span><br><span class="line">        cv2.moveWindow(&apos;frame1&apos;, x=320, y=40)</span><br><span class="line"></span><br><span class="line">    key = cv2.waitKey(delay=2)</span><br><span class="line">    if key == ord(&quot;q&quot;):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># When everything done, release the capture</span><br><span class="line">cap0.release()</span><br><span class="line">cap1.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="读取视频（影片）"><a href="#读取视频（影片）" class="headerlink" title="读取视频（影片）"></a>读取视频（影片）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(&apos;/home/ltb/视频/simplescreenrecorder-2019-04-14_00.52.45.mkv&apos;)</span><br><span class="line"># cap = cv2.VideoCapture(&apos;output.avi&apos;)</span><br><span class="line"># cap = cv2.VideoCapture(&apos;Minions_banana.mp4&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 帧率</span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)  # 25.0</span><br><span class="line">print(&quot;Frames per second using video.get(cv2.CAP_PROP_FPS) : &#123;0&#125;&quot;.format(fps))</span><br><span class="line"># 总共有多少帧</span><br><span class="line">num_frames = cap.get(cv2.CAP_PROP_FRAME_COUNT)</span><br><span class="line">print(&apos;共有&apos;, num_frames, &apos;帧&apos;)</span><br><span class="line">#</span><br><span class="line">frame_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)</span><br><span class="line">frame_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)</span><br><span class="line">print(&apos;高：&apos;, frame_height, &apos;宽：&apos;, frame_width)</span><br><span class="line"></span><br><span class="line">FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES)  # 第0帧</span><br><span class="line">print(&apos;当前帧数&apos;, FRAME_NOW)  # 当前帧数 0.0</span><br><span class="line"></span><br><span class="line"># 读取指定帧,对视频文件才有效，对摄像头无效？？</span><br><span class="line">frame_no = 121</span><br><span class="line">cap.set(1, frame_no)  # Where frame_no is the frame you want</span><br><span class="line">ret, frame = cap.read()  # Read the frame</span><br><span class="line">cv2.imshow(&apos;frame_no&apos;+str(frame_no), frame)</span><br><span class="line"></span><br><span class="line">FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES)</span><br><span class="line">print(&apos;当前帧数&apos;, FRAME_NOW)  # 当前帧数 122.0</span><br><span class="line"></span><br><span class="line">while cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES)  # 当前帧数</span><br><span class="line">    print(&apos;当前帧数&apos;, FRAME_NOW)</span><br><span class="line"></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(&apos;frame&apos;, gray)</span><br><span class="line">    key = cv2.waitKey(1)</span><br><span class="line">    if key == ord(&quot;q&quot;):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="写回视频"><a href="#写回视频" class="headerlink" title="写回视频"></a>写回视频</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(0)</span><br><span class="line">width = 640</span><br><span class="line">ret = cap.set(3, width)</span><br><span class="line">height = 480</span><br><span class="line">ret = cap.set(4, height)</span><br><span class="line"></span><br><span class="line"># Define the codec and create VideoWriter object</span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*&apos;XVID&apos;)  # opencv 3.0</span><br><span class="line"># Error: &apos;module&apos; object has no attribute &apos;VideoWriter_fourcc&apos;</span><br><span class="line"># fourcc=cv2.VideoWriter_fourcc(&apos;X&apos;, &apos;V&apos;, &apos;I&apos;, &apos;D&apos;)</span><br><span class="line">#jpeg,h263,&apos;m&apos;, &apos;p&apos;, &apos;4&apos;, &apos;v&apos;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">out = cv2.VideoWriter(&apos;output.avi&apos;, fourcc, 20.0, (width, height))</span><br><span class="line"></span><br><span class="line">while cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    if ret is True:</span><br><span class="line"></span><br><span class="line">        frame = cv2.resize(frame, (640, 480))</span><br><span class="line"></span><br><span class="line">        # write the flipped frame</span><br><span class="line">        out.write(frame)</span><br><span class="line"></span><br><span class="line">        cv2.imshow(&apos;frame&apos;, frame)</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">    key = cv2.waitKey(1)</span><br><span class="line">    if key == ord(&quot;q&quot;):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># Release everything if job is finished</span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="绘图函数"><a href="#绘图函数" class="headerlink" title="绘图函数"></a>绘图函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">• img: 你想 绘制图形的 幅图像。</span><br><span class="line">• color: 形状的颜色。以RGB为例  需要传入一个元组BGR 例如 255,0,0</span><br><span class="line">   代表蓝色，第一个是蓝色通道，第二个是绿色通道，第三个是红色通道。对于灰度图只需要传入灰度值。</span><br><span class="line">• thickness 线条的粗细。如果给一个闭合图形 置为 -1  那么这个图形</span><br><span class="line">就会被填充。 默认值是 1.</span><br><span class="line">• linetype 线条的类型， 8 连接，抗锯齿等。  默认情况是8 连接。cv2.LINE_AA</span><br><span class="line">   为抗锯齿  这样看起来会非常平滑。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"># Create a black image</span><br><span class="line">img = np.zeros((512, 512, 3), np.uint8)</span><br><span class="line"></span><br><span class="line"># Draw a diagonal blue line with thickness of 5 px</span><br><span class="line">cv2.line(img, pt1=(0, 0), pt2=(511, 511), color=(255, 0, 0), thickness=5)  # pt1, pt2, color, thickness=</span><br><span class="line"># cv2.polylines() 可以 用来画很多条线。只需要把想 画的线放在一 个列表中， 将 列表传给函数就可以了。每条线 会被独立绘制。 这会比用 cv2.line() 一条一条的绘制 要快一些。</span><br><span class="line"># cv2.polylines(img, pts, isClosed, color, thickness=None, lineType=None, shift=None)</span><br><span class="line">cv2.arrowedLine(img, pt1=(21, 13), pt2=(151, 401), color=(255, 0, 0), thickness=5)</span><br><span class="line"></span><br><span class="line">cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)</span><br><span class="line"></span><br><span class="line">cv2.circle(img, center=(447, 63), radius=63, color=(0, 0, 255), thickness=-1)  # center, radius, color, thickness=None</span><br><span class="line"></span><br><span class="line"># 一个参数是中心点的位置坐标。 下一个参数是长轴和短轴的长度。椭圆沿逆时针方向旋转的角度。</span><br><span class="line"># 椭圆弧演顺时针方向起始的角度和结束角度 如果是 0 很 360 就是整个椭圆</span><br><span class="line">cv2.ellipse(img, center=(256, 256), axes=(100, 50), angle=0, startAngle=0, endAngle=180, color=255,</span><br><span class="line">            thickness=-1)  # center, axes, angle, startAngle, endAngle, color, thickness=</span><br><span class="line"></span><br><span class="line">pts = np.array([[10, 5], [20, 30], [70, 20], [50, 10]], np.int32)</span><br><span class="line">pts = pts.reshape((-1, 1, 2))</span><br><span class="line"># 这里 reshape 的第一个参数为-1, 表明这一维的长度是根据后面的维度的计算出来的。</span><br><span class="line"># 注意 如果第三个参数是 False 我们得到的多边形是不闭合的 ，首 尾不相  连 。</span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line"># org :Bottom-left corner of the text string in the image.左下角</span><br><span class="line"># 或使用 bottomLeftOrigin=True,文字会上下颠倒</span><br><span class="line">cv2.putText(img, text=&apos;bottomLeftOrigin&apos;, org=(10, 400), fontFace=font, fontScale=1, color=(255, 255, 255), thickness=1, bottomLeftOrigin=True)  # text, org, fontFace, fontScale, color, thickness=</span><br><span class="line">cv2.putText(img, text=&apos;OpenCV&apos;, org=(10, 500), fontFace=font, fontScale=4, color=(255, 255, 255), thickness=2)  # text, org, fontFace, fontScale, color, thickness=</span><br><span class="line"></span><br><span class="line"># 所有的绘图函数的返回值都是 None ，所以不能使用 img = cv2.line(img,(0,0),(5</span><br><span class="line"></span><br><span class="line">winname = &apos;example&apos;</span><br><span class="line">cv2.namedWindow(winname, 0)</span><br><span class="line">cv2.imshow(winname, img)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(&quot;example.png&quot;, img)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="拆分通道、合并通道"><a href="#拆分通道、合并通道" class="headerlink" title="拆分通道、合并通道"></a>拆分通道、合并通道</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"># 拆分及合并图像通道</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">b, g, r = cv2.split(img)  # 比较耗时的操作，请使用numpy 索引</span><br><span class="line">img = cv2.merge((b, g, r))</span><br><span class="line">#</span><br><span class="line">b = img[:, :, 0]</span><br><span class="line"></span><br><span class="line"># 使所有像素的红色通道值都为 0,你不必先拆分再赋值。</span><br><span class="line"># 你可以 直接使用 Numpy 索引,这会更快。</span><br><span class="line">img[:, :, 2] = 0</span><br><span class="line"></span><br><span class="line"># 保存到文件，看下效果</span><br><span class="line">cv2.imwrite(filename=&apos;split_color2.jpg&apos;, img=img)</span><br></pre></td></tr></table></figure>
<h1 id="图像相加"><a href="#图像相加" class="headerlink" title="图像相加"></a>图像相加</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 学习图像上的算术运算 加法 减法 位运算等</span><br><span class="line"></span><br><span class="line"># 你可以使用函数 cv2.add() 将两幅图像进行加法运算 当然也可以直接使 用 numpy ，</span><br><span class="line"># res=img1+img</span><br><span class="line"># 两幅图像的大小 类型必须一致 ，或者第二个 图像可以使一个简单的标量值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.uint8([250])</span><br><span class="line">y = np.uint8([10])</span><br><span class="line">print(cv2.add(x, y))  # 250+10 = 260 =&gt; 255</span><br><span class="line"># [[255]]</span><br><span class="line">print(x + y)  # 250+10=260%256=4</span><br><span class="line"># [4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 图像混合</span><br><span class="line">img1 = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)</span><br><span class="line">img2 = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.png&apos;)</span><br><span class="line"></span><br><span class="line">dst = cv2.addWeighted(img1, 0.1, img2, 0.9, 0)  # 第一幅图的权重是 0.7 第二幅图的权重是 0.3</span><br><span class="line"></span><br><span class="line">cv2.imshow(&apos;dst&apos;, dst)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="图像扩展缩放"><a href="#图像扩展缩放" class="headerlink" title="图像扩展缩放"></a>图像扩展缩放</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">扩展缩放</span><br><span class="line">在缩放时我们推荐使用 cv2.INTER_AREA</span><br><span class="line">在扩展时我们推荐使用 v2.INTER_CUBIC 慢) 和 v2.INTER_LINEAR。</span><br><span class="line">默认情况下所有改变图像尺寸大小的操作使用的插值方法 是 cv2.INTER_LINEAR。</span><br><span class="line">Resize(src, dst, interpolation=CV_INTER_LINEAR)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)</span><br><span class="line"># 下面的 None 本应 是 出图像的尺寸 但是因为后边我们设置了缩放因子</span><br><span class="line"># 因此这里为 None</span><br><span class="line">res = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line"># OR</span><br><span class="line"># 我们直接设置输出图像的尺寸 所以不用设置缩放因子</span><br><span class="line"># height, width = img.shape[:2]</span><br><span class="line"># res = cv2.resize(img, (2 * width, 2 * height), interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line">cv2.imshow(&apos;resize&apos;, res)</span><br><span class="line">cv2.imshow(&apos;src img&apos;, img)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="Otsu二值化"><a href="#Otsu二值化" class="headerlink" title="Otsu二值化"></a>Otsu二值化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">Otsu&apos;s 二值化</span><br><span class="line">在第一 分中我们提到  retVal 当我们使用 Otsu 二值化时会用到它。  么它到底是什么呢</span><br><span class="line">在使用全局 值时 我们就是 便给了一个数来做 值  我们怎么知  我们 取的 个数的好坏呢?</span><br><span class="line"> 答案就是不停的尝 。</span><br><span class="line"> 如果是一副双峰图像 ，简 单来 双峰图像是指图像直方图中存在两个峰 呢 ？</span><br><span class="line"> 我们岂不是应 在两个峰 之 的峰  一个值作为阈值 。</span><br><span class="line">  就是 Otsu 二值化 做的。</span><br><span class="line">  简单来说，就是对一副双峰图像自动根据其直方图计算出一个阈值。</span><br><span class="line">  对于非双峰图像 这 种方法 得到的结果可能会不理想 。</span><br><span class="line"> 这里 用到的函数 是 cv2.threshold() 但是  需要多传入一个参数  flag  cv2.THRESH_OTSU。</span><br><span class="line">  这时 把 值 为 0。然后算法会找到最 优阈值 ，这 个最优 值就是 回值 retVal。</span><br><span class="line">  如果不使用 Otsu 二值化 返回的retVal 值与 设定的 阈值相等。</span><br><span class="line">下 的例子中  输入图像是一副带有噪声的图像。</span><br><span class="line">第一种方法 我们 设127 为全局 阈值。</span><br><span class="line">第二种方法 我们直接使用 Otsu 二值化。</span><br><span class="line">第三种方法 我 们 先使用一个 5x5 的 高斯核 去噪  然后再使用 Otsu 二值化。</span><br><span class="line">看看噪音 去除对结果的影响有多大吧。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)</span><br><span class="line"># global thresholding</span><br><span class="line">ret1, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)</span><br><span class="line"># Otsu&apos;s thresholding</span><br><span class="line">ret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"># Otsu&apos;s thresholding after Gaussian filtering</span><br><span class="line"># 5,5 为 斯核的大小 0 为标准差</span><br><span class="line">blur = cv2.GaussianBlur(img, (5, 5), 0)</span><br><span class="line"># 阀值一定为 0</span><br><span class="line">ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"># plot all the images and their histograms</span><br><span class="line">images = [img, 0, th1,</span><br><span class="line">          img, 0, th2,</span><br><span class="line">          blur, 0, th3]</span><br><span class="line">titles = [&apos;Original Noisy Image&apos;, &apos;Histogram&apos;, &apos;Global Thresholding (v=127)&apos;,</span><br><span class="line">          &apos;Original Noisy Image&apos;, &apos;Histogram&apos;, &quot;Otsu&apos;s Thresholding&quot;,</span><br><span class="line">          &apos;Gaussian filtered Image&apos;, &apos;Histogram&apos;, &quot;Otsu&apos;s Thresholding&quot;]</span><br><span class="line"># 使用了 pyplot 中画直方图的方法 plt.hist,</span><br><span class="line"># 注意的是它的参数是一维数组</span><br><span class="line"># 所以使用了 numpy ravel 方法 将多维数组 换成一维 也可以使用 flatten 方法</span><br><span class="line"># ndarray.flat 1-D iterator over an array.</span><br><span class="line"># ndarray.flatten 1-D array copy of the elements of an array in row-major order.</span><br><span class="line"></span><br><span class="line">for i in range(3):</span><br><span class="line">    plt.subplot(3, 3, i * 3 + 1), plt.imshow(images[i * 3], &apos;gray&apos;)</span><br><span class="line">    plt.title(titles[i * 3]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(3, 3, i * 3 + 2), plt.hist(images[i * 3].ravel(), 256)</span><br><span class="line">    plt.title(titles[i * 3 + 1]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(3, 3, i * 3 + 3), plt.imshow(images[i * 3 + 2], &apos;gray&apos;)</span><br><span class="line">    plt.title(titles[i * 3 + 2]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="自适应二值化"><a href="#自适应二值化" class="headerlink" title="自适应二值化"></a>自适应二值化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">自适应阈值</span><br><span class="line">Adaptive Method- 指定 算阈值的方法。</span><br><span class="line">– cv2.ADPTIVE_THRESH_MEAN_C  值取自相邻区域的平均值</span><br><span class="line">– cv2.ADPTIVE_THRESH_GAUSSIAN_C  值取值相邻区域 的加权和 ，权重为一个高斯窗口</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)</span><br><span class="line"># 中值滤波</span><br><span class="line">img = cv2.medianBlur(img, 5)</span><br><span class="line">ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"># 11 为 Block size 邻域大小 用来计算阈值的区域大小 ,</span><br><span class="line"># 2 为 C值，常数， 阈值就等于的平均值或者加权平均值减去这个常数。</span><br><span class="line">th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)</span><br><span class="line"></span><br><span class="line">titles = [&apos;Original Image&apos;, &apos;Global Thresholding (v = 127)&apos;,</span><br><span class="line">          &apos;Adaptive Mean Thresholding&apos;, &apos;Adaptive Gaussian Thresholding&apos;]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line">for i in range(4):</span><br><span class="line">    plt.subplot(2, 2, i + 1), plt.imshow(images[i], &apos;gray&apos;)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="简单二值化"><a href="#简单二值化" class="headerlink" title="简单二值化"></a>简单二值化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">简单阈值</span><br><span class="line">像素值高于阈值时 我们给这个像素 赋予一个新值， 可能是白色 ，</span><br><span class="line"> 否则我们给它赋予另外一种颜色， 或是黑色 。</span><br><span class="line"> 这个函数就是 cv2.threshhold()。</span><br><span class="line"> 这个函数的第一个参数就是原图像</span><br><span class="line"> 原图像应 是灰度图。</span><br><span class="line"> 第二个参数就是用来对像素值进行分类的阈值。</span><br><span class="line"> 第三个参数 就是当像素值高于， 有时是小于  阈值时应该被赋予的新的像素值。</span><br><span class="line"> OpenCV 提供了多种不同的阈值方法 ， 是由第四个参数来决定的。</span><br><span class="line">  些方法包括</span><br><span class="line">• cv2.THRESH_BINARY</span><br><span class="line">• cv2.THRESH_BINARY_INV • cv2.THRESH_TRUNC</span><br><span class="line">• cv2.THRESH_TOZERO</span><br><span class="line">• cv2.THRESH_TOZERO_INV</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)</span><br><span class="line"></span><br><span class="line">ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)</span><br><span class="line">ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)</span><br><span class="line">ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)</span><br><span class="line">ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)</span><br><span class="line">ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [&apos;Original Image&apos;, &apos;BINARY&apos;, &apos;BINARY_INV&apos;, &apos;TRUNC&apos;, &apos;TOZERO&apos;, &apos;TOZERO_INV&apos;]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"></span><br><span class="line">for i in range(6):</span><br><span class="line">    plt.subplot(2, 3, i + 1), plt.imshow(images[i], &apos;gray&apos;)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="图像腐蚀"><a href="#图像腐蚀" class="headerlink" title="图像腐蚀"></a>图像腐蚀</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">两个基本的形态学操作是腐蚀和膨胀。他们 的变体构成了开运算 ，闭运算， 梯度等。</span><br><span class="line">根据卷积核的大小  前景的所有像素 会 腐  掉 变为 0  ，所以前景物体会变小 整幅图像的白色区域会减少。</span><br><span class="line">对于去除白噪声很有用 也可以用来断开两个 在一块的物体等。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)</span><br><span class="line">cv2.imshow(&apos;Origin&apos;, img)</span><br><span class="line">print(img.shape)</span><br><span class="line"></span><br><span class="line">#您可以将内核看作是一个小矩阵，我们在图像上滑动以进行（卷积）操作，例如模糊，锐化，边缘检测或其他图像处理操作。</span><br><span class="line">kernel = np.ones((5, 5), np.uint8)</span><br><span class="line">erosion = cv2.erode(img, kernel, iterations=1)</span><br><span class="line"></span><br><span class="line">cv2.imshow(&apos;erode&apos;, erosion)</span><br><span class="line">cv2.moveWindow(&apos;erode&apos;, x=img.shape[1], y=0)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="图像膨胀"><a href="#图像膨胀" class="headerlink" title="图像膨胀"></a>图像膨胀</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">与腐 相反 与卷积核对应的原图像的像素值中只 有一个是 1 中心元 素的像素值就是 1。所以 个操作会增加图像中的白色区域 前景 。一般在去 噪声时先用腐 再用膨胀。因为腐 在去掉白噪声的同时 也会使前景对 变 小。所以我们再对他  膨胀。 时噪声已经 去 了 不会再回来了 但是 前景 在并会增加。膨胀也可以用来 接两个分开的物体。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)</span><br><span class="line">cv2.imshow(&apos;Origin&apos;, img)</span><br><span class="line">print(img.shape)</span><br><span class="line"></span><br><span class="line">kernel = np.ones((5, 5), np.uint8)</span><br><span class="line">dilation = cv2.dilate(img, kernel, iterations=1)</span><br><span class="line"></span><br><span class="line">cv2.imshow(&apos;dilation&apos;, dilation)</span><br><span class="line">cv2.moveWindow(&apos;dilation&apos;, x=img.shape[1], y=0)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="图像匹配"><a href="#图像匹配" class="headerlink" title="图像匹配"></a>图像匹配</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*-coding:utf8-*-#</span><br><span class="line">__author__ = &apos;play4fun&apos;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">create time:15-10-24 下午5:46</span><br><span class="line">原理</span><br><span class="line">模板匹配是用来在一副大图中搜寻查找模版图像位置的方法。OpenCV 为 我们提供了函数 cv2.matchTemplate()。</span><br><span class="line">和 2D 卷积一样 它也是用模板图像在输入图像 大图 上滑动 并在每一个位置对模板图像和与其对应的 输入图像的子区域  比较。</span><br><span class="line">OpenCV 提供了几种不同的比较方法 细节 看 文档 。</span><br><span class="line">返回的结果是一个灰度图像 每一个像素值 示了此区域与模板的匹配 程度。</span><br><span class="line">如果输入图像的大小是 WxH</span><br><span class="line">模板的大小是 wxh   输出的结果 的大小就是 W-w+1 H-h+1 。</span><br><span class="line">当你得到这幅图之后 就可以使用函数 cv2.minMaxLoc() 来找到其中的最小值和最大值的位置了。</span><br><span class="line">第一个值为矩形左上角的点 位置</span><br><span class="line">w h 为 moban 模板矩形的宽和 。</span><br><span class="line">这个矩形就是 找到的模板区域了。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;../data/messi5.jpg&apos;, 0)</span><br><span class="line">img2 = img.copy()</span><br><span class="line">template = cv2.imread(&apos;../data/messi_face.jpg&apos;, 0)</span><br><span class="line"></span><br><span class="line">w, h = template.shape[::-1]</span><br><span class="line"># All the 6 methods for comparison in a list</span><br><span class="line">methods = [&apos;cv2.TM_CCOEFF&apos;, &apos;cv2.TM_CCOEFF_NORMED&apos;, &apos;cv2.TM_CCORR&apos;,</span><br><span class="line">           &apos;cv2.TM_CCORR_NORMED&apos;, &apos;cv2.TM_SQDIFF&apos;, &apos;cv2.TM_SQDIFF_NORMED&apos;]</span><br><span class="line"></span><br><span class="line">for meth in methods:</span><br><span class="line">    img = img2.copy()</span><br><span class="line"></span><br><span class="line">    # exec 语句用来执行储存在字符串或文件中的 Python 语句。</span><br><span class="line">    # 例如,我们可以在运行时生成一个包含 Python 代码的字符串,</span><br><span class="line">    # 然后使用 exec 语句执行这些语句。</span><br><span class="line">    # eval 语句用来计算存储在字符串中的有效 Python 表达式</span><br><span class="line">    method = eval(meth)</span><br><span class="line">    # Apply template Matching</span><br><span class="line">    res = cv2.matchTemplate(img, template, method)</span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line">    # 使用不同的比较方法,对结果的解释不同</span><br><span class="line">    # If the method is TM_SQDIFF or TM_SQDIFF_NORMED, take minimum</span><br><span class="line">    if method in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:</span><br><span class="line">        top_left = min_loc</span><br><span class="line">    else:</span><br><span class="line">        top_left = max_loc</span><br><span class="line"></span><br><span class="line">    bottom_right = (top_left[0] + w, top_left[1] + h)</span><br><span class="line">    cv2.rectangle(img, top_left, bottom_right, 255, 2)</span><br><span class="line"></span><br><span class="line">    plt.subplot(121), plt.imshow(res, cmap=&apos;gray&apos;)</span><br><span class="line">    plt.title(&apos;Matching Result&apos;), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(122), plt.imshow(img, cmap=&apos;gray&apos;)</span><br><span class="line">    plt.title(&apos;Detected Point&apos;), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.suptitle(&apos;method: &apos; + meth)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="SIFT算法"><a href="#SIFT算法" class="headerlink" title="SIFT算法"></a>SIFT算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2017/7/13 下午2:23</span><br><span class="line"># @Author  : play4fun</span><br><span class="line"># @File    : sift.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">sift.py:尺度不变特征变换</span><br><span class="line">关键点 极值点 定位</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line">kp = sift.detect(gray, None)</span><br><span class="line">img = cv2.drawKeypoints(gray, kp, img)</span><br><span class="line"></span><br><span class="line"># 计算关键点描述符</span><br><span class="line"># 使用函数 sift.compute() 来 计算 些关键点的描述符。例如</span><br><span class="line"># kp, des = sift.compute(gray, kp)</span><br><span class="line">kp, des = sift.detectAndCompute(gray, None)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(&apos;sift_keypoints.jpg&apos;, img)</span><br><span class="line">cv2.imshow(&apos;sift_keypoints.jpg&apos;, img)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">pangzibo243</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://litianbo243.github.io/2019/08/05/opencv-python常用函数及介绍/">https://litianbo243.github.io/2019/08/05/opencv-python常用函数及介绍/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/opencv/">opencv</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_zhifubao_code.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/my_weixin_code.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/05/Ubuntu shell 常用指令 指南/"><i class="fa fa-chevron-left">  </i><span>Ubuntu常用指令</span></a></div><div class="next-post pull-right"><a href="/2019/08/05/visdom使用指南/"><span>visdom使用指南</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/litianbo243/litianbo243.github.io/master/images/chen_sir_1.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By pangzibo243</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>