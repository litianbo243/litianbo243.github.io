{"meta":{"title":"pangzibo243's blog","subtitle":"a man can be destroyed, but not defeated.","description":"pangzibo243's blog","author":"pangzibo243","url":"https://litianbo243.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-03","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"08-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-03","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"08-05","excerpt":""}],"posts":[{"title":"Docker使用指南","text":"1. 查看docker服务器是否正常sudo docker info 2. 运行容器sudo docker run -i -t ubuntu /bin/bashsudo docker run -i -t 镜像名称 命令代码 3. 使用容器# 查看系统中存在的容器docker ps -a 4. 容器命名sudo docker run --name litianbo_test -i -t ubuntu /bin/bashsudo docker run --name 容器名称 -i -t 镜像名称 命令代码 5. 启动已停止的容器# 根据容器名称启动sudo docker start litianbo_test# 根据容器id启动sudo docker start 41225bc38698 6. 进行容器内部命令行sudo docker attach litianbo_test 7. 创建守护式容器sudo docker run --name litianbo_test -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 8. 查看容器日志sudo docker logs litianbo_testsudo docker logs -f litianbo_test 9. 查看容器内进程sudo docker top litianbo_test 10. 在容器内运行进程sudo docker exec -it litianbo_test /bin/bash 11. 停止守护式容器sudo docker stop litianbo_test 12. 自动重启容器sudo docker run --restart=always --name litianbo_test -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 13. 查看容器详细信息sudo docker inspect litianbo_test 14. 删除容器sudo docker rm litianbo_test 15. 查看镜像列表sudo docker images 16. 拉取镜像sudo docker pull ubuntu# 运行时指定tagsudo docker run -it ubuntu:16.04 /bin/bash# 对于一个仓库而言，完整的格式如下：[用户名称/]仓库名称:tag 17. 查找镜像sudo docker search keywords 18. 构建镜像 使用docker commit构建 使用docker build和Dockerfile文件来构建# 创建docker hub账号# 通过命令在本地绑定对应的Docker Hub账号sudo docker login# commit# 根据某个镜像创建一个容器# 对该容器进行一些修改# 提交该容器并生成一个新的镜像sudo docker run -it ubuntu /bin/bashroot@b3f9427a5039:/# apt-get -yqq updateroot@b3f9427a5039:/# apt-get -y install apache2root@b3f9427a5039:/# exitsudo docker commit b3f9427a5039 ltb/apache2sudo docker images# -m=”message” 可以用于对提交的镜像添加一些文本描述# –author=”person” 可以用于添加提交人信息# 提交时，我们可以设置tagsudo docker commit -m=&quot;install apache&quot; --author=&quot;ltb&quot; b3f9427a5039 ltb/apache:v1# 查看镜像详细信息sudo inspect ltb/apache2:v1# 用心镜像创建容器sudo docker run -it ltb/apache2:v1 /bin/bash# dockerfile# 先创建一个工作目录，并在目录中创建一个dockerfile文件mkdir workdircd ./workdirtouch dockerfile# 编辑dockerfile文件FROM ubuntu:14.04MAINTAINER Wangzhe0912 &quot;Wangzhe0912@tju.edu.cn&quot;RUN apt-get updateRUN apt-get install -y nginxRUN echo &quot;Hi, I am your contrainer&quot; &gt; /usr/share/nginx/html/index.htmlEXPOSE 80# 基于dockerfile构建新镜像# 写完dockerfile文件后，可以执行docker build命令生成一个新的镜像# 在本地当前目录下寻找dockerfile文件docker build -t=&quot;ltb/nginx:v1&quot;` .# 指定git仓库寻找dockfile文件docker build -t=&quot;wangzhe0912/nginx:v1&quot;` git@github.com:wangzhe0912/docker_web# dockerfile构建缓存# 希望强制忽略缓存时，可以额外添加--no-cache参数进行设置sudo docker build --no-cache -t=&quot;ltb/nginx:v1&quot;# 基于构建缓存的dockfile模板# 添加了一行环境变量ENVFROM ubuntu:14.04MAINTAINER Wangzhe0912 &quot;Wangzhe0912@tju.edu.cn&quot;ENV REFRESHED_AT 2018-01-28RUN apt-get update...# 查看新镜像构建过程docker history image_name/id# 从新镜像启动容器# -d表示后台程序进行运行# -p 80表示运行时公开80端口给宿主机docker run -d -p 80 --name ltb_nginx ltb/nginx:v1 nginx -g &quot;daemon off;&quot;# 端口查询docker port ltb_nginx 80# 访问地址curl localhost:32768 19. 将镜像推送至Docker Hubsudo docker push ltb/nginx 20. 删除镜像sudo docker rmi 镜像名称 21.登录DockerHubsudo docker login# 输入账号密码 22.Docker免sudo操作sudo groupadd dockercat /ect/groupsudo gpasswd -a $&#123;USER&#125; dockernewgrp - docker 23.管理网络# 创建自定义网络docker network create iccd# 删除自定义网络docker network rm iccd","path":"2019/08/05/docker使用指南/","date":"08-05","excerpt":"","tags":[{"name":"docker","slug":"docker","permalink":"https://litianbo243.github.io/tags/docker/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://litianbo243.github.io/tags/虚拟化/"},{"name":"常用指令","slug":"常用指令","permalink":"https://litianbo243.github.io/tags/常用指令/"}]},{"title":"服务器管理指南","text":"1.给root用户设置一个密码sudo passwd root 2.查看所有用户和用户组cat /etc/passwdcat /etc/group 3.添加用户sudo suadduser ltb 4.删除用户deluser --remove-all-files ltb 5.添加用户到用户组sudo usermod -aG iccd ltb 6.创建用户组sudo groupadd iccd 7.删除用户组sudo groupdel iccd 8.修改用户组权限vim /etc/sudoers 9.nfs等操作# 下载nfssudo apt-get install nfs-kernal-server# 重启nfssudo /etc/init.d/nfs-kernal-server restart# 修改配置文件sudo vi /etc/export&quot;&quot;&quot;加上/amax-share *(rw,sync,no_root_squash,no_subtree_check)&quot;&quot;&quot;# mount操作sudo mount X.X.X.X：/amax-share /home/ltb/AMAX# umount操作sudo umount /home/ltb/AMAX","path":"2019/08/05/服务器管理指南/","date":"08-05","excerpt":"","tags":[{"name":"常用指令","slug":"常用指令","permalink":"https://litianbo243.github.io/tags/常用指令/"},{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"管理","slug":"管理","permalink":"https://litianbo243.github.io/tags/管理/"}]},{"title":"Ubuntu常用指令","text":"Ubuntu常用指令石墨版: Ubuntu指南. su和sudo：得到root权限sudo passwd [root] # 设定root密码su [root] # 切换到root用户sudo COMMAND # 切换到root用户，执行COMMAND，然后切换回当前用户su USER # 切换回普通用户USER apt和dpkg：用于安装软件包apt list # 根据名称列出软件包apt show PACKAGE # 显示软件包细节sudo apt-get install PACKAGE # 安装软件包sudo apt-get remove PACKAGE # 卸载软件包sudo apt-get check PACKAGE # 检查依赖sudo apt-get update # 更新可用软件包列表sudo apt upgrade # 通过升级来更新系统sudo apt-get install -f # 修复依赖sudo dpkg -i xxx.deb # 运行deb程序进行安装 pip：用于安装python模块（不是linux里的默认指令，需自行安装sudo apt-get install pip）sudo apt-get install python3-pip # 安装python3下的pip# 更新pip到指定版本python3 -m pip install --user --upgrade pip==9.0.3 # (换成你想要的版本编号)# pip临时加速pip 加参数-i https://pypi.tuna.tsinghua.edu.cn/simple # pip永久加速# Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\"\"\"[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com\"\"\"# windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。pip install PACKAGE # 安装包pip uninstall PACKAGE # 卸载包pip search PACKAGE # 搜索能安装的包pip list # 例出所有的已安装的包pip show PACKAGE # 展示已安装包的信息，可以指定单个包名展示 pip check PACKAGE # 检查依赖pip --version # 显示pip版本和位置pip help # 查看帮助pip help install # 查看install指令的相关option介绍 ssh和scp：用于主机间的通信ssh USERNAME@IP -p PORTNUM # 远程登录到主机scp LOCAL_FILE USERNAME@IP:REMOTE_DIRECTORY # 复制本地文件到远程主机scp -r LOCAL_FILE USERNAME@IP:REMOTE_DIRECTORY # 复制本地文件夹到远程主机sudo ufw dissable # 关闭防火墙sudo ufw enable # 开启防火墙sudo apt-get install vsftpd # 安装sftpservice vsftpd starrt # 启用sftp zip,unzip,tar,rar,unrar：压缩和解压gzip # gzip是Linux使用最广的压缩指令gzip [-cdtv#] FILENAME\"\"\"-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6\"\"\"bzip2 # 提供比gzip更高的压缩比bzip2 [-cdkzv#] FILENAME\"\"\"-k ：保留源文件\"\"\"xz2 # 提供比bzip2更佳的压缩比xz [-dtlkc#] FILENAMEtar 压缩打包tar [-z|-j|-J][cv][-f NEW_TAR_FILE] FILE # 打包压缩tar [-z|-j|-J][tv][-f TAR_FILE] # 查看tar [-z|-j|-J][xv][-f TAR_FILE] [-C DIR] # 解压\"\"\"-z ：使用 zip-j ：使用 bzip2-J ：使用 xz-c ：新建打包文件-t ：查看打包文件里面有哪些文件-x ：解打包或解压缩的功能-v ：在压缩/解压缩的过程中，显示正在处理的文件名-f : filename：要处理的文件-C DIR ： 在特定目录解压缩\"\"\"# 例1tar -jcv -f file.tar.bz2 file # 压缩tar -jxv -f file.tar.bz2 -C ./file # 解压tar -zcv -f dir.tar.gz dir1 dir2 ... # 多个文件压缩# 例2tar -zcv file | split -b 4000M -d -a 1 - file.tar.gz. # 压缩成多个压缩包# 使用split命令\"\"\"-b 4000M 表示设置每个分割包的大小，单位还是可以k-d 参数指定生成的分割包后缀为数字的形式-a x来设定序列的长度(默认值是2)\"\"\"cat file.tar.gz.* | tar -zxv file 多个压缩包解压 du和df：查看磁盘的存储占用和查看文件系统的存储占用du -s # 仅显示总计，只列出最后加的总值du -c # 除了显示个别文件或目录的大小外，还显示一行目录和文件的总和大小du -h # 以k,m,g为单位，提高信息的可读性du --max-depth=1 # 查看当前目录所有（一级）文件的大小du -sh *.mkv # 显示每个mkv文件的大小du -csh *.mkv # 显示每个mkv文件的大小和总和df -h # 以k,m,g为单位，提高信息的可读性df -T # 显示文件系统的类型 which,whereis,locate,find：查找命令#which在PATH变量制定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果#whereis只能用于程序名的搜索，而且只能搜索二进制文件（-b），man说明文件（-m），源代码文件（-s）。若省略，则返回所有信息#locate配合数据库查看文件位置。linux会将系统内所有文件记录在一个数据库文件中，电视该数据库并不是实时更新#find实际搜寻硬盘查询文件名称find . -name \"*.conf\" 当前目录查找扩展名为.conf的文件updatedb 更新数据库locate STRING 快速查找系统数据库中指定的内容which python 查询pythonwhereis python 查询python 文件权限chmod [ugoa][+-=][rwx] FILE|DIR # 改变指定目录或文件的权限# u代表该文件所有者，g代表该文件所有者的同组用户，o代表其他，a表示这三者皆是# r可读，w可写，x可执行chomd u+x test # 该文件的所有者增加可执行的权限# 用数字表示，规定r=4,w=2,x=1chmod 777 file # 三种用户都赋予可读可写可执行的权限chown -R 用户名[:组名] 文件名或目录 # 改变指定目录或文件的所属用户，-R代表递归地改变目录下的所有文件 文件和文本操作ls [-adl] FILE|DIR # 列出文件或者目录信息\"\"\"-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据\"\"\"cd DIR # 更换当前路径mkdir [-mp] DIR # 创建目录\"\"\"-m ：配置目录权限-p ：递归创建目录\"\"\"rmdir [-p] DIR # 删除目录，目录必须为空\"\"\"-p ：递归删除目录\"\"\"touch [-acdmt] FILENAME # 更新文件时间或者建立新文件\"\"\"-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=\"日期或时间\"-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]\"\"\"cp [-adfilprsu] SOURCE DESTINATION # 复制文件\"\"\"-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制\"\"\"rm [-fir] FILE|DIR # 删除文件或者目录\"\"\"-r ：递归删除\"\"\"mv [-fiu] SOURCE DESTINATION # 移动文件\"\"\"-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\"\"\"ln [-sf] SOURCE DESTINATION # 创建链接\"\"\"-s ：默认是 hard link，加 -s 为 symbolic link-f ：如果目标文件存在时，先删除目标文件\"\"\"cat [-n] FILENAME # 获取文件内容\"\"\"-n ：打印出行号，连同空白行也会有行号，-b 不会\"\"\"grep str /tmp/test # 在文件/tmp/test中查找strgrep ^str /tmp/test # 在文件/tmp/test中查找以str开始的行ls -ld */ # 显示当前目录的所有目录文件ls -l | grep '^d' # 显示当前目录的所有目录文件wc -l # 统计文件行数wc -w # 统计单词数量ls -l | wc -l # 统计当前目前的文件数量，注意要减去“总用量”那一行cp -a dir1 dir2 # 复制目录mv dir1 dir2 # 移动/重命名目录mkdir -p /tmp/dir1/dir2 # 创建一个目录树rm -f file1 # 删除文件rm -rf dir1 # 删除目录ln -s /real_file /soft_link # 创建软链接 进程ps -e # 显示所有进程ps -f # 全格式显示进程ps -u 'liaohuqiang' | grep 'tmux' # 显示指定用户执行的进程，并匹配出包含'tmux'的那一行进程ps -ef | grep 'python' | grep -v grep # 把grep命令排除掉ps -ef | grep 'python' | grep -v grep | awk '&#123;print $2&#125;' # 提取进程号pstree -A #查看进程树kill -2 PID # 类似ctrl+C，在程序结束之前能够保存相关数据，再退出kill -9 PID # 直接强制结束进程reboot # 重启shutdown -r now # 立刻重启shutdown -r 30 # 30分钟后重启shutdown -r 23:00 # 晚上11点重启halt # 立刻关机poweroff # 立刻关机shutdown -h now # 立刻关机shutdown -h 30 # 30分钟后关机shutdown -c # 取消shutdwon的重启或关机command &amp; # 使指令成为后台任务nohup # 不挂断地运行命令，通常和&amp;一起用，输出将附加到目录的nohup.outjobs -l # 列出任务列表，l表示显示进程号（只查看当前终端的，关闭终端后无法看到）fg # 把最近一个job切换到前台fg n # 把某个job切换到前台ctrl z # 挂起某个前台进程bg # 把作业放到后台运行top # 动态显示进程信息top -i # 不显示任何闲置或无用的进程\"\"\"k 杀死某进程n 改变显示的进程数量u 显示指定用户P 按CPU使用情况排序q 退出\"\"\"lscpu # 查看cpu信息概要# 监视cpu# 先安装matstatsudo apt install sysstat# 每两秒查看一次mpstat -P ALL 2 网络netstat # 显示网络情况netstat -a # 列出所有端口netstat -l # 只显示监听端口netstat -t # 列出所有tcp端口netstat -p # 显示使用该端口的pid和程序名称netstat -n # 直接使用ip地址，不通过域名服务器# 找出程序运行的端口 netstat -anp | grep ssh# 找出运行在指定端口的进程 netstat -anp | grep ':80'ifconfig # 查看网卡信息 查看电脑配置free -m # 查看内存使用情况df # 查看磁盘使用情况cat /proc/cpuinfo # 查看cpu信息lspci | grep VGA # 查看显卡nvidia-smi # 查看英伟达系列显卡的使用情况nvidia-smi -L # 查看显卡型号watch -n 1 -d nvidia-smi # 实时监控nvidia-smi，每隔一秒刷新一次，d表示高亮 cat /proc/driver/nvidia/version # 查看显卡驱动cat /etc/issue # 查看ubuntu版本 vim简单操作vim可以分为三种模式：命令模式（Command mode）、插入模式（Insert mode）和底线命令模式（Last line mode）Comand mode：控制屏幕光标的移动，字符或光标的删除，移动复制某区段及进入Insert mode下，或者到Last line mode。Insert mode：唯有在Insert mode下，才可做文字数据输入，按Esc等可回到Comand mode。Last line mode：将储存文件或离开编辑器，也可设置编辑环境，如寻找字符串、列出行号等。 在Command mode下按‘i’、‘a’或‘o’三键就可进入Insert mode。这时候您就可以开始输入文字了i: 插入，从目前光标所在之处插入所输入的文字a: 增加，目前光标所在的下一个字开始输入文字o: 插入新的一行，从行首开始输入文字Insert的切换→Command mode，按Esc键您目前处于Insert mode，您就只能一直打字。假如您发现打错字了，想用光标键往回移动，将该字删除，就要按ESC键转换回Command mode，再删除文字 在Command mode下，可按冒号“：”键入入Last line mode，例如：:w filename (输入“w filename”，将文章存入指定的文件名filename):wq (输入“wq”，因为进入之时已经指定文件名testfile，所以会写入testfile并离开vi):q! (输入“q!”，强制离开并放弃编辑的文件) x：每按一次删除光标所在位置的后面一个字符dd：删除光标所在行yy：复制光标所在行u：假如您误操作一个指令，可以马上按u，回复到上一个操作 其他date # 显示时间whoami # 显示当前用户名who # 目前登录系统的用户信息curl 'url' -O --progress # 下载文件,-O代表保存文件（如果没有则输出到屏幕）, --progress表示会显示进度条 # (curl不是linux的默认自行，需自行安装apt install curl)echo $SHELL # 查看系统使用的是哪种shellecho $PATH # 查看环境变量xdg-open filename # 用默认应用程序打开文件python run_generation.py | tee vggTrainResult # 重定向到文件 cat /usr/local/cuda/version.txt # 查看cuda版本cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 # 查看cudnn版本 参考https://www.cnblogs.com/liaohuiqiang/p/7191462.html","path":"2019/08/05/Ubuntu shell 常用指令 指南/","date":"08-05","excerpt":"","tags":[{"name":"常用指令","slug":"常用指令","permalink":"https://litianbo243.github.io/tags/常用指令/"},{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://litianbo243.github.io/tags/shell/"}]},{"title":"python 多线程、多进程","text":"导读真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。当然，真正地同时执行多线程需要多核CPU才可能实现。 我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。 多线程添加线程# 导入模块import threading# 获取已激活的线程数threading.active_count()# 查看所有线程信息threading.enumerate()# 查看现在正在运行的线程threading.current_thread()# 添加线程，threading.Thread()接收参数target代表这个线程要完成的任务def thread_job(): print(&apos;This is a thread of %s&apos; % threading.current_thread())def main(): thread = threading.Thread(target=thread_job,) # 定义线程 thread.start() # 让线程开始工作 if __name__ == &apos;__main__&apos;: main() join功能使用join对控制多个线程的执行顺序非常关键。join功能是等待调用线程完成再继续下面的操作。推荐如下这种1221的V型排布。示例代码 def T1_job(): print(&quot;T1 start\\n&quot;) for i in range(10): time.sleep(0.1) print(&quot;T1 finish\\n&quot;)def T2_job(): print(&quot;T2 start\\n&quot;) print(&quot;T2 finish\\n&quot;)thread_1 = threading.Thread(target=T1_job, name=&apos;T1&apos;)thread_2 = threading.Thread(target=T2_job, name=&apos;T2&apos;)----------------------------------------------------------------------thread_1.start() # start T1thread_2.start() # start T2thread_2.join() # join for T2thread_1.join() # join for T1print(&quot;all done\\n&quot;)&quot;&quot;&quot;T1 startT2 startT2 finishT1 finishall done&quot;&quot;&quot; setDaemon功能setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(),这个的意思是，把主线程A设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出.这就是setDaemon方法的含义，这基本和join是相反的。示例代码 import threading import time class MyThread(threading.Thread): def __init__(self,id): threading.Thread.__init__(self) def run(self): time.sleep(5) print &quot;This is &quot; + self.getName() if __name__ == &quot;__main__&quot;: t1=MyThread(999) t1.setDaemon(True) t1.start() print &quot;I am the father thread.&quot; &quot;&quot;&quot;I am the father thread.&quot;&quot;&quot;# 可以看出，子线程t1中的内容并未打出。 线程锁Locklock在不同线程使用同一共享内存时，能够确保线程之间互不影响，使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。示例代码 import threadingdef job1(): global A,lock lock.acquire() for i in range(10): A+=1 print(&apos;job1&apos;,A) lock.release()def job2(): global A,lock lock.acquire() for i in range(10): A+=10 print(&apos;job2&apos;,A) lock.release()if __name__== &apos;__main__&apos;: lock=threading.Lock() A=0 t1=threading.Thread(target=job1) t2=threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join() &quot;&quot;&quot;job1 1job1 2job1 3job1 4job1 5job1 6job1 7job1 8job1 9job1 10job2 20job2 30job2 40job2 50job2 60job2 70job2 80job2 90job2 100job2 110&quot;&quot;&quot; 其他常用操作import threading# 队列from queue import Queuedef job(i, q): print(&quot;i&apos;m thread &#123;&#125; &quot;.format(i)) i = i**2 # 将结果存入队列中，因为多线程函数不能有return q.put(i) q =Queue()threads = []for i in range(4): t = threading.Thread(target=job,args=(i, q)) t.start() # 将进程加入列表 threads.append(t)# 逐个joinfor thread in threads: thread.join() # 得到队列中元素，result# 测试后发现结果顺序有一定概率不准确。。。result = []for _ in range(4): result.append(q.get()) print(result) GILPython 的设计上, 有一个必要的环节, 就是 Global Interpreter Lock (GIL). 这个东西让 Python 还是一次性只能处理一个东西. GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。 所以Python的多线程就是假的。。。。 多进程Python提供多进程的原因很简单, 就是用来弥补 threading 的一些劣势, 比如在 GIL. 添加进程示例代码 # 多进程import multiprocessing as mpdef job(a,d): print(&apos;aaaaa&apos;) print(mp.current_process())if __name__==&apos;__main__&apos;: p1 = mp.Process(target=job,args=(1,2)) print(mp.current_process()) p1.start() p1.join() 进程池进程池就是我们将所要运行的东西，放到池子里，Python会自行解决多进程的问题示例代码 import multiprocessing as mpdef job(x): return x*x # 定义一个poolpool = mp.Pool()# 有了池子之后，就可以让池子对应某一个函数，我们向池子里丢数据，池子就会返回函数返回的值。Pool和之前的Process的不同点是丢向Pool的函数有返回值，而Process的没有返回值。# 接下来用map()获取结果，在map()中需要放入函数和需要迭代运算的值，然后它会自动分配给CPU核res = pool.map(job, range(10))print(res) 自定义核数量Pool默认大小是CPU的核数，我们也可以通过在Pool中传入processes参数即可自定义需要的核数量。示例代码 def multicore(): pool = mp.Pool(processes=3) # 定义CPU核数量为3 res = pool.map(job, range(10)) print(res) apply_async示例代码 import multiprocessing as mpdef job(x): return x*xpool = mp.Pool()multi_res = [pool.apply_async(job, (i,)) for i in range(10)]print([res.get() for res in multi_res])# 和map差不多 共享内存我们可以通过使用Value数据存储在一个共享的内存表中。 import multiprocessing as mpvalue1 = mp.Value(&apos;i&apos;, 0) value2 = mp.Value(&apos;d&apos;, 3.14) 其中d和i参数用来设置数据类型的，d表示一个双精浮点类型，i表示一个带符号的整型。更多的形式请查看此表. | Type code | C Type | Python Type | Minimum size in bytes || --------- | ------------------ | ----------------- | --------------------- || `&apos;b&apos;` | signed char | int | 1 || `&apos;B&apos;` | unsigned char | int | 1 || `&apos;u&apos;` | Py_UNICODE | Unicode character | 2 || `&apos;h&apos;` | signed short | int | 2 || `&apos;H&apos;` | unsigned short | int | 2 || `&apos;i&apos;` | signed int | int | 2 || `&apos;I&apos;` | unsigned int | int | 2 || `&apos;l&apos;` | signed long | int | 4 || `&apos;L&apos;` | unsigned long | int | 4 || `&apos;q&apos;` | signed long long | int | 8 || `&apos;Q&apos;` | unsigned long long | int | 8 || `&apos;f&apos;` | float | float | 4 || `&apos;d&apos;` | double | float | 8 | 在Python的mutiprocessing中，有还有一个Array类，可以和共享内存交互，来实现在进程之间共享数据。 array = mp.Array(&apos;i&apos;, [1, 2, 3, 4]) 这里的Array和numpy中的不同，它只能是一维的，不能是多维的。同样和Value 一样，需要定义数据形式，否则会报错。 进程锁为了解决不同进程抢共享资源的问题，我们可以用加进程锁来解决。示例代码 import multiprocessing as mpimport timedef job(v, num, l): l.acquire() # 锁住 for _ in range(5): time.sleep(0.1) v.value += num # 获取共享内存 print(v.value) l.release() # 释放def multicore(): l = mp.Lock() # 定义一个进程锁 v = mp.Value(&apos;i&apos;, 0) # 定义共享内存 p1 = mp.Process(target=job, args=(v,1,l)) # 需要将lock传入 p2 = mp.Process(target=job, args=(v,3,l)) p1.start() p2.start() p1.join() p2.join()if __name__ == &apos;__main__&apos;: multicore() &quot;&quot;&quot;12345811141720&quot;&quot;&quot;# 显然，进程锁保证了进程p1的完整运行，然后才进行了进程p2的运行","path":"2019/08/05/python 多线程、多进程/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"多线程","slug":"多线程","permalink":"https://litianbo243.github.io/tags/多线程/"},{"name":"多进程","slug":"多进程","permalink":"https://litianbo243.github.io/tags/多进程/"}]},{"title":"tkinter使用指南","text":"Tkinter模块元素简要说明| tkinter类 | 元素 ||:—-:|:—-:|:—-:|:—-:|| Button | 按钮 || Canvas | 画布 || Checkbutton | 复选框 || Entry | 单行文本框 || Frame | 框架 || Label | 标签 || LabelFrame | 容器控件 || Listbox | 列表框 || Menu | 菜单 || Menubutton | 菜单按钮 || Message | 消息框 || OptionMenu | 选择菜单 || PanedWindow | 窗口布局管理 || Radiobutton | 单选框 || Scale | 进度条 || Scrollbar | 滚动条 || Spinbox | 输入控件 || Text | 多行文本框 || Toplevel | 顶层 || messageBox | 消息框 | Tkinter支持16个核心的窗口部件，这个16个核心窗口部件类简要描述如下：Button：一个简单的按钮，用来执行一个命令或别的操作。Canvas：组织图形。这个部件可以用来绘制图表和图，创建图形编辑器，实现定制窗口部件。Checkbutton：代表一个变量，它有两个不同的值。点击这个按钮将会在这两个值间切换。Entry：文本输入域。Frame：一个容器窗口部件。帧可以有边框和背景，当创建一个应用程序或dialog(对话）版面时，帧被用来组织其它的窗口部件。Label：显示一个文本或图象。Listbox：显示供选方案的一个列表。listbox能够被配置来得到radiobutton或checklist的行为。Menu：菜单条。用来实现下拉和弹出式菜单。Menubutton：菜单按钮。用来实现下拉式菜单。Message：显示一文本。类似label窗口部件，但是能够自动地调整文本到给定的宽度或比率。Radiobutton：代表一个变量，它可以有多个值中的一个。点击它将为这个变量设置值，并且清除与这同一变量相关的其它radiobutton。Scale：允许你通过滑块来设置一数字值。Scrollbar：为配合使用canvas, entry, listbox, and text窗口部件的标准滚动条。Text：格式化文本显示。允许你用不同的样式和属性来显示和编辑文本。同时支持内嵌图象和窗口。Toplevel：一个容器窗口部件，作为一个单独的、最上面的窗口显示。messageBox：消息框，用于显示你应用程序的消息框。(Python2中为tkMessagebox)注意在Tkinter中窗口部件类没有分级；所有的窗口部件类在树中都是兄弟关系。所有这些窗口部件提供了Misc和几何管理方法、配置管理方法和部件自己定义的另外的方法。此外，Toplevel类也提供窗口管理接口。这意味一个典型的窗口部件类提供了大约150种方法。 动手实践学习创建主窗口及Label部件的创建和使用示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定标签l = tk.Label(window, text=&apos;你好！this is Tkinter&apos;, bg=&apos;green&apos;, font=(&apos;Arial&apos;, 12), width=30, height=2)# 说明： bg为背景，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高 # 第5步，放置标签l.pack() # Label内容content区域放置位置，自动调节尺寸# 放置lable的方法有：1）l.pack(); 2)l.place(); # 第6步，主窗口循环显示window.mainloop()# 注意，loop因为是循环的意思，window.mainloop就会让window不断的刷新，如果没有mainloop,就是一个静态的window,传入进去的值就不会有循环，mainloop就相当于一个很大的while循环，有个while，每点击一次就会更新一次，所以我们必须要有循环 测试效果 Button窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定标签var = tk.StringVar() # 将label标签的内容设置为字符类型，用var来接收hit_me函数的传出内容用以显示在标签上l = tk.Label(window, textvariable=var, bg=&apos;green&apos;, fg=&apos;white&apos;, font=(&apos;Arial&apos;, 12), width=30, height=2)# 说明： bg为背景，fg为字体颜色，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高l.pack() # 定义一个函数功能（内容自己自由编写），供点击Button按键时调用，调用命令参数command=函数名on_hit = Falsedef hit_me(): global on_hit if on_hit == False: on_hit = True var.set(&apos;you hit me&apos;) else: on_hit = False var.set(&apos;&apos;) # 第5步，在窗口界面设置放置Button按键b = tk.Button(window, text=&apos;hit me&apos;, font=(&apos;Arial&apos;, 12), width=10, height=1, command=hit_me)b.pack() # 第6步，主窗口循环显示window.mainloop() 测试效果 Entry窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定输入框控件entry并放置控件e1 = tk.Entry(window, show=&apos;*&apos;, font=(&apos;Arial&apos;, 14)) # 显示成密文形式e2 = tk.Entry(window, show=None, font=(&apos;Arial&apos;, 14)) # 显示成明文形式e1.pack()e2.pack() # 第5步，主窗口循环显示window.mainloop() 测试效果 Text窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定输入框控件entry框并放置e = tk.Entry(window, show = None)#显示成明文形式e.pack() # 第5步，定义两个触发事件时的函数insert_point和insert_end（注意：因为Python的执行顺序是从上往下，所以函数一定要放在按钮的上面）def insert_point(): # 在鼠标焦点处插入输入内容 var = e.get() t.insert(&apos;insert&apos;, var)def insert_end(): # 在文本框内容最后接着插入输入内容 var = e.get() t.insert(&apos;end&apos;, var) # 第6步，创建并放置两个按钮分别触发两种情况b1 = tk.Button(window, text=&apos;insert point&apos;, width=10, height=2, command=insert_point)b1.pack()b2 = tk.Button(window, text=&apos;insert end&apos;, width=10, height=2, command=insert_end)b2.pack() # 第7步，创建并放置一个多行文本框text用以显示，指定height=3为文本框是三个字符高度t = tk.Text(window, height=3)t.pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 Listbox窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置var1 = tk.StringVar() # 创建变量，用var1用来接收鼠标点击具体选项的内容l = tk.Label(window, bg=&apos;green&apos;, fg=&apos;yellow&apos;,font=(&apos;Arial&apos;, 12), width=10, textvariable=var1)l.pack() # 第6步，创建一个方法用于按钮的点击事件def print_selection(): value = lb.get(lb.curselection()) # 获取当前选中的文本 var1.set(value) # 为label设置值 # 第5步，创建一个按钮并放置，点击按钮调用print_selection函数b1 = tk.Button(window, text=&apos;print selection&apos;, width=15, height=2, command=print_selection)b1.pack() # 第7步，创建Listbox并为其添加内容var2 = tk.StringVar()var2.set((1,2,3,4)) # 为变量var2设置值# 创建Listboxlb = tk.Listbox(window, listvariable=var2) #将var2的值赋给Listbox# 创建一个list并将值循环添加到Listbox控件中list_items = [11,22,33,44]for item in list_items: lb.insert(&apos;end&apos;, item) # 从最后一个位置开始加入值lb.insert(1, &apos;first&apos;) # 在第一个位置加入&apos;first&apos;字符lb.insert(2, &apos;second&apos;) # 在第二个位置加入&apos;second&apos;字符lb.delete(2) # 删除第二个位置的字符lb.pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 Radiobutton窗口控件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置var = tk.StringVar() # 定义一个var用来将radiobutton的值和Label的值联系在一起.l = tk.Label(window, bg=&apos;yellow&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义选项触发函数功能def print_selection(): l.config(text=&apos;you have selected &apos; + var.get()) # 第5步，创建三个radiobutton选项，其中variable=var, value=&apos;A&apos;的意思就是，当我们鼠标选中了其中一个选项，把value的值A放到变量var中，然后赋值给variabler1 = tk.Radiobutton(window, text=&apos;Option A&apos;, variable=var, value=&apos;A&apos;, command=print_selection)r1.pack()r2 = tk.Radiobutton(window, text=&apos;Option B&apos;, variable=var, value=&apos;B&apos;, command=print_selection)r2.pack()r3 = tk.Radiobutton(window, text=&apos;Option C&apos;, variable=var, value=&apos;C&apos;, command=print_selection)r3.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Checkbutton窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置l = tk.Label(window, bg=&apos;yellow&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义触发函数功能def print_selection(): if (var1.get() == 1) &amp; (var2.get() == 0): # 如果选中第一个选项，未选中第二个选项 l.config(text=&apos;I love only Python &apos;) elif (var1.get() == 0) &amp; (var2.get() == 1): # 如果选中第二个选项，未选中第一个选项 l.config(text=&apos;I love only C++&apos;) elif (var1.get() == 0) &amp; (var2.get() == 0): # 如果两个选项都未选中 l.config(text=&apos;I do not love either&apos;) else: l.config(text=&apos;I love both&apos;) # 如果两个选项都选中 # 第5步，定义两个Checkbutton选项并放置var1 = tk.IntVar() # 定义var1和var2整型变量用来存放选择行为返回值var2 = tk.IntVar()c1 = tk.Checkbutton(window, text=&apos;Python&apos;,variable=var1, onvalue=1, offvalue=0, command=print_selection) # 传值原理类似于radiobutton部件c1.pack()c2 = tk.Checkbutton(window, text=&apos;C++&apos;,variable=var2, onvalue=1, offvalue=0, command=print_selection)c2.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Scale窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置l = tk.Label(window, bg=&apos;green&apos;, fg=&apos;white&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义一个触发函数功能def print_selection(v): l.config(text=&apos;you have selected &apos; + v)# 第5步，创建一个尺度滑条，长度200字符，从0开始10结束，以2为刻度，精度为0.01，触发调用print_selection函数s = tk.Scale(window, label=&apos;try me&apos;, from_=0, to=10, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=2, resolution=0.01, command=print_selection)s.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Canvas窗口部件示例代码 from PIL import Imagefrom PIL import ImageTkimport tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，在图形界面上创建 500 * 200 大小的画布并放置各种元素canvas = tk.Canvas(window, bg=&apos;green&apos;, height=200, width=500)# 说明图片位置，并导入图片到画布上image_file = Image.open(&quot;/home/ltb/timg.jpeg&quot;).resize((500, 300))image_file = ImageTk.PhotoImage(image_file)# image_file = tk.PhotoImage(file=&apos;/home/ltb/timg.gif&apos;) # 图片位置（相对路径，与.py文件同一文件夹下，也可以用绝对路径，需要给定图片具体绝对路径）image = canvas.create_image(250, 0, anchor=&apos;n&apos;, image=image_file) # 图片锚定点（n图片顶端的中间点位置）放在画布（250,0）坐标处# 定义多边形参数，然后在画布上画出指定图形x0, y0, x1, y1 = 100, 100, 150, 150line = canvas.create_line(x0 - 50, y0 - 50, x1 - 50, y1 - 50) # 画直线oval = canvas.create_oval(x0 + 120, y0 + 50, x1 + 120, y1 + 50, fill=&apos;white&apos;) # 画圆 用黄色填充arc = canvas.create_arc(x0, y0 + 50, x1, y1 + 50, start=0, extent=180) # 画扇形 从0度打开收到180度结束rect = canvas.create_rectangle(330, 30, 330 + 20, 30 + 20) # 画矩形正方形canvas.pack()# 第6步，触发函数，用来一定指定图形def moveit(): canvas.move(rect, 2, 2) # 移动正方形rect（也可以改成其他图形名字用以移动一起图形、元素），按每次（x=2, y=2）步长进行移动# 第5步，定义一个按钮用来移动指定图形的在画布上的位置b = tk.Button(window, text=&apos;move item&apos;, command=moveit).pack()# 第7步，主窗口循环显示window.mainloop()# 在一个类中创建Canvas需要把要显示再画布上的图片声明为全局变量，不然画布无法显示图片。 图像锚定点位置参数图测试效果 Menu窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，在图形界面上创建一个标签用以显示内容并放置l = tk.Label(window, text=&apos; &apos;, bg=&apos;green&apos;)l.pack()# 第10步，定义一个函数功能，用来代表菜单选项的功能，这里为了操作简单，定义的功能比较简单counter = 0def do_job(): global counter l.config(text=&apos;do &apos; + str(counter)) counter += 1# 第5步，创建一个菜单栏，这里我们可以把他理解成一个容器，在窗口的上方menubar = tk.Menu(window)# 第6步，创建一个File菜单项（默认不下拉，下拉内容包括New，Open，Save，Exit功能项）filemenu = tk.Menu(menubar, tearoff=0)# 将上面定义的空菜单命名为File，放在菜单栏中，就是装入那个容器中menubar.add_cascade(label=&apos;File&apos;, menu=filemenu)# 在File中加入New、Open、Save等小菜单，即我们平时看到的下拉菜单，每一个小菜单对应命令操作。filemenu.add_command(label=&apos;New&apos;, command=do_job)filemenu.add_command(label=&apos;Open&apos;, command=do_job)filemenu.add_command(label=&apos;Save&apos;, command=do_job)filemenu.add_separator() # 添加一条分隔线filemenu.add_command(label=&apos;Exit&apos;, command=window.quit) # 用tkinter里面自带的quit()函数# 第7步，创建一个Edit菜单项（默认不下拉，下拉内容包括Cut，Copy，Paste功能项）editmenu = tk.Menu(menubar, tearoff=0)# 将上面定义的空菜单命名为 Edit，放在菜单栏中，就是装入那个容器中menubar.add_cascade(label=&apos;Edit&apos;, menu=editmenu)# 同样的在 Edit 中加入Cut、Copy、Paste等小命令功能单元，如果点击这些单元, 就会触发do_job的功能editmenu.add_command(label=&apos;Cut&apos;, command=do_job)editmenu.add_command(label=&apos;Copy&apos;, command=do_job)editmenu.add_command(label=&apos;Paste&apos;, command=do_job)# 第8步，创建第二级菜单，即菜单项里面的菜单submenu = tk.Menu(filemenu) # 和上面定义菜单一样，不过此处实在File上创建一个空的菜单filemenu.add_cascade(label=&apos;Import&apos;, menu=submenu, underline=0) # 给放入的菜单submenu命名为Import# 第9步，创建第三级菜单命令，即菜单项里面的菜单项里面的菜单命令（有点拗口，笑~~~）submenu.add_command(label=&apos;Submenu_1&apos;, command=do_job) # 这里和上面创建原理也一样，在Import菜单项中加入一个小菜单命令Submenu_1# 第11步，创建菜单栏完成后，配置让菜单栏menubar显示出来window.config(menu=menubar)# 第12步，主窗口循环显示window.mainloop() 测试效果 Frame窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签用以显示内容并放置tk.Label(window, text=&apos;on the window&apos;, bg=&apos;red&apos;, font=(&apos;Arial&apos;, 16)).pack() # 和前面部件分开创建和放置不同，其实可以创建和放置一步完成 # 第5步，创建一个主frame，长在主window窗口上frame = tk.Frame(window)frame.pack() # 第6步，创建第二层框架frame，长在主框架frame上面frame_l = tk.Frame(frame)# 第二层frame，左frame，长在主frame上frame_r = tk.Frame(frame)# 第二层frame，右frame，长在主frame上frame_l.pack(side=&apos;left&apos;)frame_r.pack(side=&apos;right&apos;) # 第7步，创建三组标签，为第二层frame上面的内容，分为左区域和右区域，用不同颜色标识tk.Label(frame_l, text=&apos;on the frame_l1&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_l, text=&apos;on the frame_l2&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_l, text=&apos;on the frame_l3&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r1&apos;, bg=&apos;yellow&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r2&apos;, bg=&apos;yellow&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r3&apos;, bg=&apos;yellow&apos;).pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 messageBox窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入import tkinter.messagebox # 要使用messagebox先要导入模块 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第5步，定义触发函数功能def hit_me(): tkinter.messagebox.showinfo(title=&apos;Hi&apos;, message=&apos;你好！&apos;) # 提示信息对话窗 # tkinter.messagebox.showwarning(title=&apos;Hi&apos;, message=&apos;有警告！&apos;) # 提出警告对话窗 # tkinter.messagebox.showerror(title=&apos;Hi&apos;, message=&apos;出错了！&apos;) # 提出错误对话窗 # print(tkinter.messagebox.askquestion(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # 询问选择对话窗return &apos;yes&apos;, &apos;no&apos; # print(tkinter.messagebox.askyesno(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # return &apos;True&apos;, &apos;False&apos; # print(tkinter.messagebox.askokcancel(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # return &apos;True&apos;, &apos;False&apos; # 第4步，在图形界面上创建一个标签用以显示内容并放置tk.Button(window, text=&apos;hit me&apos;, bg=&apos;green&apos;, font=(&apos;Arial&apos;, 14), command=hit_me).pack() # 第6步，主窗口循环显示window.mainloop() 测试效果 窗口部件三种放置方式 pack/grid/placepack按上下左右的方式排列 示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，pack 放置方法tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;top&apos;) # 上tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;bottom&apos;) # 下tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;left&apos;) # 左tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;right&apos;) # 右# 第5步，主窗口循环显示window.mainloop() 测试效果 grid所有的内容会被放在这些规律的方格中 示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，grid 放置方法for i in range(3): for j in range(3): tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10, ipadx=10, ipady=10)# 第5步，主窗口循环显示window.mainloop() 测试效果 place给精确的坐标来定位 示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，place 放置方法（精准的放置到指定坐标点的位置上）tk.Label(window, text=&apos;Pl&apos;, font=(&apos;Arial&apos;, 20), ).place(x=50, y=100, anchor=&apos;nw&apos;) # 第5步，主窗口循环显示window.mainloop() 测试效果 Tkinter布局之pack我们使用pack函数的时候，默认先使用的放在上面，然后依次向下排，它会给我们的部件一个自认为合适的位置和大小，这是默认方式。 side 按钮停靠的位置left：左top：上right：右bottom：下 fill 填充x：水平方向填充y：竖直方向填充both：水平和竖直方向填充none：不填充 expand 扩展yes：扩展整个空白区no：不扩展 部件消除示例代码 # 销毁上一个布局的frame及其部件# 先销毁frame下的部件，再销毁framefor widget in self.last_frame.winfo_children(): widget.destroy()self.last_frame.destroy() 多线程按钮部件示例代码 # 打开摄像头button_open_camera = tk.Button(self.frame_3, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading)button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;)# 关闭摄像头button_close_camera = tk.Button(self.frame_3, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera)button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;)# 线程函数def camera_threading(self): self.thread = threading.Thread(target=self.open_camera) self.thread.setDaemon(True) self.thread.start() # 打开摄像头函数，被线程函数调用def open_camera(self): try: cap = cv2.VideoCapture(0) self.thread_flag = True while(self.thread_flag): ret, frame = cap.read() cv2.imshow(&quot;video&quot;, frame) cv2.imwrite(self.temporary_path, frame) if ret != True: break c = cv2.waitKey(60) if c == 27: break cv2.destroyAllWindows() cap.release() except: messagebox.showerror(title=&quot;读取视频出错&quot;, message=&quot;读取出错或未检测到usb摄像头&quot;) # 关闭摄像头函数，用全局变量控制def close_camera(self): self.thread_flag = False os._exit(0) 第一个Tkinter程序from PIL import Imagefrom PIL import ImageTkimport tkinter as tkfrom tkinter import filedialog, messageboximport threadingimport cv2import osimport shutilfrom datetime import datetimeclass AppUI(): def __init__(self): # 全局变量 self.first = True self.last_frame = None self.thread_flag = False self.temporary_path = &quot;/mnt/tkinter_pj1/temporary_picture.jpg&quot; self.database = &quot;/mnt/tkinter_pj1/Images/all&quot; # 存线程实例 self.thread_obj = [] # 创建窗口 self.window = tk.Tk() self.window.title(&quot;手术器械自动识别系统&quot;) self.window.geometry(&quot;500x200&quot;) # 参数 self.main_menu() self.main_layout() self.window.mainloop() # 主菜单 def main_menu(self): self.menu_bar = tk.Menu(self.window) self.start_menu = tk.Menu(self.menu_bar, tearoff=0) self.menu_bar.add_cascade(label=&quot;开始&quot;, menu=self.start_menu) self.start_menu.add_command(label=&quot;首页&quot;, command=self.main_layout) self.start_menu.add_command(label=&quot;单张图像预测&quot;, command=self.layout_2) self.start_menu.add_command(label=&quot;实时图像检测&quot;, command=self.layout_3) self.start_menu.add_command(label=&quot;图像采集&quot;, command=self.layout_4) self.window.config(menu=self.menu_bar) def main_layout(self): if self.first == False: # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;500x200&quot;) self.first = False self.main_frame = tk.Frame(self.window) self.main_frame.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.main_frame label_main_frame_title = tk.Label(self.main_frame, text=&apos;欢迎来到手术器械自动识别系统&apos;, font=(&apos;Arial&apos;, 17), height=3) label_main_frame_title.pack(side=&quot;top&quot;, fill=&quot;both&quot;) # 三个button button_single_predict = tk.Button(self.main_frame, text=&apos;单张图像识别&apos;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_2) button_single_predict.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) button_realtime_predict = tk.Button(self.main_frame, text=&quot;实时图像识别&quot;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_3) button_realtime_predict.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) button_catch_picture = tk.Button(self.main_frame, text=&quot;图像采集&quot;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_4) button_catch_picture.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) def layout_2(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) # 创建frame_2 self.frame_2 = tk.Frame(self.window) self.frame_2.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_2 label_frame_2_title = tk.Label(self.frame_2, text=&apos;单张图像识别&apos;, font=(&apos;Arial&apos;, 15), height=3, width=30) label_frame_2_title.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_2, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 选择路径 button_picture_path = tk.Button(self.frame_2, text=&quot;选择路径&quot;, height=3, command=self.select_picture_path) button_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 路径 label_picture_path = tk.Label(self.frame_2, text=&quot;图片路径&quot;, height=3) label_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_picture_path = tk.Entry(self.frame_2, show=None) self.entry_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_predict_result = tk.Entry(self.frame_2, show=None) self.entry_predict_result.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) button_predict_picture = tk.Button(self.frame_2, text=&quot;图片预测&quot;, height=3, command=self.predict_picture) button_predict_picture.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def layout_3(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) self.frame_3 = tk.Frame(self.window) self.frame_3.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_3 label_frame_3_title = tk.Label(self.frame_3, text=&apos;实时图像识别&apos;, font=(&apos;Arial&apos;, 15), height=3, width=30) label_frame_3_title.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_3, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 打开摄像头 button_open_camera = tk.Button(self.frame_3, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading) button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 关闭摄像头 button_close_camera = tk.Button(self.frame_3, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera) button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_realtime_result = tk.Entry(self.frame_3, show=None) self.entry_realtime_result.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) button_realtime_prediction = tk.Button(self.frame_3, text=&quot;实时检测&quot;, height=3, command=self.realtime_prediction) button_realtime_prediction.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def layout_4(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) self.frame_4 = tk.Frame(self.window) self.frame_4.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_4 label = tk.Label(self.frame_4, text=&apos;图像采集&apos;, font=(&apos;Arial&apos;, 15), width=30, height=3) label.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_4, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 打开摄像头 button_open_camera = tk.Button(self.frame_4, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading) button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 关闭摄像头 button_close_camera = tk.Button(self.frame_4, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera) button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) button_picture_capture = tk.Button(self.frame_4, text=&quot;图片采集&quot;, height=3, command=self.picture_capture) button_picture_capture.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) self.entry_input_label = tk.Entry(self.frame_4, show=None, text=&quot;&quot;) self.entry_input_label.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) label_input_label = tk.Label(self.frame_4, text=&quot;输入类别&quot;) label_input_label.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def select_picture_path(self): self.pic_path = filedialog.askopenfilename() self.entry_picture_path.delete(0, &quot;end&quot;) self.entry_picture_path.insert(0, self.pic_path) self.show_picture(self.pic_path) def show_picture(self, path): try: self.picture = Image.open(path).resize((640, 480)) self.picture = ImageTk.PhotoImage(self.picture) self.canvas.create_image(0, 0, anchor=&quot;nw&quot;, image=self.picture) except: messagebox.showerror(title=&quot;路径错误&quot;, message=&quot;路径输入错误或选中文件不是图片&quot;) def open_camera(self): try: cap = cv2.VideoCapture(0) self.thread_flag = True while(self.thread_flag): ret, frame = cap.read() cv2.imshow(&quot;video&quot;, frame) cv2.imwrite(self.temporary_path, frame) if ret != True: break c = cv2.waitKey(60) if c == 27: break cv2.destroyAllWindows() cap.release() except: messagebox.showerror(title=&quot;读取视频出错&quot;, message=&quot;读取出错或未检测到usb摄像头&quot;) def close_camera(self): self.thread_flag = False os._exit(0) def realtime_prediction(self): self.show_picture(self.temporary_path) pass def predict_picture(self): self.entry_predict_result.delete(0, &quot;end&quot;) self.entry_predict_result.insert(0, 0) pass def picture_capture(self): content = self.entry_input_label.get() if len(content) &gt; 0: time_stamp = &apos;&#123;:%Y-%m-%d-%H-%M-%S&#125;&apos;.format(datetime.now()) sub_class_folder = os.path.join(self.database, str(self.entry_input_label.get())) if not os.path.exists(sub_class_folder): os.mkdir(sub_class_folder) image_store_path = os.path.join(sub_class_folder, &apos;&#123;&#125;_&#123;&#125;.jpg&apos;.format(str(self.entry_input_label.get()), time_stamp)) if self.thread_flag: self.show_picture(self.temporary_path) shutil.copy(self.temporary_path, image_store_path) messagebox.showinfo(title=&quot;成功&quot;, message=&quot;成功保存图片&quot;) else: messagebox.showwarning(title=&quot;警告&quot;, message=&quot;未打开摄像头&quot;) else: messagebox.showwarning(title=&quot;警告&quot;, message=&quot;请输入类别号&quot;) def camera_threading(self): self.thread = threading.Thread(target=self.open_camera) self.thread.setDaemon(True) self.thread.start()if __name__ == &quot;__main__&quot;: app = AppUI()pyinstaller 打包 # 安装pyinstallsudo pip3 install pyinstaller# 切换到需要打包的目录，执行pyinstaller -F -W GUI.py# -F: 只生成耦合可执行的文件# -W: 表示窗口，无控制台# 生成的可执行文件就在目录dist中# 修改图标-i icon.ico 或者 --icon.ico# 图片放在需要打包的文件同目录中 参考本文参考以下网站、博客http://www.cnblogs.com/shwee/p/9427975.htmlhttps://blog.csdn.net/yingshukun/article/details/78838395http://www.cnblogs.com/kongzhagen/p/6144588.html","path":"2019/08/05/Tkinter使用指南/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"tkinter","slug":"tkinter","permalink":"https://litianbo243.github.io/tags/tkinter/"}]}]}