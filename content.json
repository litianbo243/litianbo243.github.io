{"meta":{"title":"pangzibo243's blog","subtitle":"a man can be destroyed, but not defeated.","description":"pangzibo243's blog","author":"pangzibo243","url":"https://litianbo243.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-03","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"08-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-03","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"08-05","excerpt":""}],"posts":[{"title":"Ubuntu 软件和软件源","text":"Ubuntu 软件和软件源什么是软件源源,在Ubuntu下,它相当于软件库,需要什么软件,只要记得正确的软件名就可以用命令安装: sudo apt-get install 软件名 例如:你要安装gcc软件,那么你就可以再终端中输sudo apt-get install gcc,这样就能帮你装好gcc软件,如果源里没有这个软件时,此命令就没法完成 当然,如果你要删除软件时,可以再终端中输入: sudo apt-get remove软件名 Ubuntu中安装软件的方式它主要可以分为下面三种安装方式： 通过 apt 包管理工具从软件源中安装 通过 deb 格式的软件包安装 从软件源码手动编译安装 通过软件源安装软件的原理Ubuntu 系统中自带了一个名为 apt的软件包管理工具，它的主要功能就是负责 Ubuntu 系统中所有软件包的管理，包括从软件源中下载软件，卸载系统中已经安装的软件等。而每当我们通过 apt-get install ```命令去安装一个软件时，apt 包管理工具就会从系统中一个叫做源列表的文件中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作## 软件源的分类在 Ubuntu 中软件源其实还细分为下面两种：- Ubuntu 官方软件源- PPA 软件源**Ubuntu 官方软件源:**Ubuntu 官方软件源中包含了 Ubuntu 系统中所用到的绝大部分的软件，它对应的源列表是 **/etc/apt/sources.list****PPA 软件源:**PPA 源出现的背景是因为系统自带的源是很有限的，我们肯定需要一些其他的软件包然而如果是直接下载deb格式的文件的话，又不能获取到更新和维护，所以这就用到了十分重要的 PPA 源了。所谓 PPA 源，就是指 “Personal Package Archives” ，也就是个人软件包集。这其实是一个网站，即－launchpad.net。Launchpad 是 Ubuntu 母公司 Canonical 有限公司所架设的网站，是一个提供维护、支援或联络 Ubuntu 开发者的平台。由于不是所有的软件都能进入 Ubuntu 的官方的软件库，launchpad.net 提供了 PPA，允许开发者建立自己的软件仓库，自由的上传软件。供用户安装和查看更新。## 如何替换官方软件源在终端输入`sudo vim /etc/apt/sources.list`(文件 etc/apt/sources.list是一个普通可编辑的文本文件，保存了ubuntu软件更新的源服务器的地址。)sources.list就是添加源的文件,只要把你在网上找到的源地址加在最后一行就行了,然后保存。回到终端下,更新一下软件列表,输入:`sudo apt-get update`## 如何添加和删除PPA源**添加 PPA 软件源的命令**：`sudo add-apt-repository ppa:user/ppa-name`**删除 PPA 软件源的命令**：`sudo add-apt-repository --remove ppa:user/ppa-name`当我们添加完 PPA 源之后，系统就会在 */etc/apt/sources.list.d/* 文件夹里创建了两个文件：```bashcd /etc/apt/sources.list.dls&quot;&quot;&quot;cuda-8-0-local-ga2.listcuda-8-0-local-ga2.list.save&quot;&quot;&quot; 参考https://www.jianshu.com/p/57a91bc0c594","path":"2019/08/09/Ubuntu 软件和软件源/","date":"08-09","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"软件","slug":"软件","permalink":"https://litianbo243.github.io/tags/软件/"},{"name":"源","slug":"源","permalink":"https://litianbo243.github.io/tags/源/"}]},{"title":"Ubuntu 基础网络排错","text":"Ubuntu 基础网络排错查看网卡信息ifconfig\"\"\"br-8cfad14f3af4 Link encap:以太网 硬件地址 02:42:83:ad:67:64 inet 地址:172.18.0.1 广播:172.18.255.255 掩码:255.255.0.0 UP BROADCAST MULTICAST MTU:1500 跃点数:1 接收数据包:0 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:0 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:0 接收字节:0 (0.0 B) 发送字节:0 (0.0 B)docker0 Link encap:以太网 硬件地址 02:42:1c:64:56:8f inet 地址:172.17.0.1 广播:172.17.255.255 掩码:255.255.0.0 UP BROADCAST MULTICAST MTU:1500 跃点数:1 接收数据包:0 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:0 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:0 接收字节:0 (0.0 B) 发送字节:0 (0.0 B)enp6s0 Link encap:以太网 硬件地址 34:97:f6:8d:55:37 inet 地址:192.168.50.228 广播:192.168.50.255 掩码:255.255.255.0 inet6 地址: fe80::5805:f69:d7e9:4d93/64 Scope:Link inet6 地址: 2001:da8:a800:1007:6163:e5b5:ee4d:ef9/64 Scope:Global inet6 地址: 2001:da8:a800:1007:a960:ef5a:58ad:86f9/64 Scope:Global UP BROADCAST RUNNING MULTICAST MTU:1500 跃点数:1 接收数据包:714830 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:271085 错误:4 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:1000 接收字节:393839354 (393.8 MB) 发送字节:51512172 (51.5 MB)lo Link encap:本地环回 inet 地址:127.0.0.1 掩码:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 跃点数:1 接收数据包:75959 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:75959 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:1000 接收字节:38997685 (38.9 MB) 发送字节:38997685 (38.9 MB)\"\"\" 其中ip地址为enp6s0的inet地址：192.168.50.228 enp6s0是我们真实的网卡 lo是本地回环表示本地 docker0和br-XXX是和docker有关的网络和网桥，会分配给docker网络 防火墙# ufw防火墙状态sudo ufw status# 关闭防火墙sudo ufw disabel 重启网络service networking restart 配置文件网卡配置文件： /etc/network/interfaces DNS配置文件： /etc/resolv.conf 或者 /etc/resolvconf/resolv.conf.d/head 文件 ufw防火墙配置文件： /etc/ufw/before.rules 网络排错的基本思路基本思路如下，这跟网上的大多数人写的应该是差不多的。 （1）检查物理链路是否有问题 （2）查看本机IP地址、路由、DNS的设置是否有问题 （3）测试网关或路由器的通畅情况。先测网关然后再测路由器，一级一级地测试 （4）测试ping公网ip的通畅情况（平时要记几个外部IP） （5）测试DNS的通畅情况，可以直接ping网站地址 下面的第三部分，就针对上面的基本思路来进行详细的说明。 检查物理链路是否有问题看看网线有没有接通 查看本机IP地址、路由、DNS的设置是否有问题如果采用的是DHCP自动获取的方法，那么这时候只需要看自己本机的设置上有没有开启自动获取IP的设置以及有没有开启相关的服务 如果用的是静态IP，那么就必须要注意IP地址的填写有没有错（一般网络管理人员给的）、IP地址的子网掩码有没有问题 # 查看ip地址、MAC地址、子网掩码、广播地址ifconfig# 查看dns地址cat /etc/resolv.conf 测试网关或路由的通畅情况# 检查数据的走向sudo traceroute -d www.baidu.com 先测试到网关的通畅情况 ping -d 192.168.50.1 再测试到其他路由器的通畅情况 sudo traceroute 101.4.130.34 测试ping公网IP的通畅情况ping 114.114.114.114 测试DNS的通畅情况可以直接ping网站地址，看有没有回显示IP地址，通不通是了另外一回事 还有nslookup命令 nslookup&gt; baidu.com\"\"\"之后会出现解析的结果\"\"\" 用netstat查看开放端口及服务netstat -tnp 显示路由表route -n","path":"2019/08/07/Ubuntu 基础网络排错/","date":"08-07","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"网络","slug":"网络","permalink":"https://litianbo243.github.io/tags/网络/"}]},{"title":"Ubuntu 进程管理","text":"UBuntu 进程管理psps命令可以列出正在运行的进程 ps -ef\"\"\"-f: 显示多列信息-e: 显示系统中运行的所有的进程信息\"\"\"# 查看所有运行的进程 ，常常和grep连用ps -aux toptop命令是一个常用的查看系统资源使用情况和查看占用系统资源最多的进程的命令 top以列形式显示所有的进程，占最多CPU资源的进程会显示在最上面 top htophtop命令是top的改进版 sudo apt-get install htophtop killkill命令可以根据进程ID来杀死进程 你可以使用ps -A，top，或者grep命令获取到进程ID 从技术层面来讲，kill命令可以发送任何信号给一个进程 你可以使用kill -9 [id] 来杀死顽固的进程 kill -9 PID","path":"2019/08/07/Ubuntu 进程管理/","date":"08-07","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"进程","slug":"进程","permalink":"https://litianbo243.github.io/tags/进程/"}]},{"title":"Ubuntu ss 配置及其使用","text":"Ubuntu ss 配置及其使用安装sssudo pip3 install shadowsocks 配置服务器并连接需要创建一个.json的配置文件，用配置文件里的参数进行连接 mkdir shadowsockstouch shadowsocks/ss.jsonvim shadowsocks/ss.json# 然后在里面加入\"\"\"&#123; \"server\":\"1.1.1.1\", \"server_port\":8388, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"your passwd\", \"timeout\":300, \"method\":\"aes-256-cfb\"&#125;\"\"\"# 其中，server填你的服务器ip，sever_port填远程端口号，local_address本地ip，local_part本地端口，password填密码，timeout是延迟时间，method是加密方式，按照实际情况填写并保存# 然后运行sssslocal -c shadowsocks/ss.json proxychains 命令行也走代理安装proxychainssudo apt-get install proxychains 配置proxychains# 先创建配置文件touch /etc/proxychains.confvim /etc/proxychains.conf# 找到 [ProxyList]，在其后面追加如下如下的代理服务器配置信息\"\"\"socks5 127.0.0.1 1080\"\"\"","path":"2019/08/07/Ubuntu ss配置及其使用/","date":"08-07","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"ss","slug":"ss","permalink":"https://litianbo243.github.io/tags/ss/"}]},{"title":"ssh操作指南","text":"ssh 操作指南检查ssh服务是否启动SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，为建立在应用层基础上的安全通信协议。 ps -e | grep ssh\"\"\"7529 ? 00:00:00 sshd7852 pts/1 00:00:00 ssh\"\"\" 若输入指令后显示类似于上图所示，则说明SSH服务已启动其中sshd表示ssh-server已启动，ssh表示ssh-client已启动 安装ssh服务sudo apt-get install openssh-clientsudo apt-get install openssh-server 启动ssh服务sudo /etc/init.d/ssh startps -e | grep ssh 修改ssh端口号sudo vim /etc/ssh/sshd_config\"\"\"# Package generated configuration file# See the sshd_config(5) manpage for details# What ports, IPs and protocols we listen forPort 22# Use these options to restrict which interfaces/protocols sshd will bind to#ListenAddress ::#ListenAddress 0.0.0.0Protocol 2# HostKeys for protocol version 2HostKey /etc/ssh/ssh_host_rsa_keyHostKey /etc/ssh/ssh_host_dsa_keyHostKey /etc/ssh/ssh_host_ecdsa_keyHostKey /etc/ssh/ssh_host_ed25519_key#Privilege Separation is turned on for securityUsePrivilegeSeparation yes# Lifetime and size of ephemeral version 1 server keyKeyRegenerationInterval 3600ServerKeyBits 1024# LoggingSyslogFacility AUTHLogLevel INFO# Authentication:LoginGraceTime 120PermitRootLogin prohibit-passwordStrictModes yesRSAAuthentication yesPubkeyAuthentication yes#AuthorizedKeysFile %h/.ssh/authorized_keys# Don't read the user's ~/.rhosts and ~/.shosts filesIgnoreRhosts yes# For this to work you will also need host keys in /etc/ssh_known_hostsRhostsRSAAuthentication no# similar for protocol version 2HostbasedAuthentication no# Uncomment if you don't trust ~/.ssh/known_hosts for RhostsRSAAuthentication#IgnoreUserKnownHosts yes# To enable empty passwords, change to yes (NOT RECOMMENDED)PermitEmptyPasswords no# Change to yes to enable challenge-response passwords (beware issues with# some PAM modules and threads)ChallengeResponseAuthentication no# Change to no to disable tunnelled clear text passwords#PasswordAuthentication yes# Kerberos options#KerberosAuthentication no#KerberosGetAFSToken no#KerberosOrLocalPasswd yes#KerberosTicketCleanup yes# GSSAPI options#GSSAPIAuthentication no#GSSAPICleanupCredentials yesX11Forwarding yesX11DisplayOffset 10PrintMotd noPrintLastLog yesTCPKeepAlive yes#UseLogin no#MaxStartups 10:30:60#Banner /etc/issue.net# Allow client to pass locale environment variablesAcceptEnv LANG LC_*Subsystem sftp /usr/lib/openssh/sftp-server# Set this to 'yes' to enable PAM authentication, account processing,# and session processing. If this is enabled, PAM authentication will# be allowed through the ChallengeResponseAuthentication and# PasswordAuthentication. Depending on your PAM configuration,# PAM authentication via ChallengeResponseAuthentication may bypass# the setting of \"PermitRootLogin without-password\".# If you just want the PAM account and session checks to run without# PAM authentication, then enable this but set PasswordAuthentication# and ChallengeResponseAuthentication to 'no'.UsePAM yes\"\"\" 修改端口号port后，重启ssh服务即可生效 sudo /etc/init.d/ssh restart ssh远程登录ssh user@X.X.X.X# X.X.X.X 为ip地址 数据传输完成SSH服务配置之后即可实现基于SSH的数据传输，最常用方便的指令便是scp，以下是常用scp指令： scp SOURCE DESTINATION# -r : 递归复制目录 ssh无密码自动登录需要两步 在本地主机上生成ssh密钥 将生成的公钥传给远程主机 # 在本地主机上生成密钥ssh-keygen -t rsa# 将公钥传给远程主机ssh-copy-id USER@REMOTE_HOST ssh实现端口转发SSH的端口转发包括，本地端口转发和远程端口转发两部分 本地端口转发 # 在本地(运行命令的机器上)起一个监听端口，把所有对该本地端口的访问转发到服务器ssh -L &lt;local-port-to-listen&gt;:&lt;remote-host&gt;:&lt;remote-port&gt; &lt;sshserver&gt;# &lt;local-port-to-listen&gt; 本地端口，也就是命令运行的机器的端口# &lt;remote-host&gt;:&lt;remote-port&gt; 目标机器和端口，是真正提供服务的端口# &lt;sshserver&gt; ssh服务器，是提供端口转发功能的服务器 这个命令的功能就是把”本地机器:“映射到”:“，这个功能通过sshserver实现 本地端口转发通常执行在防火墙外的机器上，用来给防火墙外的其他机器访问防火墙内的资源 # 在proxyserver机器上执行下面的命令ssh -L 30000：webserver：8080 user@SSHserver 远程端口转发 和本地端口转发的区别是： 本地端口转发，起一个监听端口在本地(执行命令的机器)；然后转发所有向这个新起本地端口的请求， 到 sshserver，再到目标机器。 远程端口转发，起一个监听端口在远程(sshserver机器)；然后转发所有向这个新起远程端口的请求，到本地机器(执行命令的机器)，再到目标机器。 ssh -R &lt;local-port-to-listen&gt;:&lt;remote-host&gt;:&lt;remote-port&gt; &lt;sshserver&gt;# &lt;local-port-to-listen&gt; 本地端口，也就是命令运行的机器的端口# &lt;remote-host&gt;:&lt;remote-port&gt; 目标机器和端口，是真正提供服务的端口# &lt;sshserver&gt; ssh服务器，是提供端口转发功能的服务器 所不同的是端口是起在sshserver上，而不是在运行命令的proxyserver机器上。然后把所有对:的请求都转发到:上去远程端口转发通常执行在防火墙内的机器上，用来给防火墙外的其他机器访问防火墙内的资源 # 在proxyserveer机器上执行下面的命令ssh -R 30000:webserver:8080 user@sshserver 借助服务器访问内网主机 sshfs实现本地挂载点挂载远程驱动器# 首先安装sshfssudo apt-get install sshfs# 必须sudo执行命令，否则权限出错sudo sshf -o allow_other ltb@X.X.X.X:/home/ltb ~/AMAX# 使用下面命令卸载umount ~/AMAX","path":"2019/08/06/ssh 操作指南/","date":"08-06","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"ssh","slug":"ssh","permalink":"https://litianbo243.github.io/tags/ssh/"}]},{"title":"服务器管理指南","text":"1.给root用户设置一个密码sudo passwd root 2.查看所有用户和用户组cat /etc/passwdcat /etc/group 3.添加用户sudo suadduser ltb 4.删除用户deluser --remove-all-files ltb 5.添加用户到用户组sudo usermod -aG iccd ltb 6.创建用户组sudo groupadd iccd 7.删除用户组sudo groupdel iccd 8.修改用户组权限vim /etc/sudoers 9.nfs等操作# 下载nfssudo apt-get install nfs-kernal-server# 重启nfssudo /etc/init.d/nfs-kernal-server restart# 修改配置文件sudo vi /etc/export&quot;&quot;&quot;加上/amax-share *(rw,sync,no_root_squash,no_subtree_check)&quot;&quot;&quot;# mount操作sudo mount X.X.X.X：/amax-share /home/ltb/AMAX# umount操作sudo umount /home/ltb/AMAX sshfs实现本地挂载点挂载远程驱动器# 首先安装sshfssudo apt-get install sshfs# 必须sudo执行命令，否则权限出错sudo sshf -o allow_other ltb@X.X.X.X:/home/ltb ~/AMAX# 使用下面命令卸载umount ~/AMAX","path":"2019/08/05/服务器管理指南/","date":"08-05","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"常用指令","slug":"常用指令","permalink":"https://litianbo243.github.io/tags/常用指令/"},{"name":"管理","slug":"管理","permalink":"https://litianbo243.github.io/tags/管理/"}]},{"title":"Docker使用指南","text":"1. 查看docker服务器是否正常sudo docker info 2. 运行容器sudo docker run -i -t ubuntu /bin/bashsudo docker run -i -t 镜像名称 命令代码 3. 使用容器# 查看系统中存在的容器docker ps -a 4. 容器命名sudo docker run --name litianbo_test -i -t ubuntu /bin/bashsudo docker run --name 容器名称 -i -t 镜像名称 命令代码 5. 启动已停止的容器# 根据容器名称启动sudo docker start litianbo_test# 根据容器id启动sudo docker start 41225bc38698 6. 进行容器内部命令行sudo docker attach litianbo_test 7. 创建守护式容器sudo docker run --name litianbo_test -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 8. 查看容器日志sudo docker logs litianbo_testsudo docker logs -f litianbo_test 9. 查看容器内进程sudo docker top litianbo_test 10. 在容器内运行进程sudo docker exec -it litianbo_test /bin/bash 11. 停止守护式容器sudo docker stop litianbo_test 12. 自动重启容器sudo docker run --restart=always --name litianbo_test -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 13. 查看容器详细信息sudo docker inspect litianbo_test 14. 删除容器sudo docker rm litianbo_test 15. 查看镜像列表sudo docker images 16. 拉取镜像sudo docker pull ubuntu# 运行时指定tagsudo docker run -it ubuntu:16.04 /bin/bash# 对于一个仓库而言，完整的格式如下：[用户名称/]仓库名称:tag 17. 查找镜像sudo docker search keywords 18. 构建镜像 使用docker commit构建 使用docker build和Dockerfile文件来构建# 创建docker hub账号# 通过命令在本地绑定对应的Docker Hub账号sudo docker login# commit# 根据某个镜像创建一个容器# 对该容器进行一些修改# 提交该容器并生成一个新的镜像sudo docker run -it ubuntu /bin/bashroot@b3f9427a5039:/# apt-get -yqq updateroot@b3f9427a5039:/# apt-get -y install apache2root@b3f9427a5039:/# exitsudo docker commit b3f9427a5039 ltb/apache2sudo docker images# -m=”message” 可以用于对提交的镜像添加一些文本描述# –author=”person” 可以用于添加提交人信息# 提交时，我们可以设置tagsudo docker commit -m=&quot;install apache&quot; --author=&quot;ltb&quot; b3f9427a5039 ltb/apache:v1# 查看镜像详细信息sudo inspect ltb/apache2:v1# 用心镜像创建容器sudo docker run -it ltb/apache2:v1 /bin/bash# dockerfile# 先创建一个工作目录，并在目录中创建一个dockerfile文件mkdir workdircd ./workdirtouch dockerfile# 编辑dockerfile文件FROM ubuntu:14.04MAINTAINER Wangzhe0912 &quot;Wangzhe0912@tju.edu.cn&quot;RUN apt-get updateRUN apt-get install -y nginxRUN echo &quot;Hi, I am your contrainer&quot; &gt; /usr/share/nginx/html/index.htmlEXPOSE 80# 基于dockerfile构建新镜像# 写完dockerfile文件后，可以执行docker build命令生成一个新的镜像# 在本地当前目录下寻找dockerfile文件docker build -t=&quot;ltb/nginx:v1&quot;` .# 指定git仓库寻找dockfile文件docker build -t=&quot;wangzhe0912/nginx:v1&quot;` git@github.com:wangzhe0912/docker_web# dockerfile构建缓存# 希望强制忽略缓存时，可以额外添加--no-cache参数进行设置sudo docker build --no-cache -t=&quot;ltb/nginx:v1&quot;# 基于构建缓存的dockfile模板# 添加了一行环境变量ENVFROM ubuntu:14.04MAINTAINER Wangzhe0912 &quot;Wangzhe0912@tju.edu.cn&quot;ENV REFRESHED_AT 2018-01-28RUN apt-get update...# 查看新镜像构建过程docker history image_name/id# 从新镜像启动容器# -d表示后台程序进行运行# -p 80表示运行时公开80端口给宿主机docker run -d -p 80 --name ltb_nginx ltb/nginx:v1 nginx -g &quot;daemon off;&quot;# 端口查询docker port ltb_nginx 80# 访问地址curl localhost:32768 19. 将镜像推送至Docker Hubsudo docker push ltb/nginx 20. 删除镜像sudo docker rmi 镜像名称 21.登录DockerHubsudo docker login# 输入账号密码 22.Docker免sudo操作sudo groupadd dockercat /ect/groupsudo gpasswd -a $&#123;USER&#125; dockernewgrp - docker 23.管理网络# 创建自定义网络docker network create iccd# 删除自定义网络docker network rm iccd","path":"2019/08/05/docker使用指南/","date":"08-05","excerpt":"","tags":[{"name":"docker","slug":"docker","permalink":"https://litianbo243.github.io/tags/docker/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://litianbo243.github.io/tags/虚拟化/"}]},{"title":"dockerfile构建指南","text":"dockerfile构建指南dockerfile官方文档https://docs.docker.com/engine/reference/builder/ dockerfile的基本结构Dockerfile 一般分为四部分： 基础镜像信息 维护者信息 镜像操作指令 容器启动时执行指令 ’#’ 为 Dockerfile 中的注释 FROM指定基于哪个基础镜像,必须为第一个命令 格式： FROM &lt;image&gt; FROM &lt;image&gt;:&lt;tag&gt; FROM &lt;image&gt;@&lt;digest&gt;示例： FROM mysql:5.6注： tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像 MAINTAINER维护者信息 格式： MAINTAINER &lt;name&gt;示例： MAINTAINER fendo fendo MAINTAINER fendo.com MAINTAINER fendo fendo &lt;fendo@163.com&gt; RUN构建镜像时执行的命令 RUN用于在镜像容器中执行命令，其有以下两种命令执行方式： 1.shell执行格式： RUN &lt;command&gt; 2.exec执行格式： RUN [\"executable\", \"param1\", \"param2\"]示例： RUN yum update RUN [\"/etc/execfile\", \"arg1\", \"arg1\"]注： RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache CMD构建容器后调用，也就是在容器启动时才进行调用 格式： CMD [\"executable\",\"param1\",\"param2\"] (执行可执行文件，优先) CMD [\"param1\",\"param2\"] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数) CMD command param1 param2 (执行shell内部命令)示例： CMD [\"/bin/bash\", \"/usr/local/nginx/sbin/nginx\", \"-c\", \"/usr/local/nginx/conf/nginx.conf\"]注： CMD不同于RUN,CMD用于指定在容器启动时所要执行的命令,而RUN用于指定镜像构建时所要执行的命令,只能有一条。 COPY复制文件到镜像中 使用copy命令时,必须将需要copy的文件放在和dockerfile同一目录下 格式: COPY &lt;src&gt; &lt;dest&gt;示例: COPY ltb-tutorial /home/ltb/tutorial ENTRYPOINT配置容器，容器启动时要执行的命令，它和CMD很像，也是只有一条生效 和CMD不同是：CMD 是可以被 docker run 指令覆盖的，而ENTRYPOINT不能覆盖 格式： ENTRYPOINT [\"executable\", \"param1\", \"param2\"] (可执行文件, 优先) ENTRYPOINT command param1 param2 (shell内部命令)示例： FROM ubuntu ENTRYPOINT [\"top\", \"-b\"] CMD [\"-c\"]注： ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT， 而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。 Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。 LABEL用于为镜像添加元数据 格式： LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...示例： LABEL version=\"1.0\" description=\"这是描述\" by=\"fendo\"注： 使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据， 指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 EVN设置环境变量,它主要是为后续的RUN指令提供一个环境变量 格式： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key&gt;=&lt;value&gt; ...示例： ENV myName fendo ENV myDog fendo Dog ENV myCat fendo EXPOSE格式： EXPOSE &lt;port&gt; [&lt;port&gt;...]示例： EXPOSE 80 443 EXPOSE 8080说明: 用来指定要映射出去的端口，比如容器内部我们启动了sshd和nginx，所以我们需要把22和80端口暴漏出去。这个需要配合-P（大写）来工作， 也就是说在启动容器时，需要加上-P，让它自动分配。如果想指定具体的端口，也可以使用-p（小写）来指定。注： EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口 VOLUME用于指定持久化目录 格式： VOLUME [\"/path/to/dir\"]示例： VOLUME [\"/data\"] VOLUME [\"/var/www\", \"/var/log/apache2\", \"/etc/apache2\"]说明: 创建一个可以从本地主机或其他容器挂载的挂载点。注： 一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能： 1 卷可以容器间共享和重用 2 容器并不一定要和其它容器共享卷 3 修改卷后会立即生效 4 对卷的修改不会对镜像产生影响 5 卷会一直存在，直到没有任何容器在使用它 WORKDIR工作目录,类似于cd命令 格式： WORKDIR /fendo/nginx示例： WORKDIR /a (这时工作目录为/a) WORKDIR b (这时工作目录为/a/b) WORKDIR c (这时工作目录为/a/b/c)说明: 为后续的RUN、CMD或者ENTRYPOINT指定工作目录注： 通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。 在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。 dockerfile实例# This my first nginx Dockerfile# Version 1.0# Base images 基础镜像FROM centos#MAINTAINER 维护者信息MAINTAINER tianfeiyu #ENV 设置环境变量ENV PATH /usr/local/nginx/sbin:$PATH#ADD 文件放在当前目录下，拷过去会自动解压ADD nginx-1.8.0.tar.gz /usr/local/ ADD epel-release-latest-7.noarch.rpm /usr/local/ #RUN 执行以下命令 RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpmRUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean allRUN useradd -s /sbin/nologin -M www#WORKDIR 相当于cdWORKDIR /usr/local/nginx-1.8.0 RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make installRUN echo \"daemon off;\" &gt;&gt; /etc/nginx.conf#EXPOSE 映射端口EXPOSE 80#CMD 运行以下命令CMD [\"nginx\"] dockerfile构建流程 新建文件夹DIR,进入并编写dockerfile文件 使用docker build命令构建docker镜像 docker build --network ltb_net -t leeskywave/nginx:v1.0 . # 不加--network参数,大概率构建的时候没网 参考https://blog.csdn.net/u011781521/article/details/80464065","path":"2019/08/05/dockerfile构建指南/","date":"08-05","excerpt":"","tags":[{"name":"docker","slug":"docker","permalink":"https://litianbo243.github.io/tags/docker/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://litianbo243.github.io/tags/虚拟化/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://litianbo243.github.io/tags/dockerfile/"}]},{"title":"visdom使用指南","text":"安装visdompip install visdom 打开visompython -m visdom.server# 然后打开浏览器 http://localhost:8097/ 指定端口vis = visdom.Visdom(env=&apos;名称&apos;, port=上面开启visdom服务的指定接口)# eg:vis = visdom.Visdom(env=&apos;faster rcnn&apos;, port=15024) 打印lossdef plot(self, name, y): &quot;&quot;&quot; self.plot(&apos;loss&apos;,1.00) &quot;&quot;&quot; x = self.index.get(name, 0) self.vis.line(Y=np.array([y]), X=np.array([x]), win=(name), opts=dict(title=name), update=None if x == 0 else &apos;append&apos; ) self.index[name] = x + 1 vis.plot(&apos;errord&apos;, error_d)vis.plot(&apos;errorg&apos;, error_g) 打印图片# (n, c, h, w)带batch，打印出一个batch里所有图片vis.images(fix_fake_imgs.detach().cpu().numpy()[:64] * 0.5 + 0.5, win=&apos;fixfake&apos;)vis.images(real_img.data.cpu().numpy()[:64] * 0.5 + 0.5, win=&apos;real&apos;)","path":"2019/08/05/visdom使用指南/","date":"08-05","excerpt":"","tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://litianbo243.github.io/tags/pytorch/"},{"name":"visdom","slug":"visdom","permalink":"https://litianbo243.github.io/tags/visdom/"},{"name":"可视化","slug":"可视化","permalink":"https://litianbo243.github.io/tags/可视化/"}]},{"title":"GANs生成对抗网络","text":"GAN的历程左边部分主要是改进模型解决实际的图片转换，文本转图像，生成图片，视频转换等实际问题；右边部分呢则是主要解决GAN框架本身存在的一些问题。学习路径 GANIan Goodfellow 的原始 GAN 论文肯定是必读之作。涉及了GAN框架、“非饱和”损失函数以及最优判别器的推导。图1：训练对抗神经网络时，同时更新判别分布（D，蓝色虚线）使D能区分数据分布px（REAL，黑色虚线）中的样本和生成分布pg(G，绿色实线) 中的样本。下面的水平线为均匀采样z的区域，上面的水平线为x的部分区域。朝上的箭头显示映射x=G(z)如何将非均匀分布pg作用在转换后的样本上。G在pg高密度区域收缩，且在pg地的低密度区域扩散。(a)考虑一个接近收敛的对抗的模型对：pg 与pdata相似，且D是个部分准确的分类器。(b)在算法的内循环中，训练D来判断数据中的样本，收敛到D*(x)=pdata(x)/[pdata(x)+pg(x)](c)在G的一次更新后，D的梯度引导G(z)流向更可能分类为数据的区域。(d)训练若干步后，如果G和D有足够的容量，他们将会接近某个点，由于pg=pdata 两者都无法提高性能。判别器将不能区别出训练数据分布和生成数据分布，即D(x)= 1/2。 DCGAN顾名思义，DCGAN主要讨论CNN与GAN如何结合使用并给出了一系列建议。另外还讨论了GAN特征的可视化、潜在空间插值等问题。 ImprovedGANIan Goodfellow等人提供了诸多训练稳定GAN的建议，包括特征匹配、mini-batch识别、历史平均、单边标签平滑以及虚拟批标准化等技巧。讨论了GAN不稳定性的最佳假设。 PACGANPACGAN讨论的是的如何分析model collapse，以及提出了PAC判别器的方法用于解决model collapse。思想其实就是将判别器的输入改成多个样本，这样判别器可以同时看到多个样本可以从一定程度上防止model collapse。 WGANWGAN首先从理论上分析了原始GAN模型存在的训练不稳定、生成器和判别器的loss无法只是训练进程、生成样本缺乏多样性等问题，并通过改进算法流程针对性的给出了改进要点。 ConditionalGAN同一般形式的GAN类似，也是先训练判别网络，再训练生成网络，然后再训练判别网络，两个网络交替训练。只是训练判别网络的样本稍有不同，训练判别网络的时候需要这三种样本，分别是：（1）条件和与条件相符的真实图片，期望输出为1；（2）条件和与条件不符的真实图片，期望输出为0；（3）条件和生成网络生成的输出，期望输出为0。 CycleGANCycleGAN讨论的是image2image的转换问题，提出了Cycle consistency loss来处理缺乏成对训练样本来做image2image的转换问题。Cycle Consistency Loss 背后的主要想法，图片A转化得到图片B，再从图片B转换得到图片A’，那么图片A和图片A’应该是图一张图片。 Vid2vidVid2Vid通过在生成器中加入光流约束，判别器中加入光流信息以及对前景和背景分别建模重点解决了视频转换过程中前后帧图像的不一致性问题。 PGGANPGGAN创造性地提出了以一种渐进增大（Progressive growing）的方式训练GAN，利用逐渐增大的PGGAN网络实现了效果令人惊叹的生成图像。“Progressive Growing” 指的是先训练 4x4 的网络，然后训练 8x8，不断增大，最终达到 1024x1024。这既加快了训练速度，又大大稳定了训练速度，并且生成的图像质量非常高。 SeqGANSeqGAN用对抗网络实现了离散序列数据的生成模型。解决了对抗生成网络难应用于nlp领域的问题，并且在文本生成任务上有优异表现。相比以往刻意用增强学习解决生成模型的训练不一样，在NLP上因为存在误差无法回进行梯度更新的问题，对抗生成网络的训练中只能用增强学习，所以模型结构显得如此的恰到好处。 StackGANStackGAN是由文本生成图像，StackGAN模型与PGGAN工作的原理很像，StackGAN 首先输出分辨率为64×64 的图像，然后将其作为先验信息生成一个 256×256 分辨率的图像。 BigGANBigGAN模型是基于 ImageNet 生成图像质量最高的模型之一。该模型很难在本地机器上实现，而且 有许多组件，如 Self-Attention、 Spectral Normalization 和带有投影鉴别器的 cGAN等。 StyleGANStyleGAN应该是截至目前最复杂的GAN模型，该模型借鉴了一种称为自适应实例标准化 (AdaIN) 的机制来控制潜在空间向量 z。虽然很难自己实现一个StyleGAN，但是它提供了很多有趣的想法。","path":"2019/08/05/GAN生成对抗网络学习/","date":"08-05","excerpt":"","tags":[{"name":"deeplearning","slug":"deeplearning","permalink":"https://litianbo243.github.io/tags/deeplearning/"},{"name":"GANs","slug":"GANs","permalink":"https://litianbo243.github.io/tags/GANs/"}]},{"title":"Ubuntu常用指令","text":"Ubuntu常用指令石墨版: Ubuntu指南. su和sudo：得到root权限sudo passwd [root] # 设定root密码su [root] # 切换到root用户sudo COMMAND # 切换到root用户，执行COMMAND，然后切换回当前用户su USER # 切换回普通用户USER apt和dpkg：用于安装软件包apt list # 根据名称列出软件包apt show PACKAGE # 显示软件包细节sudo apt-get install PACKAGE # 安装软件包sudo apt-get remove PACKAGE # 卸载软件包sudo apt-get check PACKAGE # 检查依赖sudo apt-get update # 更新可用软件包列表sudo apt upgrade # 通过升级来更新系统sudo apt-get install -f # 修复依赖sudo dpkg -i xxx.deb # 运行deb程序进行安装 pip：用于安装python模块（不是linux里的默认指令，需自行安装sudo apt-get install pip）sudo apt-get install python3-pip # 安装python3下的pip# 更新pip到指定版本python3 -m pip install --user --upgrade pip==9.0.3 # (换成你想要的版本编号)# pip临时加速pip 加参数-i https://pypi.tuna.tsinghua.edu.cn/simple # pip永久加速# Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\"\"\"[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com\"\"\"# windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。pip install PACKAGE # 安装包pip uninstall PACKAGE # 卸载包pip search PACKAGE # 搜索能安装的包pip list # 例出所有的已安装的包pip show PACKAGE # 展示已安装包的信息，可以指定单个包名展示 pip check PACKAGE # 检查依赖pip --version # 显示pip版本和位置pip help # 查看帮助pip help install # 查看install指令的相关option介绍 ssh和scp：用于主机间的通信ssh USERNAME@IP -p PORTNUM # 远程登录到主机scp LOCAL_FILE USERNAME@IP:REMOTE_DIRECTORY # 复制本地文件到远程主机scp -r LOCAL_FILE USERNAME@IP:REMOTE_DIRECTORY # 复制本地文件夹到远程主机sudo ufw dissable # 关闭防火墙sudo ufw enable # 开启防火墙sudo apt-get install vsftpd # 安装sftpservice vsftpd starrt # 启用sftp zip,unzip,tar,rar,unrar：压缩和解压gzip # gzip是Linux使用最广的压缩指令gzip [-cdtv#] FILENAME\"\"\"-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6\"\"\"bzip2 # 提供比gzip更高的压缩比bzip2 [-cdkzv#] FILENAME\"\"\"-k ：保留源文件\"\"\"xz2 # 提供比bzip2更佳的压缩比xz [-dtlkc#] FILENAMEtar 压缩打包tar [-z|-j|-J][cv][-f NEW_TAR_FILE] FILE # 打包压缩tar [-z|-j|-J][tv][-f TAR_FILE] # 查看tar [-z|-j|-J][xv][-f TAR_FILE] [-C DIR] # 解压\"\"\"-z ：使用 zip-j ：使用 bzip2-J ：使用 xz-c ：新建打包文件-t ：查看打包文件里面有哪些文件-x ：解打包或解压缩的功能-v ：在压缩/解压缩的过程中，显示正在处理的文件名-f : filename：要处理的文件-C DIR ： 在特定目录解压缩\"\"\"# 例1tar -jcv -f file.tar.bz2 file # 压缩tar -jxv -f file.tar.bz2 -C ./file # 解压tar -zcv -f dir.tar.gz dir1 dir2 ... # 多个文件压缩# 例2tar -zcv file | split -b 4000M -d -a 1 - file.tar.gz. # 压缩成多个压缩包# 使用split命令\"\"\"-b 4000M 表示设置每个分割包的大小，单位还是可以k-d 参数指定生成的分割包后缀为数字的形式-a x来设定序列的长度(默认值是2)\"\"\"cat file.tar.gz.* | tar -zxv file 多个压缩包解压 du和df：查看磁盘的存储占用和查看文件系统的存储占用du -s # 仅显示总计，只列出最后加的总值du -c # 除了显示个别文件或目录的大小外，还显示一行目录和文件的总和大小du -h # 以k,m,g为单位，提高信息的可读性du --max-depth=1 # 查看当前目录所有（一级）文件的大小du -sh *.mkv # 显示每个mkv文件的大小du -csh *.mkv # 显示每个mkv文件的大小和总和df -h # 以k,m,g为单位，提高信息的可读性df -T # 显示文件系统的类型 which,whereis,locate,find：查找命令#which在PATH变量制定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果#whereis只能用于程序名的搜索，而且只能搜索二进制文件（-b），man说明文件（-m），源代码文件（-s）。若省略，则返回所有信息#locate配合数据库查看文件位置。linux会将系统内所有文件记录在一个数据库文件中，电视该数据库并不是实时更新#find实际搜寻硬盘查询文件名称find . -name \"*.conf\" 当前目录查找扩展名为.conf的文件updatedb 更新数据库locate STRING 快速查找系统数据库中指定的内容which python 查询pythonwhereis python 查询python 文件权限chmod [ugoa][+-=][rwx] FILE|DIR # 改变指定目录或文件的权限# u代表该文件所有者，g代表该文件所有者的同组用户，o代表其他，a表示这三者皆是# r可读，w可写，x可执行chomd u+x test # 该文件的所有者增加可执行的权限# 用数字表示，规定r=4,w=2,x=1chmod 777 file # 三种用户都赋予可读可写可执行的权限chown -R 用户名[:组名] 文件名或目录 # 改变指定目录或文件的所属用户，-R代表递归地改变目录下的所有文件 文件和文本操作ls [-adl] FILE|DIR # 列出文件或者目录信息\"\"\"-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据\"\"\"cd DIR # 更换当前路径mkdir [-mp] DIR # 创建目录\"\"\"-m ：配置目录权限-p ：递归创建目录\"\"\"rmdir [-p] DIR # 删除目录，目录必须为空\"\"\"-p ：递归删除目录\"\"\"touch [-acdmt] FILENAME # 更新文件时间或者建立新文件\"\"\"-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=\"日期或时间\"-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]\"\"\"cp [-adfilprsu] SOURCE DESTINATION # 复制文件\"\"\"-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制\"\"\"rm [-fir] FILE|DIR # 删除文件或者目录\"\"\"-r ：递归删除\"\"\"mv [-fiu] SOURCE DESTINATION # 移动文件\"\"\"-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\"\"\"ln [-sf] SOURCE DESTINATION # 创建链接\"\"\"-s ：默认是 hard link，加 -s 为 symbolic link-f ：如果目标文件存在时，先删除目标文件\"\"\"cat [-n] FILENAME # 获取文件内容\"\"\"-n ：打印出行号，连同空白行也会有行号，-b 不会\"\"\"grep str /tmp/test # 在文件/tmp/test中查找strgrep ^str /tmp/test # 在文件/tmp/test中查找以str开始的行ls -ld */ # 显示当前目录的所有目录文件ls -l | grep '^d' # 显示当前目录的所有目录文件wc -l # 统计文件行数wc -w # 统计单词数量ls -l | wc -l # 统计当前目前的文件数量，注意要减去“总用量”那一行cp -a dir1 dir2 # 复制目录mv dir1 dir2 # 移动/重命名目录mkdir -p /tmp/dir1/dir2 # 创建一个目录树rm -f file1 # 删除文件rm -rf dir1 # 删除目录ln -s /real_file /soft_link # 创建软链接 进程ps -e # 显示所有进程ps -f # 全格式显示进程ps -u 'liaohuqiang' | grep 'tmux' # 显示指定用户执行的进程，并匹配出包含'tmux'的那一行进程ps -ef | grep 'python' | grep -v grep # 把grep命令排除掉ps -ef | grep 'python' | grep -v grep | awk '&#123;print $2&#125;' # 提取进程号pstree -A #查看进程树kill -2 PID # 类似ctrl+C，在程序结束之前能够保存相关数据，再退出kill -9 PID # 直接强制结束进程reboot # 重启shutdown -r now # 立刻重启shutdown -r 30 # 30分钟后重启shutdown -r 23:00 # 晚上11点重启halt # 立刻关机poweroff # 立刻关机shutdown -h now # 立刻关机shutdown -h 30 # 30分钟后关机shutdown -c # 取消shutdwon的重启或关机command &amp; # 使指令成为后台任务nohup # 不挂断地运行命令，通常和&amp;一起用，输出将附加到目录的nohup.outjobs -l # 列出任务列表，l表示显示进程号（只查看当前终端的，关闭终端后无法看到）fg # 把最近一个job切换到前台fg n # 把某个job切换到前台ctrl z # 挂起某个前台进程bg # 把作业放到后台运行top # 动态显示进程信息top -i # 不显示任何闲置或无用的进程\"\"\"k 杀死某进程n 改变显示的进程数量u 显示指定用户P 按CPU使用情况排序q 退出\"\"\"lscpu # 查看cpu信息概要# 监视cpu# 先安装matstatsudo apt install sysstat# 每两秒查看一次mpstat -P ALL 2 网络netstat # 显示网络情况netstat -a # 列出所有端口netstat -l # 只显示监听端口netstat -t # 列出所有tcp端口netstat -p # 显示使用该端口的pid和程序名称netstat -n # 直接使用ip地址，不通过域名服务器# 找出程序运行的端口 netstat -anp | grep ssh# 找出运行在指定端口的进程 netstat -anp | grep ':80'ifconfig # 查看网卡信息 查看电脑配置free -m # 查看内存使用情况df # 查看磁盘使用情况cat /proc/cpuinfo # 查看cpu信息lspci | grep VGA # 查看显卡nvidia-smi # 查看英伟达系列显卡的使用情况nvidia-smi -L # 查看显卡型号watch -n 1 -d nvidia-smi # 实时监控nvidia-smi，每隔一秒刷新一次，d表示高亮 cat /proc/driver/nvidia/version # 查看显卡驱动cat /etc/issue # 查看ubuntu版本 vim简单操作vim可以分为三种模式：命令模式（Command mode）、插入模式（Insert mode）和底线命令模式（Last line mode）Comand mode：控制屏幕光标的移动，字符或光标的删除，移动复制某区段及进入Insert mode下，或者到Last line mode。Insert mode：唯有在Insert mode下，才可做文字数据输入，按Esc等可回到Comand mode。Last line mode：将储存文件或离开编辑器，也可设置编辑环境，如寻找字符串、列出行号等。 在Command mode下按‘i’、‘a’或‘o’三键就可进入Insert mode。这时候您就可以开始输入文字了i: 插入，从目前光标所在之处插入所输入的文字a: 增加，目前光标所在的下一个字开始输入文字o: 插入新的一行，从行首开始输入文字Insert的切换→Command mode，按Esc键您目前处于Insert mode，您就只能一直打字。假如您发现打错字了，想用光标键往回移动，将该字删除，就要按ESC键转换回Command mode，再删除文字 在Command mode下，可按冒号“：”键入入Last line mode，例如：:w filename (输入“w filename”，将文章存入指定的文件名filename):wq (输入“wq”，因为进入之时已经指定文件名testfile，所以会写入testfile并离开vi):q! (输入“q!”，强制离开并放弃编辑的文件) x：每按一次删除光标所在位置的后面一个字符dd：删除光标所在行yy：复制光标所在行u：假如您误操作一个指令，可以马上按u，回复到上一个操作 其他date # 显示时间whoami # 显示当前用户名who # 目前登录系统的用户信息curl 'url' -O --progress # 下载文件,-O代表保存文件（如果没有则输出到屏幕）, --progress表示会显示进度条 # (curl不是linux的默认自行，需自行安装apt install curl)echo $SHELL # 查看系统使用的是哪种shellecho $PATH # 查看环境变量xdg-open filename # 用默认应用程序打开文件python run_generation.py | tee vggTrainResult # 重定向到文件 cat /usr/local/cuda/version.txt # 查看cuda版本cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 # 查看cudnn版本 参考https://www.cnblogs.com/liaohuiqiang/p/7191462.html","path":"2019/08/05/Ubuntu shell 常用指令 指南/","date":"08-05","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://litianbo243.github.io/tags/shell/"},{"name":"常用指令","slug":"常用指令","permalink":"https://litianbo243.github.io/tags/常用指令/"}]},{"title":"语义分割学习","text":"什么是语义分割图像语义分割通俗的来讲就是，将一张图片的每个像素点进行分类，分类到每个语义，即类别。 常用的数据集对于深度学习来说，数据集至关重要，数据集很大程度影响最后模型的性能。现在在研究方面有几个公开的优秀数据集，大家都在这些公开的数据集上进行实验研究，相互比较来使构建的模型更优。Pascal VOC 2012：有 20 类目标，这些目标包括人类、机动车类以及其他类，可用于目标类别或背景的分割Cityscapes：50 个城市的城市场景语义理解数据集Pascal Context：有 400 多类的室内和室外场景Stanford Background Dataset：至少有一个前景物体的一组户外场景。 评判指标对于一个模型来说，需要制定一个评判指标来评判这个模型是否优秀。在语义分割中，常常使用平均IOU来评判模型的性能。平均IOU是基于每个类别来计算的，即先计算每个类单独的IOU，在把每个类的IOU计算平均，就是平均IOU。一般大于0.5就比较好了。 语义分割的发展历程2014 FCN(Fully Convolutional Networks)2015 SegNet2015 空洞卷积(Dilated Convolution)2015 DeepLab2016 RefineNet2016 ENet2017 PSPNet2017 大内核GCN FCNFCN的主要思想是：1.几乎借鉴AlexNet的网络结构，但是把AlexNet最后几层全连接网络改成了卷积网络，这样就可以适应任意大小的图片。2.使用了反卷积（上采样）将底层信息放大，采用的是将feature map周围填0，然后卷积回去，卷积过后的feature map会更大。3.使用了skip结构，融合多层的特征，使结果更准确。 损失函数是在最后一层的 spatial map上的 pixel 的 loss 和，在每一个 pixel 使用 softmax loss 。mIOU1=62.2mIOU2=67.2 SegNet采用encoder-decoder的思想，把图片先encoder为高维的特征，再通过decoder还原为原图的大小，其中上采样部分采用了一种叫做pooling Indices的trick。在encoder时，网络经过几层卷积层后，需要max pooling层将特征图缩小，此时记录max pooling 最大元素所在的位置，叫做pooling Indices。当decoder时，进行上采样时，用pooling Indices反池化，还原成原图的大小。mIOU=59.9 Dilated Convolution使用了空洞卷积，这是一种可用于密集预测的卷积层；提出在多尺度聚集条件下使用空洞卷积的“背景模块”。池化操作增大了感受野，有助于实现分类网络。但是池化操作在分割过程中也降低了分辨率。因此，该论文所提出的空洞卷积层是如此工作的：mIOU=71.3-75.3这篇论文还是很需要看的。 DeepLab使用了空洞卷积；提出了在空间维度上实现金字塔型的空洞池化atrous spatial pyramid pooling(ASPP)；使用了全连接条件随机场。空洞卷积在不增加参数数量的情况下增大了感受野，按照上文提到的空洞卷积论文的做法，可以改善分割网络。我们可以通过将原始图像的多个重新缩放版本传递到CNN网络的并行分支(即图像金字塔)中，或是可使用不同采样率(ASPP)的多个并行空洞卷积层，这两种方法均可实现多尺度处理。我们也可通过全连接条件随机场实现结构化预测，需将条件随机场的训练和微调单独作为一个后期处理步骤。mIOU=79.7 RefineNet使用空洞卷积的方法也存在一定的缺点，它的计算成本比较高，同时由于需处理大量高分辨率特征图谱，会占用大量内存，这个问题阻碍了高分辨率预测的计算研究。DeepLab得到的预测结果只有原始输入的1/8大小。所以，这篇论文提出了相应的编码器-解码器结构，其中编码器是ResNet-101模块，解码器为能融合编码器高分辨率特征和先前RefineNet模块低分辨率特征的RefineNet模块。mIOU=84.2 PSPNet全局场景分类很重要，由于它提供了分割类别分布的线索。金字塔池化模块使用大内核池化层来捕获这些信息。和上文提到的空洞卷积论文一样，PSPNet也用空洞卷积来改善Resnet结构，并添加了一个金字塔池化模块。该模块将ResNet的特征图谱连接到并行池化层的上采样输出，其中内核分别覆盖了图像的整个区域、半各区域和小块区域。在ResNet网络的第四阶段(即输入到金字塔池化模块后)，除了主分支的损失之外又新增了附加损失，这种思想在其他研究中也被称为中级监督(intermediate supervision)。mIOU=82.6-85.4 大内核Large Kernel Matters这项研究通过全局卷积网络来提高语义分割的效果。语义分割不仅需要图像分割，而且需要对分割目标进行分类。在分割结构中不能使用全连接层，这项研究发现可以使用大维度内核来替代。采用大内核结构的另一个原因是，尽管ResNet等多种深层网络具有很大的感受野，有相关研究发现网络倾向于在一个小得多的区域来获取信息，并提出了有效感受野的概念。大内核结构计算成本高，且具有很多结构参数。因此，k×k卷积可近似成1×k＋k×1和k×1＋1×k的两种分布组合。这个模块称为全局卷积网络(Global Convolutional Network, GCN)。接下来谈结构，ResNet(不带空洞卷积)组成了整个结构的编码器部分，同时GCN网络和反卷积层组成了解码器部分。该结构还使用了一种称作边界细化(Boundary Refinement，BR)的简单残差模块。mIOU=82.2-83.6 Deeplabv3与在DeepLab v2网络、空洞卷积中一样，这项研究也用空洞卷积/多空卷积来改善ResNet模型。这篇论文还提出了三种改善ASPP的方法，涉及了像素级特征的连接、加入1×1的卷积层和三个不同比率下3×3的空洞卷积，还在每个并行卷积层之后加入了批量归一化操作。级联模块实际上是一个残差网络模块，但其中的空洞卷积层是以不同比率构建的。这个模块与空洞卷积论文中提到的背景模块相似，但直接应用到中间特征图谱中，而不是置信图谱。置信图谱是指其通道数与类别数相同的CNN网络顶层特征图谱。该论文独立评估了这两个所提出的模型，尝试结合将两者结合起来并没有提高实际性能。两者在验证集上的实际性能相近，带有ASPP结构的模型表现略好一些，且没有加入CRF结构。这两种模型的性能优于DeepLabv2模型的最优值，文章中还提到性能的提高是由于加入了批量归一化层和使用了更优的方法来编码多尺度背景。mIOU=85.7","path":"2019/08/05/语义分割/","date":"08-05","excerpt":"","tags":[{"name":"deeplearning","slug":"deeplearning","permalink":"https://litianbo243.github.io/tags/deeplearning/"},{"name":"语义分割","slug":"语义分割","permalink":"https://litianbo243.github.io/tags/语义分割/"}]},{"title":"Git使用指南","text":"简介Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git安装配置Ubuntu$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2 Windows在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：安装包下载地址：https://gitforwindows.org/完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 Git工作流程一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 下图展示了 Git 的工作流程： Git工作区、暂存区和版本库基本概念我们先来理解下Git 工作区、暂存区和版本库概念 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git创建仓库git init# 先cd带制定目录$ git init# 就初始化成功了 git clone# 克隆仓库$ git clone &lt;repo&gt;# 克隆到制定目录$ git clone &lt;repo&gt; &lt;directory&gt;# repo:Git仓库# directory:本地目录 Git基本操作git add# 查看文件状态$ git status -s?? README?? hello.php$ git add README hello.php$ git status -sA READMEA hello.php# 在README中添加一些内容，保存后推出，再执行git status$ git status -sAM READMEA hello.php# &quot;AM&quot; 状态的意思是，这个文件在我们将它添加到缓存之后又有改动# 改动后我们再执行 git add 命令将其添加到缓存中$ git add .$ git status -sA READMEA hello.php# 当你要将你的修改包含在即将提交的缓存中的时候，需要执行git add git commit使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。 $ git config --global user.name &apos;ltb&apos;$ git config --global user.email 351526199@qq.com 接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。 $ git add hello.php$ git status -sA READMEA hello.php$ git commit -m &apos;第一次版本提交&apos;[master (root-commit) d32cf1f] 第一次版本提交 2 files changed, 4 insertions(+) create mode 100644 README create mode 100644 hello.php 现在我们已经记录了快照。如果我们再执行 git status: $ git status# On branch masternothing to comxmit (working directory clean) git reset HEADgit reset HEAD 命令用于取消已缓存的内容。我们先改动文件 README 文件，内容如下： # Runoob Git 测试# 菜鸟教程 hello.php 文件修改为： &lt;?phpecho &apos;菜鸟教程：www.runoob.com&apos;;echo &apos;菜鸟教程：www.runoob.com&apos;;echo &apos;菜鸟教程：www.runoob.com&apos;;?&gt; 现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下： $ git status -s M README M hello.php $ git add .$ git status -sM READMEM hello.php$ git reset HEAD hello.php Unstaged changes after reset:M hello.php$ git status -sM README M hello.php 现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。 $ git commit -m &apos;修改&apos;[master f50cfda] 修改 1 file changed, 1 insertion(+)$ git status -s M hello.php git rm如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作 $ git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f $ git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可 $ git rm --cached &lt;file&gt; 如我们删除 hello.php文件： $ git rm hello.php rm &apos;hello.php&apos;$ lsREADME 不从工作区中删除文件： $ git rm --cached README rm &apos;README&apos;$ lsREADME 可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件： git rm –r * 进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。 Git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。创建分支命令： $ git branch (branchname) 切换分支命令： # git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。合并分支命令: $ git merge 列出分支$ git branch* master$ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 $ lsREADME$ echo &apos;runoob.com&apos; &gt; test.txt$ git add .$ git commit -m &apos;add test.txt&apos;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch &apos;testing&apos;$ lsREADME 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。 $ git checkout masterSwitched to branch &apos;master&apos;$ lsREADME test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 $ git checkout -b newtestSwitched to a new branch &apos;newtest&apos;$ git rm test.txt rm &apos;test.txt&apos;$ lsREADME$ touch hello.php$ git add .$ git commit -am &apos;removed test.txt、add runoob.php&apos;[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php$ git checkout masterSwitched to branch &apos;master&apos;$ lsREADME test.txt 如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。 删除分支$ git branch* master testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 分支合并一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： $ git branch* master newtest$ lsREADME test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。合并完后就可以删除分支: $ git branch -d newtestDeleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了： $ git branch* master 合并冲突合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 $ git branch* master$ cat runoob.php 首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为: &lt;?phpecho &apos;runoob&apos;;?&gt; 创建 change_site 分支： $ git checkout -b change_siteSwitched to a new branch &apos;change_site&apos;$ vim runoob.php$ head -3 runoob.php&lt;?phpecho &apos;runoob&apos;;?&gt;$ git commit -am &apos;changed the runoob.php&apos;[change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+) 将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。 $ git checkout masterSwitched to branch &apos;master&apos;$ cat runoob.php$ vim runoob.php # 修改内容如下$ cat runoob.php&lt;?phpecho 1;?&gt;$ git diffdiff --git a/runoob.php b/runoob.phpindex e69de29..ac60739 100644--- a/runoob.php+++ b/runoob.php@@ -0,0 +1,3 @@+&lt;?php+echo 1;+?&gt;$ git commit -am &apos;修改代码&apos;[master c68142b] 修改代码 1 file changed, 3 insertions(+) 现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。 $ git merge change_siteAuto-merging runoob.phpCONFLICT (content): Merge conflict in runoob.phpAutomatic merge failed; fix conflicts and then commit the result.$ cat runoob.php # 代开文件，看到冲突内容&lt;?php&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADecho 1;=======echo &apos;runoob&apos;;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site?&gt; 我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 $ vim runoob.php $ cat runoob.php&lt;?phpecho 1;echo &apos;runoob&apos;;?&gt;$ git diffdiff --cc runoob.phpindex ac60739,b63d7d7..0000000--- a/runoob.php+++ b/runoob.php@@@ -1,3 -1,3 +1,4 @@@ &lt;?php +echo 1;+ echo &apos;runoob&apos;; ?&gt; 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -sUU runoob.php$ git add runoob.php$ git status -sM runoob.php$ git commit[master 88afe0e] Merge branch &apos;change_site&apos; Git查看提交历史我们可以用 –oneline 选项来查看历史记录的简洁的版本。 $ git log --oneline$ git log --onelined5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;c68142b 修改代码7774248 (change_site) changed the runoob.phpc1501a2 removed test.txt、add runoob.php3e92c19 add test.txt3b58100 第一次版本提交 这告诉我们的是，此项目的开发历史。我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项： * d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交 Git标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 $ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了： * d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 3b58100$ git log --oneline --decorate --graph* d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 (tag: v0.9) 第一次版本提交 如果我们要查看所有标签可以使用以下命令： $ git tagv0.9v1.0 Github要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下： $ git remote add [shortname] [url] 本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：使用以下命令生成 SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。回到 github 上，进入 Account =&gt; Settings（账户配置）。左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。添加成功后界面如下所示为了验证是否成功，输入以下命令： $ ssh -T git@github.comHi tianqixin! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 以下命令说明我们已成功连上 Github。之后登录后点击” New repository “ 如下图所示：创建成功后，显示如下信息：以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。现在，我们根据 GitHub 的提示，在本地的仓库下运行命令： $ mkdir runoob-git-test # 创建测试目录$ cd runoob-git-test/ # 进入测试目录$ echo &quot;# 菜鸟教程 Git 测试&quot; &gt;&gt; README.md # 创建 README.md 文件并写入内容$ ls # 查看目录下的文件README$ git init # 初始化$ git add README.md # 添加文件$ git commit -m &quot;添加 README.md 文件&quot; # 提交并备注信息[master (root-commit) 0205aab] 添加 README.md 文件 1 file changed, 1 insertion(+) create mode 100644 README.md# 提交到 Github$ git remote add origin git@github.com:tianqixin/runoob-git-test.git$ git push -u origin master 以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上： fork如上图所示找到想要pull request的项目，然后点击fork按钮，此时变会在你的仓库中多出来一个仓库，名字为：自己的账户名/想要pull request的项目的名称 clone通过运行命令：git clone https://github.com/fengyanWang/first-pr.git（后面的网址为你自己账户下刚刚生成的那个新的仓库的地址），将该仓库克隆到当前的开发环境中 branch通过在终端运行命令：git branch -a查看当前所在的分支，通常我们都是在查看分支后再进行代码的修改，这是一个好的习惯。在应用github修改代码时，我们常常采用的策略是在主分支下在创建一个特性分支，在该特性分支下进行代码的修改然后通过该分支执行pull request操作。通过命令：git checkout -b work master(其中work为你新建的特性分支，master为你当前坐在的分支)创建新的特性分支并自动切换 添加修改在刚刚新创建的分支下对fork下的工程进行修改 首先使用命令：git diff查看修改的内容是否正确，然后使用命令：git add readMe.md（其中readMe.md为要添加的文件）向仓库中添加文件，在执行命令：git commit -m “add readMe.md文件”提交说明 要从github发送pull request，github端的仓库中必须有一个包含了修改后的代码的分支，所以需要创建一个与刚刚创建的特性分支（修改所在的分支）相对应的远程分支，执行命令：git push origin work1(其中origin为当时fork的远程主分支的名称，一般默认为origin,work1为本地工作的特性分支)，然后执行：git branch -a进行查看是否创建成功 发送pull request进入到自己的github账户下，并切换到创建的特性分支下，然后点击create pull request后，确定没问题，填写相关内容，然后点击send pull requests","path":"2019/08/05/Git使用指南/","date":"08-05","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://litianbo243.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://litianbo243.github.io/tags/github/"}]},{"title":"python 多线程、多进程","text":"导读真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。当然，真正地同时执行多线程需要多核CPU才可能实现。 我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。 多线程添加线程# 导入模块import threading# 获取已激活的线程数threading.active_count()# 查看所有线程信息threading.enumerate()# 查看现在正在运行的线程threading.current_thread()# 添加线程，threading.Thread()接收参数target代表这个线程要完成的任务def thread_job(): print(&apos;This is a thread of %s&apos; % threading.current_thread())def main(): thread = threading.Thread(target=thread_job,) # 定义线程 thread.start() # 让线程开始工作 if __name__ == &apos;__main__&apos;: main() join功能使用join对控制多个线程的执行顺序非常关键。join功能是等待调用线程完成再继续下面的操作。推荐如下这种1221的V型排布。示例代码 def T1_job(): print(&quot;T1 start\\n&quot;) for i in range(10): time.sleep(0.1) print(&quot;T1 finish\\n&quot;)def T2_job(): print(&quot;T2 start\\n&quot;) print(&quot;T2 finish\\n&quot;)thread_1 = threading.Thread(target=T1_job, name=&apos;T1&apos;)thread_2 = threading.Thread(target=T2_job, name=&apos;T2&apos;)----------------------------------------------------------------------thread_1.start() # start T1thread_2.start() # start T2thread_2.join() # join for T2thread_1.join() # join for T1print(&quot;all done\\n&quot;)&quot;&quot;&quot;T1 startT2 startT2 finishT1 finishall done&quot;&quot;&quot; setDaemon功能setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(),这个的意思是，把主线程A设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出.这就是setDaemon方法的含义，这基本和join是相反的。示例代码 import threading import time class MyThread(threading.Thread): def __init__(self,id): threading.Thread.__init__(self) def run(self): time.sleep(5) print &quot;This is &quot; + self.getName() if __name__ == &quot;__main__&quot;: t1=MyThread(999) t1.setDaemon(True) t1.start() print &quot;I am the father thread.&quot; &quot;&quot;&quot;I am the father thread.&quot;&quot;&quot;# 可以看出，子线程t1中的内容并未打出。 线程锁Locklock在不同线程使用同一共享内存时，能够确保线程之间互不影响，使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。示例代码 import threadingdef job1(): global A,lock lock.acquire() for i in range(10): A+=1 print(&apos;job1&apos;,A) lock.release()def job2(): global A,lock lock.acquire() for i in range(10): A+=10 print(&apos;job2&apos;,A) lock.release()if __name__== &apos;__main__&apos;: lock=threading.Lock() A=0 t1=threading.Thread(target=job1) t2=threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join() &quot;&quot;&quot;job1 1job1 2job1 3job1 4job1 5job1 6job1 7job1 8job1 9job1 10job2 20job2 30job2 40job2 50job2 60job2 70job2 80job2 90job2 100job2 110&quot;&quot;&quot; 其他常用操作import threading# 队列from queue import Queuedef job(i, q): print(&quot;i&apos;m thread &#123;&#125; &quot;.format(i)) i = i**2 # 将结果存入队列中，因为多线程函数不能有return q.put(i) q =Queue()threads = []for i in range(4): t = threading.Thread(target=job,args=(i, q)) t.start() # 将进程加入列表 threads.append(t)# 逐个joinfor thread in threads: thread.join() # 得到队列中元素，result# 测试后发现结果顺序有一定概率不准确。。。result = []for _ in range(4): result.append(q.get()) print(result) GILPython 的设计上, 有一个必要的环节, 就是 Global Interpreter Lock (GIL). 这个东西让 Python 还是一次性只能处理一个东西. GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。 所以Python的多线程就是假的。。。。 多进程Python提供多进程的原因很简单, 就是用来弥补 threading 的一些劣势, 比如在 GIL. 添加进程示例代码 # 多进程import multiprocessing as mpdef job(a,d): print(&apos;aaaaa&apos;) print(mp.current_process())if __name__==&apos;__main__&apos;: p1 = mp.Process(target=job,args=(1,2)) print(mp.current_process()) p1.start() p1.join() 进程池进程池就是我们将所要运行的东西，放到池子里，Python会自行解决多进程的问题示例代码 import multiprocessing as mpdef job(x): return x*x # 定义一个poolpool = mp.Pool()# 有了池子之后，就可以让池子对应某一个函数，我们向池子里丢数据，池子就会返回函数返回的值。Pool和之前的Process的不同点是丢向Pool的函数有返回值，而Process的没有返回值。# 接下来用map()获取结果，在map()中需要放入函数和需要迭代运算的值，然后它会自动分配给CPU核res = pool.map(job, range(10))print(res) 自定义核数量Pool默认大小是CPU的核数，我们也可以通过在Pool中传入processes参数即可自定义需要的核数量。示例代码 def multicore(): pool = mp.Pool(processes=3) # 定义CPU核数量为3 res = pool.map(job, range(10)) print(res) apply_async示例代码 import multiprocessing as mpdef job(x): return x*xpool = mp.Pool()multi_res = [pool.apply_async(job, (i,)) for i in range(10)]print([res.get() for res in multi_res])# 和map差不多 共享内存我们可以通过使用Value数据存储在一个共享的内存表中。 import multiprocessing as mpvalue1 = mp.Value(&apos;i&apos;, 0) value2 = mp.Value(&apos;d&apos;, 3.14) 其中d和i参数用来设置数据类型的，d表示一个双精浮点类型，i表示一个带符号的整型。更多的形式请查看此表. | Type code | C Type | Python Type | Minimum size in bytes || --------- | ------------------ | ----------------- | --------------------- || `&apos;b&apos;` | signed char | int | 1 || `&apos;B&apos;` | unsigned char | int | 1 || `&apos;u&apos;` | Py_UNICODE | Unicode character | 2 || `&apos;h&apos;` | signed short | int | 2 || `&apos;H&apos;` | unsigned short | int | 2 || `&apos;i&apos;` | signed int | int | 2 || `&apos;I&apos;` | unsigned int | int | 2 || `&apos;l&apos;` | signed long | int | 4 || `&apos;L&apos;` | unsigned long | int | 4 || `&apos;q&apos;` | signed long long | int | 8 || `&apos;Q&apos;` | unsigned long long | int | 8 || `&apos;f&apos;` | float | float | 4 || `&apos;d&apos;` | double | float | 8 | 在Python的mutiprocessing中，有还有一个Array类，可以和共享内存交互，来实现在进程之间共享数据。 array = mp.Array(&apos;i&apos;, [1, 2, 3, 4]) 这里的Array和numpy中的不同，它只能是一维的，不能是多维的。同样和Value 一样，需要定义数据形式，否则会报错。 进程锁为了解决不同进程抢共享资源的问题，我们可以用加进程锁来解决。示例代码 import multiprocessing as mpimport timedef job(v, num, l): l.acquire() # 锁住 for _ in range(5): time.sleep(0.1) v.value += num # 获取共享内存 print(v.value) l.release() # 释放def multicore(): l = mp.Lock() # 定义一个进程锁 v = mp.Value(&apos;i&apos;, 0) # 定义共享内存 p1 = mp.Process(target=job, args=(v,1,l)) # 需要将lock传入 p2 = mp.Process(target=job, args=(v,3,l)) p1.start() p2.start() p1.join() p2.join()if __name__ == &apos;__main__&apos;: multicore() &quot;&quot;&quot;12345811141720&quot;&quot;&quot;# 显然，进程锁保证了进程p1的完整运行，然后才进行了进程p2的运行","path":"2019/08/05/python 多线程、多进程/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"多线程","slug":"多线程","permalink":"https://litianbo243.github.io/tags/多线程/"},{"name":"多进程","slug":"多进程","permalink":"https://litianbo243.github.io/tags/多进程/"}]},{"title":"专利申请指南","text":"专利申请流程专利类别专利分为发明专利、外观专利和实用新型。外观专利3-4个月授权2个多月下证书，总共6个月左右。实用新型4-6个月会接到授权通知，交费后2个多月会受到证书，总共8个月左右。注：外观专利和实用新型现在比较快，6个月以内都会出结果，快的2-3个月。发明专利时间不一定，想较于外观专利和实用新型时间较长，要求提前公开的情况下，有1年多、2年授权的。不要求提前公开的话4-5年授权的也有，6年以上的也有，但不是很多。 具体流程依据专利法，发明专利申请的审批程序包括受理、初审、公布、实审以及授权五个阶段。实用新型或者外观设计专利申请在审批中不进行从早期公布和实质审查，只有受理、初审和授权三个阶段。发明、实用新型和外观设计专利的申请、审查流程图如下： 如何写专利专利检索系统 innojoy 润桐 几乎所有的专利都分为以下几块：说明书摘要、摘要附图、权利要求书、技术领域、背景技术、发明内容、附图说明、具体实施方案、说明书附图 说明书摘要就是本发明的方案概述以及达到的技术效果，不超过300字，写作套路就是把权利要求书概括一下，再增加一些技术效果，这个一般写完权利要求再写。 摘要附图就是本发明最具有代表性的一张图，这个等你吧说明书附图都画好了，从里面选一个最具有代表性的应该不是什么难事。 权利要求书要依照本发明方案具体来写，一般分为若干独立权利要求以及一系列的从属权利要求，这一部分也是专利最为重要的部分，怎么写后面会详细说明。 技术领域就是本发明所在的领域，写过论文的都应该知道怎么写，专利里的技术领域可以概括的去写，比如手机的技术领域就是电子技术领域、数据传输方法为通信领域、，当然，也可以再跟上一句“尤其涉及一种……领域”，进行进一步的技术领域限定。 背景技术就是介绍一下该技术领域现在的发展状况以及遇到的问题，这跟你论文里面的背景技术一模一样。 发明内容这部分也有套路，等把权利要求写好之后copy一下粘贴过来，然后把每个权利要求中“其特征在于”之前的语句（包括其特征在于这几个字）改成“可选地”，然后再最后另起一段说一下本发明的有益效果，OK,发明内容部分也写完了。 附图说明就是说一下每个说明书的附图事项表示什么意思，比如图1为本发明实施例一提供的方法流程图，图2为本发明实施例一提供的装置结构示意图。 具体实施方式就是拿出一个具体的例子来解释本发明的技术方案，专利中为何需要这一部分呢？因为权利要求书看起来不太像人话，具体实施方式就是要用人话把权利要求解释清楚，在具体实施方式中，你可以把权利要求中的每一句话用日常用语解释清楚，可以举例说明也可以对权利要求中的一些用词进行详细解释，如果你把每个技术特征解释完之后还能再说一下采用该技术特征的优势，那你这个专利的具体实施方式就已经堪称完美了。 说明书附图就是为了能更清楚地解释具体实施方式，可能你会画几个图对应着来说，也就是说你把写具体实施方式的时候画的几张图片放在这里，就是说明书附图了。 详细说明从上面的内容可以看出，一个专利中最核心的内容就是权力要求书，其他所有的内容都是胃药权利要求进行撰写的，把权利要求写好之后按照套路来完成专利的其他部分就可以，下面具体介绍如何撰写专利的权力要求。 如何撰写权力要求书举个例子，比如你要申请一件发明专利，想要解决两个问题：第一，如何把大象装进冰箱，第二，如何防止大象自己从冰箱中逃出来。为此，你设计了一种把大象关进冰箱的方法：第一步，把冰箱门打开，第二步，把大象放进冰箱，第三步，把冰箱门关上，第四步，把冰箱门锁上。现在方案很清楚了，可以写专利了，以上方案转化为专利权力要求就变成： 1.一种把大象关进冰箱的方法，其中，所述冰箱至少包括门体、腔体和锁体，其特征在于，包括以下步骤：步骤一、将所述冰箱的所述门体打开；步骤二、强所述大象放置于所述冰箱的所述腔体内部；步骤三、将所述冰箱的所述门体关闭；步骤四、将所述冰箱的所述锁体切换至锁定状态。 上面这段话可能看起来很别扭，单专利只有这么写才能清楚、完整、毫无疑问地表述我们的发明方案，有些方案通过专利语言表达出来也可能会有歧义，比如讲锁体切换至锁定状态具体是指什么意思？这个时候就需要在具体实施方式中进行详细解释了。以上，权利要求就写好了，根据上面说的“套路”，整个专利围绕权利要求应该能够很快写出。 专利局官网信息专利的提交形式申请人应当以电子形式或者书面形式提交专利申请。1.申请人以电子文件形式申请专利的，应当事先办理电子申请用户注册手续，通过专利局专利电子申请系统向专利局提交申请文件及其他文件。2.申请人以书面形式申请专利的，可以将申请文件及其他文件当面交到专利局的受理窗口或寄交至“国家知识产权局专利局受理处”（以下简称专利局受理处），也可以当面交到设在地方的专利局代办处的受理窗口或寄交至“国家知识产权局专利局×××代办处”。目前专利局在北京、沈阳、济南、长沙、成都、南京、上海、广州、西安、武汉、郑州、天津、石家庄、哈尔滨、长春、昆明、贵阳、杭州、重庆、深圳、福州、南宁、乌鲁木齐、南昌、银川、合肥、苏州、海口、兰州、太原等城市设立代办处。查询专利局代办处信息可登陆http://www.cnipa.gov.cn/zldbc/ 。国防知识产权局专门受理国防专利申请。 申请专利应当提交哪些文件（1）申请发明专利的，申请文件应当包括：发明专利请求书、说明书摘要（必要时应当提交摘要附图）、权利要求书、说明书（必要时应当提交说明书附图）。 涉及氨基酸或者核苷酸序列的发明专利申请，说明书中应当包括该序列表，把该序列表作为说明书的一个单独部分提交，并单独编写页码，同时还应提交符合国家知识产权局专利局（以下简称专利局）规定的记载有该序列表的光盘或软盘。 依赖遗传资源完成的发明创造申请专利的，申请人应当在请求书中对遗传资源的来源予以说明，并填写遗传资源来源披露登记表，写明该遗传资源的直接来源和原始来源。申请人无法说明原始来源的，应当陈述理由。 （2）申请实用新型专利的，申请文件应当包括：实用新型专利请求书、说明书摘要及其摘要附图、权利要求书、说明书、说明书附图。 示例1：实用新型专利申请撰写示例 （3）申请外观设计专利的，申请文件应当包括：外观设计专利请求书、图片或者照片（要求保护色彩的，应当提交彩色图片或者照片）以及对该外观设计的简要说明。 示例1：外观设计申请撰写示例 示例2：相似外观设计申请撰写示例 申请文件使用统一制定的表格申请文件应当使用专利局统一制定的表格。这些表格可以从国家知识产权局网站下载，下载地址http://www.cnipa.gov.cn/bgxz/ ，或者在专利局受理大厅的咨询处索取或以信函方式索取（信函寄至：国家知识产权局专利局初审及流程管理部发文处），也可以向各地的国家知识产权局专利局代办处（以下简称专利局代办处）索取。一张表格只能用于一件专利申请。 申请文件的纸张质量应当相当于复印机用纸的质量。纸面不得有无用的文字、记号、框、线等。各种文件一律采用A4尺寸（210毫米×297毫米）的纸张。申请文件的纸张应当单面、纵向使用。文字应当自左向右排列，纸张左边和上边应当各留25毫米空白，右边和下边应当各留15毫米空白。 提交申请时如何排列申请文件发明或者实用新型专利申请文件应当按照下列顺序排列：请求书、说明书摘要、摘要附图、权利要求书、说明书（含氨基酸或核苷酸序列表）、说明书附图。 外观设计专利申请文件应当按照下列顺序排列：请求书、图片或照片、简要说明。申请文件各部分都应当分别用阿拉伯数字顺序编写页码。 申请文件的字数和书写要求申请文件各部分一律使用中文。外国人名、地名和科技术语如没有统一中文译文，应当在中文译文后的括号内注明原文。申请文件都应当用宋体、仿宋体或楷体打字或印刷，字迹呈黑色，字高应当在3.5～4.5毫米之间，行距应当在2.5～3.5毫米之间。申请文件中有附图的，线条应当均匀清晰，不得涂改。不得使用工程蓝图作为附图。 证明文件办理专利申请相关手续要附具证明文件的，各种证明文件应当由有关主管部门出具或者由当事人签署。各种证明文件应当是原件；证明文件是复印件的，应当经公证或者由出具证明文件的主管部门加盖公章予以确认（原件在专利局备案确认的除外）。申请人提供的证明文件是外文的，应当附有中文题录译文。 TODO","path":"2019/08/05/专利申请/","date":"08-05","excerpt":"","tags":[{"name":"专利","slug":"专利","permalink":"https://litianbo243.github.io/tags/专利/"}]},{"title":"卷积神经网络原理","text":"人类视觉原理人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例：对于不同的物体，人类视觉也是通过这样逐层分级，来进行认知的：我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。 那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，较低层的识别初级的图像特征，若干底层特征组成更上一层特征，最终通过多个层级的组合，最终在顶层做出分类呢？答案是肯定的，这也是许多深度学习算法（包括CNN）的灵感来源。 卷积神经网络这是一个最典型的卷积网络，由卷积层、池化层、全连接层组成。其中卷积层与池化层配合，组成多个卷积组，逐层提取特征，最终通过若干个全连接层完成分类。卷积层完成的操作，可以认为是受局部感受野概念的启发，而池化层，主要是为了降低数据维度。综合起来说，CNN通过卷积来模拟特征区分，并且通过卷积的权值共享及池化，来降低网络参数的数量级，最后通过传统神经网络完成分类等任务。 卷积（Convolution）卷积运算的定义如下图所示：在具体应用中，往往有多个卷积核，可以认为，每个卷积核代表了一种图像模式，如果某个图像块与此卷积核卷积出的值大，则认为此图像块十分接近于此卷积核。如果我们设计了6个卷积核，可以理解：我们认为这个图像上有6种底层纹理模式，也就是我们用6中基础模式就能描绘出一副图像。以下就是24种不同的卷积核的示例： 池化（Pooling）池化听起来很高深，其实简单的说就是下采样。池化的过程如下图所示：上图中，我们可以看到，原始图片是20x20的，我们对其进行下采样，采样窗口为10x10，最终将其下采样成为一个2x2大小的特征图。之所以这么做的原因，是因为即使做完了卷积，图像仍然很大（因为卷积核比较小），所以为了降低数据维度，就进行下采样。之所以能这么做，是因为即使减少了许多数据，特征的统计属性仍能够描述图像，而且由于降低了数据维度，有效地避免了过拟合。在实际应用中，池化根据下采样的方法，分为最大值下采样（Max-Pooling）与平均值下采样（Mean-Pooling）。 反向传播原理为多元函数微积分中的链式求导规则，通过链式求导规则，把梯度传给每个卷积核的权重，更新使他们学习到新的特征。 pooling层的反向求导为：对于mean pooling，假设pooling的窗大小是2x2, 在forward的时候啊，就是在前面卷积完的输出上依次不重合的取2x2的窗平均，得到一个值就是当前mean pooling之后的值。backward的时候，把一个值分成四等分放到前面2x2的格子里面就好了。如下 forward: [1 3; 2 2] -&gt; [2]backward: [2] -&gt; [0.5 0.5; 0.5 0.5] max pooling就稍微复杂一点，forward的时候你只需要把2x2窗子里面那个最大的拿走就好了，backward的时候你要把当前的值放到之前那个最大的位置，其他的三个位置都弄成0。如下 forward: [1 3; 2 2] -&gt; 3backward: [3] -&gt; [0 3; 0 0] 卷积神经网络中的trick分组卷积Group convolution在AlexNet中被提出，可以节省显存，减少参数量。 3*3卷积核在VGGNet中被提出，使用3*3的卷积核可以减少参数数量，效果比大卷积核更好。 每层使用多个尺寸的卷积核在Inception中被提出，事实上，同一层feature map可以分别使用多个不同尺寸的卷积核，以获得不同尺度的特征，再把这些特征结合起来，得到的特征往往比使用单一卷积核的要好。 减少卷积层参数量–Bottleneck在Inception中被提出，如果仅仅引入多个尺寸的卷积核，会带来大量的额外的参数，受到Network In Network中1×1卷积核的启发，为了解决这个问题，他们往Inception结构中加入了一些1×1的卷积核。1×1卷积核也被认为是影响深远的操作，往后大型的网络为了降低参数量都会应用上1×1卷积核。 训练更深的网络–ResNet传统的卷积层层叠网络会遇到一个问题，当层数加深时，网络的表现越来越差，很大程度上的原因是因为当层数加深时，梯度消散得越来越严重，以至于反向传播很难训练到浅层的网络。为了解决这个问题，何凯明大神想出了一个“残差网络”，使得梯度更容易地流动到浅层的网络当中去。 DepthWise操作标准的卷积过程可以看上图，一个2×2的卷积核在卷积时，对应图像区域中的所有通道均被同时考虑，问题在于，为什么一定要同时考虑图像区域和通道？我们为什么不能把通道和空间区域分开考虑？Xception网络就是基于以上的问题发明而来。我们首先对每一个通道进行各自的卷积操作，有多少个通道就有多少个过滤器。得到新的通道feature maps之后，这时再对这批新的通道feature maps进行标准的1×1跨通道卷积操作。这种操作被称为 “DepthWise convolution” ，缩写“DW”。这种操作是相当有效的，在imagenet 1000类分类任务中已经超过了InceptionV3的表现，而且也同时减少了大量的参数。因此，一个depthwise操作比标准的卷积操作降低不少的参数量，同时论文中指出这个模型得到了更好的分类效果。 分组卷积对通道进行随机分组– ShuffleNet在AlexNet的Group Convolution当中，特征的通道被平均分到不同组里面，最后再通过两个全连接层来融合特征，这样一来，就只能在最后时刻才融合不同组之间的特征，对模型的泛化性是相当不利的。为了解决这个问题，ShuffleNet在每一次层叠这种Group conv层前，都进行一次channel shuffle，shuffle过的通道被分配到不同组当中。进行完一次group conv之后，再一次channel shuffle，然后分到下一层组卷积当中，以此循环。经过channel shuffle之后，Group conv输出的特征能考虑到更多通道，输出的特征自然代表性就更高。另外，AlexNet的分组卷积，实际上是标准卷积操作，而在ShuffleNet里面的分组卷积操作是depthwise卷积，因此结合了通道洗牌和分组depthwise卷积的ShuffleNet，能得到超少量的参数以及超越mobilenet、媲美AlexNet的准确率！ 给通道加上权重–SENet无论是在Inception、DenseNet或者ShuffleNet里面，我们对所有通道产生的特征都是不分权重直接结合的，那为什么要认为所有通道的特征对模型的作用就是相等的呢？ 这是一个好问题，于是，ImageNet2017 冠军SEnet就出来了。一组特征在上一层被输出，这时候分两条路线，第一条直接通过，第二条首先进行Squeeze操作（Global Average Pooling），把每个通道2维的特征压缩成一个1维，从而得到一个特征通道向量（每个数字代表对应通道的特征）。然后进行Excitation操作，把这一列特征通道向量输入两个全连接层和sigmoid，建模出特征通道间的相关性，得到的输出其实就是每个通道对应的权重，把这些权重通过Scale乘法通道加权到原来的特征上（第一条路），这样就完成了特征通道的权重分配。 更大的接受域–Dilated convolution标准的3×3卷积核只能看到对应区域3×3的大小，但是为了能让卷积核看到更大的范围，dilated conv使其成为了可能。上图b可以理解为卷积核大小依然是3×3，但是每个卷积点之间有1个空洞，也就是在绿色7×7区域里面，只有9个红色点位置作了卷积处理，其余点权重为0。这样即使卷积核大小不变，但它看到的区域变得更大了。 可变的卷积核–Deformable convolutuin传统的卷积核一般都是长方形或正方形，但MSRA提出了一个相当反直觉的见解，认为卷积核的形状可以是变化的，变形的卷积核能让它只看感兴趣的图像区域 ，这样识别出来的特征更佳。要做到这个操作，可以直接在原来的过滤器前面再加一层过滤器，这层过滤器学习的是下一层卷积核的位置偏移量（offset），这样只是增加了一层过滤器，或者直接把原网络中的某一层过滤器当成学习offset的过滤器，这样实际增加的计算量是相当少的，但能实现可变形卷积核，识别特征的效果更好。 启发现在越来越多的CNN模型从巨型网络到轻量化网络一步步演变，模型准确率也越来越高。现在工业界追求的重点已经不是准确率的提升（因为都已经很高了），都聚焦于速度与准确率的trade off，都希望模型又快又准。因此从原来AlexNet、VGGnet，到体积小一点的Inception、Resnet系列，到目前能移植到移动端的mobilenet、ShuffleNet（体积能降低到0.5mb！），我们可以看到这样一些趋势： 卷积核方面：大卷积核用多个小卷积核代替；单一尺寸卷积核用多尺寸卷积核代替；固定形状卷积核趋于使用可变形卷积核；使用1×1卷积核（bottleneck结构）。 卷积层通道方面：标准卷积用depthwise卷积代替；使用分组卷积；分组卷积前使用channel shuffle；通道加权计算。 卷积层连接方面：使用skip connection，让模型更深；densely connection，使每一层都融合上其它层的特征输出（DenseNet） 启发类比到通道加权操作，卷积层跨层连接能否也进行加权处理？bottleneck + Group conv + channel shuffle + depthwise的结合会不会成为以后降低参数量的标准配置？ 上采样在看图像语义分割方面的论文时，发现在网络解码器结构中有的时候使用反卷积、而有的时候使用unpooling或或者unsampling，查了下资料，发现三者还是有不同的。这里记录一下。图（a）表示UnPooling的过程，特点是在Maxpooling的时候保留最大值的位置信息，之后在unPooling阶段使用该信息扩充Feature Map，除最大值位置以外，其余补0。与之相对的是图（b），两者的区别在于UnSampling阶段没有使用MaxPooling时的位置信息，而是直接将内容复制来扩充Feature Map。从图中即可看到两者结果的不同。图（c）为反卷积的过程，反卷积是卷积的逆过程，又称作转置卷积。最大的区别在于反卷积过程是有参数要进行学习的（类似卷积过程），理论是反卷积可以实现UnPooling和unSampling，只要卷积核的参数设置的合理。","path":"2019/08/05/卷积神经网络/","date":"08-05","excerpt":"","tags":[{"name":"deeplearning","slug":"deeplearning","permalink":"https://litianbo243.github.io/tags/deeplearning/"},{"name":"卷积神经网络","slug":"卷积神经网络","permalink":"https://litianbo243.github.io/tags/卷积神经网络/"},{"name":"cv","slug":"cv","permalink":"https://litianbo243.github.io/tags/cv/"}]},{"title":"opencv-python常用函数及其介绍","text":"读取图片、显示图片、写回图片# -*- coding: utf-8 -*-import numpy as npimport cv2print(cv2.__version__)img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_COLOR) #读入一副彩色图像。图像的透明度会被忽略 默认参数。# img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_GRAYSCALE) # Load an color image in grayscale 灰度# img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_UNCHANGED) # 包括图像的 alpha 通道img = cv2.resize(img, (640, 480))#rows, cols, ch = img.shapeprint(&apos;行/高:&apos;, rows, &apos;列/宽:&apos;, cols, &apos;通道:&apos;, ch)# 图像的宽对应的是列数, 高对应的是行数。cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_NORMAL) # 可以调整窗口大小# cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_AUTOSIZE)#自动调整# cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_KEEPRATIO)#保持图片比例# cv2.resizeWindow(&apos;image&apos;, 200, 200) # 不起作用？cv2.imshow(&apos;image&apos;, img) # 窗口会自动调整为图像大小# 在窗口上按任意键退出cv2.waitKey(delay=0) # 返回按键的 ASCII 码值cv2.destroyAllWindows()# # cv2.imwrite(‘/home/ltb/图片/cv2-tutorial/000001.png’, img)颜色转化 # -*- coding: utf-8 -*-# @Time : 2018/1/20 17:15# @Author : play4fun# @File : 颜色转换.py# @Software: PyCharm&quot;&quot;&quot;颜色转换.py:&quot;&quot;&quot;import cv2img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_COLOR)cv2.imshow(&quot;BGR&quot;, img)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)cv2.imshow(&quot;GRAY&quot;, gray)temp = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 灰色转RGBcv2.imshow(&quot;RGB&quot;, temp)cv2.waitKey(0) 读取视频流（单摄像头）# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Fri Jan 3 21:06:22 2014@author: duan &quot;&quot;&quot;&apos;&apos;&apos; 注意 当你的程序报错时 你 先检查的是你的摄像头是否能够在其他程 序中正常工作 比如 linux 下的 Cheese 。&apos;&apos;&apos;import numpy as npimport cv2cap = cv2.VideoCapture(0) # 一般的笔 本电脑 有内置摄像头。所以参数就是 0。你可以 设置成 1 或 者其他的来 择别的摄像头&apos;&apos;&apos;你可以使用函数 cap.get(propId) 来获得 的一些参数信息。propId 可以是 0 到 18 之 的任何整数。其中的一些值可以使用 cap.set(propId,value) 来修改 value 就是 你想 置成的新值。例如 我可以使用 cap.get(3) cv2.CAP_PROP_FRAME_WIDTH和 cap.get(4) cv2.CAP_PROP_FRAME_HEIGHT来查看每一帧的宽和高。默认情况下得到的值是 640X480。但是我可以使用 ret=cap.set(3,320) 和 ret=cap.set(4,240) 来把宽和高改成 320X240。&apos;&apos;&apos;# ret=cap.set(3,320)# ret=cap.set(4,240)# ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, 480)#避免计算量过大# ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 270)## 等比缩放frame_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT) # 4 ，720frame_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH) # 3 ，1280frame_height = int(480 / frame_width * frame_height) # 270ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, frame_height) # 高ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, 480)# while (True):while cap.isOpened(): # 检查是否成功初始化，否则就 使用函数 cap.open() # Capture frame-by-frame ret, frame = cap.read() # ret 返回一个布尔值 True/False # print(&apos;frame shape:&apos;,frame.shape)#(720, 1280, 3) frame = cv2.flip(frame, flipCode=1) # 左右翻转,使用笔记本电脑摄像头才有用。 # flipCode：翻转方向：1：水平翻转；0：垂直翻转；-1：水平垂直翻转 # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow(&apos;frame&apos;, gray) cv2.setWindowTitle(&apos;frame&apos;, &apos;COLOR_BGR2GRAY&apos;) # Property=cv2.getWindowProperty(&apos;frame&apos;,0)#无用 # if cv2.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):#不行 # break key = cv2.waitKey(delay=10) if key == ord(&quot;q&quot;): break# When everything done, release the capturecap.release()cv2.destroyAllWindows() 读取视频流（双摄像头）# -*- coding: utf-8 -*-# @Time : 2017/8/15 00:19# @Author : play4fun# @File : two_camera.py# @Software: PyCharm&quot;&quot;&quot;two_camera.py:&quot;&quot;&quot;import cv2import numpy as npcap0 = cv2.VideoCapture(0)cap1 = cv2.VideoCapture(1)ret = cap0.set(3, 320)ret = cap0.set(4, 240)ret = cap1.set(3, 320)ret = cap1.set(4, 240)while cap0.isOpened() and cap1.isOpened(): ret0, frame0 = cap0.read() ret1, frame1 = cap1.read() if ret0: cv2.imshow(&apos;frame0&apos;, frame0) cv2.setWindowTitle(&apos;frame0&apos;, &apos;On Top&apos;) if ret1: cv2.imshow(&apos;frame1&apos;, frame1) # cv2.moveWindow(&apos;frame1&apos;, x=frame0.shape[1], y=0) cv2.moveWindow(&apos;frame1&apos;, x=320, y=40) key = cv2.waitKey(delay=2) if key == ord(&quot;q&quot;): break# When everything done, release the capturecap0.release()cap1.release()cv2.destroyAllWindows() 读取视频（影片）import numpy as npimport cv2cap = cv2.VideoCapture(&apos;/home/ltb/视频/simplescreenrecorder-2019-04-14_00.52.45.mkv&apos;)# cap = cv2.VideoCapture(&apos;output.avi&apos;)# cap = cv2.VideoCapture(&apos;Minions_banana.mp4&apos;)# 帧率fps = cap.get(cv2.CAP_PROP_FPS) # 25.0print(&quot;Frames per second using video.get(cv2.CAP_PROP_FPS) : &#123;0&#125;&quot;.format(fps))# 总共有多少帧num_frames = cap.get(cv2.CAP_PROP_FRAME_COUNT)print(&apos;共有&apos;, num_frames, &apos;帧&apos;)#frame_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)frame_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)print(&apos;高：&apos;, frame_height, &apos;宽：&apos;, frame_width)FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES) # 第0帧print(&apos;当前帧数&apos;, FRAME_NOW) # 当前帧数 0.0# 读取指定帧,对视频文件才有效，对摄像头无效？？frame_no = 121cap.set(1, frame_no) # Where frame_no is the frame you wantret, frame = cap.read() # Read the framecv2.imshow(&apos;frame_no&apos;+str(frame_no), frame)FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES)print(&apos;当前帧数&apos;, FRAME_NOW) # 当前帧数 122.0while cap.isOpened(): ret, frame = cap.read() FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES) # 当前帧数 print(&apos;当前帧数&apos;, FRAME_NOW) gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imshow(&apos;frame&apos;, gray) key = cv2.waitKey(1) if key == ord(&quot;q&quot;): breakcap.release()cv2.destroyAllWindows() 写回视频import numpy as npimport cv2cap = cv2.VideoCapture(0)width = 640ret = cap.set(3, width)height = 480ret = cap.set(4, height)# Define the codec and create VideoWriter objectfourcc = cv2.VideoWriter_fourcc(*&apos;XVID&apos;) # opencv 3.0# Error: &apos;module&apos; object has no attribute &apos;VideoWriter_fourcc&apos;# fourcc=cv2.VideoWriter_fourcc(&apos;X&apos;, &apos;V&apos;, &apos;I&apos;, &apos;D&apos;)#jpeg,h263,&apos;m&apos;, &apos;p&apos;, &apos;4&apos;, &apos;v&apos;#out = cv2.VideoWriter(&apos;output.avi&apos;, fourcc, 20.0, (width, height))while cap.isOpened(): ret, frame = cap.read() if ret is True: frame = cv2.resize(frame, (640, 480)) # write the flipped frame out.write(frame) cv2.imshow(&apos;frame&apos;, frame) else: break key = cv2.waitKey(1) if key == ord(&quot;q&quot;): break# Release everything if job is finishedcap.release()out.release()cv2.destroyAllWindows() 绘图函数# -*- coding: utf-8 -*-import numpy as npimport cv2&apos;&apos;&apos;• img: 你想 绘制图形的 幅图像。• color: 形状的颜色。以RGB为例 需要传入一个元组BGR 例如 255,0,0 代表蓝色，第一个是蓝色通道，第二个是绿色通道，第三个是红色通道。对于灰度图只需要传入灰度值。• thickness 线条的粗细。如果给一个闭合图形 置为 -1 那么这个图形就会被填充。 默认值是 1.• linetype 线条的类型， 8 连接，抗锯齿等。 默认情况是8 连接。cv2.LINE_AA 为抗锯齿 这样看起来会非常平滑。&apos;&apos;&apos;# Create a black imageimg = np.zeros((512, 512, 3), np.uint8)# Draw a diagonal blue line with thickness of 5 pxcv2.line(img, pt1=(0, 0), pt2=(511, 511), color=(255, 0, 0), thickness=5) # pt1, pt2, color, thickness=# cv2.polylines() 可以 用来画很多条线。只需要把想 画的线放在一 个列表中， 将 列表传给函数就可以了。每条线 会被独立绘制。 这会比用 cv2.line() 一条一条的绘制 要快一些。# cv2.polylines(img, pts, isClosed, color, thickness=None, lineType=None, shift=None)cv2.arrowedLine(img, pt1=(21, 13), pt2=(151, 401), color=(255, 0, 0), thickness=5)cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)cv2.circle(img, center=(447, 63), radius=63, color=(0, 0, 255), thickness=-1) # center, radius, color, thickness=None# 一个参数是中心点的位置坐标。 下一个参数是长轴和短轴的长度。椭圆沿逆时针方向旋转的角度。# 椭圆弧演顺时针方向起始的角度和结束角度 如果是 0 很 360 就是整个椭圆cv2.ellipse(img, center=(256, 256), axes=(100, 50), angle=0, startAngle=0, endAngle=180, color=255, thickness=-1) # center, axes, angle, startAngle, endAngle, color, thickness=pts = np.array([[10, 5], [20, 30], [70, 20], [50, 10]], np.int32)pts = pts.reshape((-1, 1, 2))# 这里 reshape 的第一个参数为-1, 表明这一维的长度是根据后面的维度的计算出来的。# 注意 如果第三个参数是 False 我们得到的多边形是不闭合的 ，首 尾不相 连 。font = cv2.FONT_HERSHEY_SIMPLEX# org :Bottom-left corner of the text string in the image.左下角# 或使用 bottomLeftOrigin=True,文字会上下颠倒cv2.putText(img, text=&apos;bottomLeftOrigin&apos;, org=(10, 400), fontFace=font, fontScale=1, color=(255, 255, 255), thickness=1, bottomLeftOrigin=True) # text, org, fontFace, fontScale, color, thickness=cv2.putText(img, text=&apos;OpenCV&apos;, org=(10, 500), fontFace=font, fontScale=4, color=(255, 255, 255), thickness=2) # text, org, fontFace, fontScale, color, thickness=# 所有的绘图函数的返回值都是 None ，所以不能使用 img = cv2.line(img,(0,0),(5winname = &apos;example&apos;cv2.namedWindow(winname, 0)cv2.imshow(winname, img)cv2.imwrite(&quot;example.png&quot;, img)cv2.waitKey(0)cv2.destroyAllWindows() 拆分通道、合并通道# -*- coding: utf-8 -*-import cv2import numpy as np# 拆分及合并图像通道img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)#b, g, r = cv2.split(img) # 比较耗时的操作，请使用numpy 索引img = cv2.merge((b, g, r))#b = img[:, :, 0]# 使所有像素的红色通道值都为 0,你不必先拆分再赋值。# 你可以 直接使用 Numpy 索引,这会更快。img[:, :, 2] = 0# 保存到文件，看下效果cv2.imwrite(filename=&apos;split_color2.jpg&apos;, img=img) 图像相加# -*- coding: utf-8 -*-import cv2import numpy as np# 学习图像上的算术运算 加法 减法 位运算等# 你可以使用函数 cv2.add() 将两幅图像进行加法运算 当然也可以直接使 用 numpy ，# res=img1+img# 两幅图像的大小 类型必须一致 ，或者第二个 图像可以使一个简单的标量值。x = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y)) # 250+10 = 260 =&gt; 255# [[255]]print(x + y) # 250+10=260%256=4# [4]# 图像混合img1 = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)img2 = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.png&apos;)dst = cv2.addWeighted(img1, 0.1, img2, 0.9, 0) # 第一幅图的权重是 0.7 第二幅图的权重是 0.3cv2.imshow(&apos;dst&apos;, dst)cv2.waitKey(0)cv2.destroyAllWindows() 图像扩展缩放# -*- coding: utf-8 -*-&apos;&apos;&apos;扩展缩放在缩放时我们推荐使用 cv2.INTER_AREA在扩展时我们推荐使用 v2.INTER_CUBIC 慢) 和 v2.INTER_LINEAR。默认情况下所有改变图像尺寸大小的操作使用的插值方法 是 cv2.INTER_LINEAR。Resize(src, dst, interpolation=CV_INTER_LINEAR)&apos;&apos;&apos;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)# 下面的 None 本应 是 出图像的尺寸 但是因为后边我们设置了缩放因子# 因此这里为 Noneres = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)# OR# 我们直接设置输出图像的尺寸 所以不用设置缩放因子# height, width = img.shape[:2]# res = cv2.resize(img, (2 * width, 2 * height), interpolation=cv2.INTER_CUBIC)cv2.imshow(&apos;resize&apos;, res)cv2.imshow(&apos;src img&apos;, img)cv2.waitKey(0)cv2.destroyAllWindows() Otsu二值化# -*- coding: utf-8 -*-&apos;&apos;&apos;Otsu&apos;s 二值化在第一 分中我们提到 retVal 当我们使用 Otsu 二值化时会用到它。 么它到底是什么呢在使用全局 值时 我们就是 便给了一个数来做 值 我们怎么知 我们 取的 个数的好坏呢? 答案就是不停的尝 。 如果是一副双峰图像 ，简 单来 双峰图像是指图像直方图中存在两个峰 呢 ？ 我们岂不是应 在两个峰 之 的峰 一个值作为阈值 。 就是 Otsu 二值化 做的。 简单来说，就是对一副双峰图像自动根据其直方图计算出一个阈值。 对于非双峰图像 这 种方法 得到的结果可能会不理想 。 这里 用到的函数 是 cv2.threshold() 但是 需要多传入一个参数 flag cv2.THRESH_OTSU。 这时 把 值 为 0。然后算法会找到最 优阈值 ，这 个最优 值就是 回值 retVal。 如果不使用 Otsu 二值化 返回的retVal 值与 设定的 阈值相等。下 的例子中 输入图像是一副带有噪声的图像。第一种方法 我们 设127 为全局 阈值。第二种方法 我们直接使用 Otsu 二值化。第三种方法 我 们 先使用一个 5x5 的 高斯核 去噪 然后再使用 Otsu 二值化。看看噪音 去除对结果的影响有多大吧。&apos;&apos;&apos;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)# global thresholdingret1, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# Otsu&apos;s thresholdingret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# Otsu&apos;s thresholding after Gaussian filtering# 5,5 为 斯核的大小 0 为标准差blur = cv2.GaussianBlur(img, (5, 5), 0)# 阀值一定为 0ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# plot all the images and their histogramsimages = [img, 0, th1, img, 0, th2, blur, 0, th3]titles = [&apos;Original Noisy Image&apos;, &apos;Histogram&apos;, &apos;Global Thresholding (v=127)&apos;, &apos;Original Noisy Image&apos;, &apos;Histogram&apos;, &quot;Otsu&apos;s Thresholding&quot;, &apos;Gaussian filtered Image&apos;, &apos;Histogram&apos;, &quot;Otsu&apos;s Thresholding&quot;]# 使用了 pyplot 中画直方图的方法 plt.hist,# 注意的是它的参数是一维数组# 所以使用了 numpy ravel 方法 将多维数组 换成一维 也可以使用 flatten 方法# ndarray.flat 1-D iterator over an array.# ndarray.flatten 1-D array copy of the elements of an array in row-major order.for i in range(3): plt.subplot(3, 3, i * 3 + 1), plt.imshow(images[i * 3], &apos;gray&apos;) plt.title(titles[i * 3]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 2), plt.hist(images[i * 3].ravel(), 256) plt.title(titles[i * 3 + 1]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 3), plt.imshow(images[i * 3 + 2], &apos;gray&apos;) plt.title(titles[i * 3 + 2]), plt.xticks([]), plt.yticks([])plt.show() 自适应二值化# -*- coding: utf-8 -*-&apos;&apos;&apos;自适应阈值Adaptive Method- 指定 算阈值的方法。– cv2.ADPTIVE_THRESH_MEAN_C 值取自相邻区域的平均值– cv2.ADPTIVE_THRESH_GAUSSIAN_C 值取值相邻区域 的加权和 ，权重为一个高斯窗口&apos;&apos;&apos;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)# 中值滤波img = cv2.medianBlur(img, 5)ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# 11 为 Block size 邻域大小 用来计算阈值的区域大小 ,# 2 为 C值，常数， 阈值就等于的平均值或者加权平均值减去这个常数。th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)titles = [&apos;Original Image&apos;, &apos;Global Thresholding (v = 127)&apos;, &apos;Adaptive Mean Thresholding&apos;, &apos;Adaptive Gaussian Thresholding&apos;]images = [img, th1, th2, th3]for i in range(4): plt.subplot(2, 2, i + 1), plt.imshow(images[i], &apos;gray&apos;) plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 简单二值化# -*- coding: utf-8 -*-&apos;&apos;&apos;简单阈值像素值高于阈值时 我们给这个像素 赋予一个新值， 可能是白色 ， 否则我们给它赋予另外一种颜色， 或是黑色 。 这个函数就是 cv2.threshhold()。 这个函数的第一个参数就是原图像 原图像应 是灰度图。 第二个参数就是用来对像素值进行分类的阈值。 第三个参数 就是当像素值高于， 有时是小于 阈值时应该被赋予的新的像素值。 OpenCV 提供了多种不同的阈值方法 ， 是由第四个参数来决定的。 些方法包括• cv2.THRESH_BINARY• cv2.THRESH_BINARY_INV • cv2.THRESH_TRUNC• cv2.THRESH_TOZERO• cv2.THRESH_TOZERO_INV&apos;&apos;&apos;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)titles = [&apos;Original Image&apos;, &apos;BINARY&apos;, &apos;BINARY_INV&apos;, &apos;TRUNC&apos;, &apos;TOZERO&apos;, &apos;TOZERO_INV&apos;]images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]for i in range(6): plt.subplot(2, 3, i + 1), plt.imshow(images[i], &apos;gray&apos;) plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 图像腐蚀# -*- coding: utf-8 -*-&apos;&apos;&apos;两个基本的形态学操作是腐蚀和膨胀。他们 的变体构成了开运算 ，闭运算， 梯度等。根据卷积核的大小 前景的所有像素 会 腐 掉 变为 0 ，所以前景物体会变小 整幅图像的白色区域会减少。对于去除白噪声很有用 也可以用来断开两个 在一块的物体等。&apos;&apos;&apos;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)cv2.imshow(&apos;Origin&apos;, img)print(img.shape)#您可以将内核看作是一个小矩阵，我们在图像上滑动以进行（卷积）操作，例如模糊，锐化，边缘检测或其他图像处理操作。kernel = np.ones((5, 5), np.uint8)erosion = cv2.erode(img, kernel, iterations=1)cv2.imshow(&apos;erode&apos;, erosion)cv2.moveWindow(&apos;erode&apos;, x=img.shape[1], y=0)cv2.waitKey(0)cv2.destroyAllWindows() 图像膨胀# -*- coding: utf-8 -*-&apos;&apos;&apos;与腐 相反 与卷积核对应的原图像的像素值中只 有一个是 1 中心元 素的像素值就是 1。所以 个操作会增加图像中的白色区域 前景 。一般在去 噪声时先用腐 再用膨胀。因为腐 在去掉白噪声的同时 也会使前景对 变 小。所以我们再对他 膨胀。 时噪声已经 去 了 不会再回来了 但是 前景 在并会增加。膨胀也可以用来 接两个分开的物体。&apos;&apos;&apos;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)cv2.imshow(&apos;Origin&apos;, img)print(img.shape)kernel = np.ones((5, 5), np.uint8)dilation = cv2.dilate(img, kernel, iterations=1)cv2.imshow(&apos;dilation&apos;, dilation)cv2.moveWindow(&apos;dilation&apos;, x=img.shape[1], y=0)cv2.waitKey(0)cv2.destroyAllWindows() 图像匹配# -*-coding:utf8-*-#__author__ = &apos;play4fun&apos;&quot;&quot;&quot;create time:15-10-24 下午5:46原理模板匹配是用来在一副大图中搜寻查找模版图像位置的方法。OpenCV 为 我们提供了函数 cv2.matchTemplate()。和 2D 卷积一样 它也是用模板图像在输入图像 大图 上滑动 并在每一个位置对模板图像和与其对应的 输入图像的子区域 比较。OpenCV 提供了几种不同的比较方法 细节 看 文档 。返回的结果是一个灰度图像 每一个像素值 示了此区域与模板的匹配 程度。如果输入图像的大小是 WxH模板的大小是 wxh 输出的结果 的大小就是 W-w+1 H-h+1 。当你得到这幅图之后 就可以使用函数 cv2.minMaxLoc() 来找到其中的最小值和最大值的位置了。第一个值为矩形左上角的点 位置w h 为 moban 模板矩形的宽和 。这个矩形就是 找到的模板区域了。&quot;&quot;&quot;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;../data/messi5.jpg&apos;, 0)img2 = img.copy()template = cv2.imread(&apos;../data/messi_face.jpg&apos;, 0)w, h = template.shape[::-1]# All the 6 methods for comparison in a listmethods = [&apos;cv2.TM_CCOEFF&apos;, &apos;cv2.TM_CCOEFF_NORMED&apos;, &apos;cv2.TM_CCORR&apos;, &apos;cv2.TM_CCORR_NORMED&apos;, &apos;cv2.TM_SQDIFF&apos;, &apos;cv2.TM_SQDIFF_NORMED&apos;]for meth in methods: img = img2.copy() # exec 语句用来执行储存在字符串或文件中的 Python 语句。 # 例如,我们可以在运行时生成一个包含 Python 代码的字符串, # 然后使用 exec 语句执行这些语句。 # eval 语句用来计算存储在字符串中的有效 Python 表达式 method = eval(meth) # Apply template Matching res = cv2.matchTemplate(img, template, method) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res) # 使用不同的比较方法,对结果的解释不同 # If the method is TM_SQDIFF or TM_SQDIFF_NORMED, take minimum if method in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]: top_left = min_loc else: top_left = max_loc bottom_right = (top_left[0] + w, top_left[1] + h) cv2.rectangle(img, top_left, bottom_right, 255, 2) plt.subplot(121), plt.imshow(res, cmap=&apos;gray&apos;) plt.title(&apos;Matching Result&apos;), plt.xticks([]), plt.yticks([]) plt.subplot(122), plt.imshow(img, cmap=&apos;gray&apos;) plt.title(&apos;Detected Point&apos;), plt.xticks([]), plt.yticks([]) plt.suptitle(&apos;method: &apos; + meth) plt.show() SIFT算法# -*- coding: utf-8 -*-# @Time : 2017/7/13 下午2:23# @Author : play4fun# @File : sift.py# @Software: PyCharm&quot;&quot;&quot;sift.py:尺度不变特征变换关键点 极值点 定位&quot;&quot;&quot;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)sift = cv2.xfeatures2d.SIFT_create()kp = sift.detect(gray, None)img = cv2.drawKeypoints(gray, kp, img)# 计算关键点描述符# 使用函数 sift.compute() 来 计算 些关键点的描述符。例如# kp, des = sift.compute(gray, kp)kp, des = sift.detectAndCompute(gray, None)cv2.imwrite(&apos;sift_keypoints.jpg&apos;, img)cv2.imshow(&apos;sift_keypoints.jpg&apos;, img)cv2.waitKey(0)","path":"2019/08/05/opencv-python常用函数及介绍/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"https://litianbo243.github.io/tags/opencv/"}]},{"title":"tkinter使用指南","text":"Tkinter模块元素简要说明 tkinter类 元素 Button 按钮 Canvas 画布 Checkbutton 复选框 Entry 单行文本框 Frame 框架 Label 标签 LabelFrame 容器控件 Listbox 列表框 Menu 菜单 Menubutton 菜单按钮 Message 消息框 OptionMenu 选择菜单 PanedWindow 窗口布局管理 Radiobutton 单选框 Scale 进度条 Scrollbar 滚动条 Spinbox 输入控件 Text 多行文本框 Toplevel 顶层 messageBox 消息框 Tkinter支持16个核心的窗口部件，这个16个核心窗口部件类简要描述如下：Button：一个简单的按钮，用来执行一个命令或别的操作。Canvas：组织图形。这个部件可以用来绘制图表和图，创建图形编辑器，实现定制窗口部件。Checkbutton：代表一个变量，它有两个不同的值。点击这个按钮将会在这两个值间切换。Entry：文本输入域。Frame：一个容器窗口部件。帧可以有边框和背景，当创建一个应用程序或dialog(对话）版面时，帧被用来组织其它的窗口部件。Label：显示一个文本或图象。Listbox：显示供选方案的一个列表。listbox能够被配置来得到radiobutton或checklist的行为。Menu：菜单条。用来实现下拉和弹出式菜单。Menubutton：菜单按钮。用来实现下拉式菜单。Message：显示一文本。类似label窗口部件，但是能够自动地调整文本到给定的宽度或比率。Radiobutton：代表一个变量，它可以有多个值中的一个。点击它将为这个变量设置值，并且清除与这同一变量相关的其它radiobutton。Scale：允许你通过滑块来设置一数字值。Scrollbar：为配合使用canvas, entry, listbox, and text窗口部件的标准滚动条。Text：格式化文本显示。允许你用不同的样式和属性来显示和编辑文本。同时支持内嵌图象和窗口。Toplevel：一个容器窗口部件，作为一个单独的、最上面的窗口显示。messageBox：消息框，用于显示你应用程序的消息框。(Python2中为tkMessagebox)注意在Tkinter中窗口部件类没有分级；所有的窗口部件类在树中都是兄弟关系。所有这些窗口部件提供了Misc和几何管理方法、配置管理方法和部件自己定义的另外的方法。此外，Toplevel类也提供窗口管理接口。这意味一个典型的窗口部件类提供了大约150种方法。 动手实践学习创建主窗口及Label部件的创建和使用示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定标签l = tk.Label(window, text=&apos;你好！this is Tkinter&apos;, bg=&apos;green&apos;, font=(&apos;Arial&apos;, 12), width=30, height=2)# 说明： bg为背景，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高 # 第5步，放置标签l.pack() # Label内容content区域放置位置，自动调节尺寸# 放置lable的方法有：1）l.pack(); 2)l.place(); # 第6步，主窗口循环显示window.mainloop()# 注意，loop因为是循环的意思，window.mainloop就会让window不断的刷新，如果没有mainloop,就是一个静态的window,传入进去的值就不会有循环，mainloop就相当于一个很大的while循环，有个while，每点击一次就会更新一次，所以我们必须要有循环 测试效果 Button窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定标签var = tk.StringVar() # 将label标签的内容设置为字符类型，用var来接收hit_me函数的传出内容用以显示在标签上l = tk.Label(window, textvariable=var, bg=&apos;green&apos;, fg=&apos;white&apos;, font=(&apos;Arial&apos;, 12), width=30, height=2)# 说明： bg为背景，fg为字体颜色，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高l.pack() # 定义一个函数功能（内容自己自由编写），供点击Button按键时调用，调用命令参数command=函数名on_hit = Falsedef hit_me(): global on_hit if on_hit == False: on_hit = True var.set(&apos;you hit me&apos;) else: on_hit = False var.set(&apos;&apos;) # 第5步，在窗口界面设置放置Button按键b = tk.Button(window, text=&apos;hit me&apos;, font=(&apos;Arial&apos;, 12), width=10, height=1, command=hit_me)b.pack() # 第6步，主窗口循环显示window.mainloop() 测试效果 Entry窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定输入框控件entry并放置控件e1 = tk.Entry(window, show=&apos;*&apos;, font=(&apos;Arial&apos;, 14)) # 显示成密文形式e2 = tk.Entry(window, show=None, font=(&apos;Arial&apos;, 14)) # 显示成明文形式e1.pack()e2.pack() # 第5步，主窗口循环显示window.mainloop() 测试效果 Text窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定输入框控件entry框并放置e = tk.Entry(window, show = None)#显示成明文形式e.pack() # 第5步，定义两个触发事件时的函数insert_point和insert_end（注意：因为Python的执行顺序是从上往下，所以函数一定要放在按钮的上面）def insert_point(): # 在鼠标焦点处插入输入内容 var = e.get() t.insert(&apos;insert&apos;, var)def insert_end(): # 在文本框内容最后接着插入输入内容 var = e.get() t.insert(&apos;end&apos;, var) # 第6步，创建并放置两个按钮分别触发两种情况b1 = tk.Button(window, text=&apos;insert point&apos;, width=10, height=2, command=insert_point)b1.pack()b2 = tk.Button(window, text=&apos;insert end&apos;, width=10, height=2, command=insert_end)b2.pack() # 第7步，创建并放置一个多行文本框text用以显示，指定height=3为文本框是三个字符高度t = tk.Text(window, height=3)t.pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 Listbox窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置var1 = tk.StringVar() # 创建变量，用var1用来接收鼠标点击具体选项的内容l = tk.Label(window, bg=&apos;green&apos;, fg=&apos;yellow&apos;,font=(&apos;Arial&apos;, 12), width=10, textvariable=var1)l.pack() # 第6步，创建一个方法用于按钮的点击事件def print_selection(): value = lb.get(lb.curselection()) # 获取当前选中的文本 var1.set(value) # 为label设置值 # 第5步，创建一个按钮并放置，点击按钮调用print_selection函数b1 = tk.Button(window, text=&apos;print selection&apos;, width=15, height=2, command=print_selection)b1.pack() # 第7步，创建Listbox并为其添加内容var2 = tk.StringVar()var2.set((1,2,3,4)) # 为变量var2设置值# 创建Listboxlb = tk.Listbox(window, listvariable=var2) #将var2的值赋给Listbox# 创建一个list并将值循环添加到Listbox控件中list_items = [11,22,33,44]for item in list_items: lb.insert(&apos;end&apos;, item) # 从最后一个位置开始加入值lb.insert(1, &apos;first&apos;) # 在第一个位置加入&apos;first&apos;字符lb.insert(2, &apos;second&apos;) # 在第二个位置加入&apos;second&apos;字符lb.delete(2) # 删除第二个位置的字符lb.pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 Radiobutton窗口控件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置var = tk.StringVar() # 定义一个var用来将radiobutton的值和Label的值联系在一起.l = tk.Label(window, bg=&apos;yellow&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义选项触发函数功能def print_selection(): l.config(text=&apos;you have selected &apos; + var.get()) # 第5步，创建三个radiobutton选项，其中variable=var, value=&apos;A&apos;的意思就是，当我们鼠标选中了其中一个选项，把value的值A放到变量var中，然后赋值给variabler1 = tk.Radiobutton(window, text=&apos;Option A&apos;, variable=var, value=&apos;A&apos;, command=print_selection)r1.pack()r2 = tk.Radiobutton(window, text=&apos;Option B&apos;, variable=var, value=&apos;B&apos;, command=print_selection)r2.pack()r3 = tk.Radiobutton(window, text=&apos;Option C&apos;, variable=var, value=&apos;C&apos;, command=print_selection)r3.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Checkbutton窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置l = tk.Label(window, bg=&apos;yellow&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义触发函数功能def print_selection(): if (var1.get() == 1) &amp; (var2.get() == 0): # 如果选中第一个选项，未选中第二个选项 l.config(text=&apos;I love only Python &apos;) elif (var1.get() == 0) &amp; (var2.get() == 1): # 如果选中第二个选项，未选中第一个选项 l.config(text=&apos;I love only C++&apos;) elif (var1.get() == 0) &amp; (var2.get() == 0): # 如果两个选项都未选中 l.config(text=&apos;I do not love either&apos;) else: l.config(text=&apos;I love both&apos;) # 如果两个选项都选中 # 第5步，定义两个Checkbutton选项并放置var1 = tk.IntVar() # 定义var1和var2整型变量用来存放选择行为返回值var2 = tk.IntVar()c1 = tk.Checkbutton(window, text=&apos;Python&apos;,variable=var1, onvalue=1, offvalue=0, command=print_selection) # 传值原理类似于radiobutton部件c1.pack()c2 = tk.Checkbutton(window, text=&apos;C++&apos;,variable=var2, onvalue=1, offvalue=0, command=print_selection)c2.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Scale窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置l = tk.Label(window, bg=&apos;green&apos;, fg=&apos;white&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义一个触发函数功能def print_selection(v): l.config(text=&apos;you have selected &apos; + v)# 第5步，创建一个尺度滑条，长度200字符，从0开始10结束，以2为刻度，精度为0.01，触发调用print_selection函数s = tk.Scale(window, label=&apos;try me&apos;, from_=0, to=10, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=2, resolution=0.01, command=print_selection)s.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Canvas窗口部件示例代码 from PIL import Imagefrom PIL import ImageTkimport tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，在图形界面上创建 500 * 200 大小的画布并放置各种元素canvas = tk.Canvas(window, bg=&apos;green&apos;, height=200, width=500)# 说明图片位置，并导入图片到画布上image_file = Image.open(&quot;/home/ltb/timg.jpeg&quot;).resize((500, 300))image_file = ImageTk.PhotoImage(image_file)# image_file = tk.PhotoImage(file=&apos;/home/ltb/timg.gif&apos;) # 图片位置（相对路径，与.py文件同一文件夹下，也可以用绝对路径，需要给定图片具体绝对路径）image = canvas.create_image(250, 0, anchor=&apos;n&apos;, image=image_file) # 图片锚定点（n图片顶端的中间点位置）放在画布（250,0）坐标处# 定义多边形参数，然后在画布上画出指定图形x0, y0, x1, y1 = 100, 100, 150, 150line = canvas.create_line(x0 - 50, y0 - 50, x1 - 50, y1 - 50) # 画直线oval = canvas.create_oval(x0 + 120, y0 + 50, x1 + 120, y1 + 50, fill=&apos;white&apos;) # 画圆 用黄色填充arc = canvas.create_arc(x0, y0 + 50, x1, y1 + 50, start=0, extent=180) # 画扇形 从0度打开收到180度结束rect = canvas.create_rectangle(330, 30, 330 + 20, 30 + 20) # 画矩形正方形canvas.pack()# 第6步，触发函数，用来一定指定图形def moveit(): canvas.move(rect, 2, 2) # 移动正方形rect（也可以改成其他图形名字用以移动一起图形、元素），按每次（x=2, y=2）步长进行移动# 第5步，定义一个按钮用来移动指定图形的在画布上的位置b = tk.Button(window, text=&apos;move item&apos;, command=moveit).pack()# 第7步，主窗口循环显示window.mainloop()# 在一个类中创建Canvas需要把要显示再画布上的图片声明为全局变量，不然画布无法显示图片。 图像锚定点位置参数图测试效果 Menu窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，在图形界面上创建一个标签用以显示内容并放置l = tk.Label(window, text=&apos; &apos;, bg=&apos;green&apos;)l.pack()# 第10步，定义一个函数功能，用来代表菜单选项的功能，这里为了操作简单，定义的功能比较简单counter = 0def do_job(): global counter l.config(text=&apos;do &apos; + str(counter)) counter += 1# 第5步，创建一个菜单栏，这里我们可以把他理解成一个容器，在窗口的上方menubar = tk.Menu(window)# 第6步，创建一个File菜单项（默认不下拉，下拉内容包括New，Open，Save，Exit功能项）filemenu = tk.Menu(menubar, tearoff=0)# 将上面定义的空菜单命名为File，放在菜单栏中，就是装入那个容器中menubar.add_cascade(label=&apos;File&apos;, menu=filemenu)# 在File中加入New、Open、Save等小菜单，即我们平时看到的下拉菜单，每一个小菜单对应命令操作。filemenu.add_command(label=&apos;New&apos;, command=do_job)filemenu.add_command(label=&apos;Open&apos;, command=do_job)filemenu.add_command(label=&apos;Save&apos;, command=do_job)filemenu.add_separator() # 添加一条分隔线filemenu.add_command(label=&apos;Exit&apos;, command=window.quit) # 用tkinter里面自带的quit()函数# 第7步，创建一个Edit菜单项（默认不下拉，下拉内容包括Cut，Copy，Paste功能项）editmenu = tk.Menu(menubar, tearoff=0)# 将上面定义的空菜单命名为 Edit，放在菜单栏中，就是装入那个容器中menubar.add_cascade(label=&apos;Edit&apos;, menu=editmenu)# 同样的在 Edit 中加入Cut、Copy、Paste等小命令功能单元，如果点击这些单元, 就会触发do_job的功能editmenu.add_command(label=&apos;Cut&apos;, command=do_job)editmenu.add_command(label=&apos;Copy&apos;, command=do_job)editmenu.add_command(label=&apos;Paste&apos;, command=do_job)# 第8步，创建第二级菜单，即菜单项里面的菜单submenu = tk.Menu(filemenu) # 和上面定义菜单一样，不过此处实在File上创建一个空的菜单filemenu.add_cascade(label=&apos;Import&apos;, menu=submenu, underline=0) # 给放入的菜单submenu命名为Import# 第9步，创建第三级菜单命令，即菜单项里面的菜单项里面的菜单命令（有点拗口，笑~~~）submenu.add_command(label=&apos;Submenu_1&apos;, command=do_job) # 这里和上面创建原理也一样，在Import菜单项中加入一个小菜单命令Submenu_1# 第11步，创建菜单栏完成后，配置让菜单栏menubar显示出来window.config(menu=menubar)# 第12步，主窗口循环显示window.mainloop() 测试效果 Frame窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签用以显示内容并放置tk.Label(window, text=&apos;on the window&apos;, bg=&apos;red&apos;, font=(&apos;Arial&apos;, 16)).pack() # 和前面部件分开创建和放置不同，其实可以创建和放置一步完成 # 第5步，创建一个主frame，长在主window窗口上frame = tk.Frame(window)frame.pack() # 第6步，创建第二层框架frame，长在主框架frame上面frame_l = tk.Frame(frame)# 第二层frame，左frame，长在主frame上frame_r = tk.Frame(frame)# 第二层frame，右frame，长在主frame上frame_l.pack(side=&apos;left&apos;)frame_r.pack(side=&apos;right&apos;) # 第7步，创建三组标签，为第二层frame上面的内容，分为左区域和右区域，用不同颜色标识tk.Label(frame_l, text=&apos;on the frame_l1&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_l, text=&apos;on the frame_l2&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_l, text=&apos;on the frame_l3&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r1&apos;, bg=&apos;yellow&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r2&apos;, bg=&apos;yellow&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r3&apos;, bg=&apos;yellow&apos;).pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 messageBox窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入import tkinter.messagebox # 要使用messagebox先要导入模块 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第5步，定义触发函数功能def hit_me(): tkinter.messagebox.showinfo(title=&apos;Hi&apos;, message=&apos;你好！&apos;) # 提示信息对话窗 # tkinter.messagebox.showwarning(title=&apos;Hi&apos;, message=&apos;有警告！&apos;) # 提出警告对话窗 # tkinter.messagebox.showerror(title=&apos;Hi&apos;, message=&apos;出错了！&apos;) # 提出错误对话窗 # print(tkinter.messagebox.askquestion(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # 询问选择对话窗return &apos;yes&apos;, &apos;no&apos; # print(tkinter.messagebox.askyesno(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # return &apos;True&apos;, &apos;False&apos; # print(tkinter.messagebox.askokcancel(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # return &apos;True&apos;, &apos;False&apos; # 第4步，在图形界面上创建一个标签用以显示内容并放置tk.Button(window, text=&apos;hit me&apos;, bg=&apos;green&apos;, font=(&apos;Arial&apos;, 14), command=hit_me).pack() # 第6步，主窗口循环显示window.mainloop() 测试效果 窗口部件三种放置方式 pack/grid/placepack按上下左右的方式排列 示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，pack 放置方法tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;top&apos;) # 上tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;bottom&apos;) # 下tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;left&apos;) # 左tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;right&apos;) # 右# 第5步，主窗口循环显示window.mainloop() 测试效果 grid所有的内容会被放在这些规律的方格中 示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，grid 放置方法for i in range(3): for j in range(3): tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10, ipadx=10, ipady=10)# 第5步，主窗口循环显示window.mainloop() 测试效果 place给精确的坐标来定位 示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，place 放置方法（精准的放置到指定坐标点的位置上）tk.Label(window, text=&apos;Pl&apos;, font=(&apos;Arial&apos;, 20), ).place(x=50, y=100, anchor=&apos;nw&apos;) # 第5步，主窗口循环显示window.mainloop() 测试效果 Tkinter布局之pack我们使用pack函数的时候，默认先使用的放在上面，然后依次向下排，它会给我们的部件一个自认为合适的位置和大小，这是默认方式。 side 按钮停靠的位置left：左top：上right：右bottom：下 fill 填充x：水平方向填充y：竖直方向填充both：水平和竖直方向填充none：不填充 expand 扩展yes：扩展整个空白区no：不扩展 部件消除示例代码 # 销毁上一个布局的frame及其部件# 先销毁frame下的部件，再销毁framefor widget in self.last_frame.winfo_children(): widget.destroy()self.last_frame.destroy() 多线程按钮部件示例代码 # 打开摄像头button_open_camera = tk.Button(self.frame_3, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading)button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;)# 关闭摄像头button_close_camera = tk.Button(self.frame_3, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera)button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;)# 线程函数def camera_threading(self): self.thread = threading.Thread(target=self.open_camera) self.thread.setDaemon(True) self.thread.start() # 打开摄像头函数，被线程函数调用def open_camera(self): try: cap = cv2.VideoCapture(0) self.thread_flag = True while(self.thread_flag): ret, frame = cap.read() cv2.imshow(&quot;video&quot;, frame) cv2.imwrite(self.temporary_path, frame) if ret != True: break c = cv2.waitKey(60) if c == 27: break cv2.destroyAllWindows() cap.release() except: messagebox.showerror(title=&quot;读取视频出错&quot;, message=&quot;读取出错或未检测到usb摄像头&quot;) # 关闭摄像头函数，用全局变量控制def close_camera(self): self.thread_flag = False os._exit(0) 第一个Tkinter程序from PIL import Imagefrom PIL import ImageTkimport tkinter as tkfrom tkinter import filedialog, messageboximport threadingimport cv2import osimport shutilfrom datetime import datetimeclass AppUI(): def __init__(self): # 全局变量 self.first = True self.last_frame = None self.thread_flag = False self.temporary_path = &quot;/mnt/tkinter_pj1/temporary_picture.jpg&quot; self.database = &quot;/mnt/tkinter_pj1/Images/all&quot; # 存线程实例 self.thread_obj = [] # 创建窗口 self.window = tk.Tk() self.window.title(&quot;手术器械自动识别系统&quot;) self.window.geometry(&quot;500x200&quot;) # 参数 self.main_menu() self.main_layout() self.window.mainloop() # 主菜单 def main_menu(self): self.menu_bar = tk.Menu(self.window) self.start_menu = tk.Menu(self.menu_bar, tearoff=0) self.menu_bar.add_cascade(label=&quot;开始&quot;, menu=self.start_menu) self.start_menu.add_command(label=&quot;首页&quot;, command=self.main_layout) self.start_menu.add_command(label=&quot;单张图像预测&quot;, command=self.layout_2) self.start_menu.add_command(label=&quot;实时图像检测&quot;, command=self.layout_3) self.start_menu.add_command(label=&quot;图像采集&quot;, command=self.layout_4) self.window.config(menu=self.menu_bar) def main_layout(self): if self.first == False: # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;500x200&quot;) self.first = False self.main_frame = tk.Frame(self.window) self.main_frame.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.main_frame label_main_frame_title = tk.Label(self.main_frame, text=&apos;欢迎来到手术器械自动识别系统&apos;, font=(&apos;Arial&apos;, 17), height=3) label_main_frame_title.pack(side=&quot;top&quot;, fill=&quot;both&quot;) # 三个button button_single_predict = tk.Button(self.main_frame, text=&apos;单张图像识别&apos;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_2) button_single_predict.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) button_realtime_predict = tk.Button(self.main_frame, text=&quot;实时图像识别&quot;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_3) button_realtime_predict.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) button_catch_picture = tk.Button(self.main_frame, text=&quot;图像采集&quot;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_4) button_catch_picture.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) def layout_2(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) # 创建frame_2 self.frame_2 = tk.Frame(self.window) self.frame_2.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_2 label_frame_2_title = tk.Label(self.frame_2, text=&apos;单张图像识别&apos;, font=(&apos;Arial&apos;, 15), height=3, width=30) label_frame_2_title.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_2, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 选择路径 button_picture_path = tk.Button(self.frame_2, text=&quot;选择路径&quot;, height=3, command=self.select_picture_path) button_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 路径 label_picture_path = tk.Label(self.frame_2, text=&quot;图片路径&quot;, height=3) label_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_picture_path = tk.Entry(self.frame_2, show=None) self.entry_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_predict_result = tk.Entry(self.frame_2, show=None) self.entry_predict_result.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) button_predict_picture = tk.Button(self.frame_2, text=&quot;图片预测&quot;, height=3, command=self.predict_picture) button_predict_picture.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def layout_3(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) self.frame_3 = tk.Frame(self.window) self.frame_3.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_3 label_frame_3_title = tk.Label(self.frame_3, text=&apos;实时图像识别&apos;, font=(&apos;Arial&apos;, 15), height=3, width=30) label_frame_3_title.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_3, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 打开摄像头 button_open_camera = tk.Button(self.frame_3, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading) button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 关闭摄像头 button_close_camera = tk.Button(self.frame_3, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera) button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_realtime_result = tk.Entry(self.frame_3, show=None) self.entry_realtime_result.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) button_realtime_prediction = tk.Button(self.frame_3, text=&quot;实时检测&quot;, height=3, command=self.realtime_prediction) button_realtime_prediction.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def layout_4(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) self.frame_4 = tk.Frame(self.window) self.frame_4.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_4 label = tk.Label(self.frame_4, text=&apos;图像采集&apos;, font=(&apos;Arial&apos;, 15), width=30, height=3) label.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_4, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 打开摄像头 button_open_camera = tk.Button(self.frame_4, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading) button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 关闭摄像头 button_close_camera = tk.Button(self.frame_4, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera) button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) button_picture_capture = tk.Button(self.frame_4, text=&quot;图片采集&quot;, height=3, command=self.picture_capture) button_picture_capture.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) self.entry_input_label = tk.Entry(self.frame_4, show=None, text=&quot;&quot;) self.entry_input_label.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) label_input_label = tk.Label(self.frame_4, text=&quot;输入类别&quot;) label_input_label.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def select_picture_path(self): self.pic_path = filedialog.askopenfilename() self.entry_picture_path.delete(0, &quot;end&quot;) self.entry_picture_path.insert(0, self.pic_path) self.show_picture(self.pic_path) def show_picture(self, path): try: self.picture = Image.open(path).resize((640, 480)) self.picture = ImageTk.PhotoImage(self.picture) self.canvas.create_image(0, 0, anchor=&quot;nw&quot;, image=self.picture) except: messagebox.showerror(title=&quot;路径错误&quot;, message=&quot;路径输入错误或选中文件不是图片&quot;) def open_camera(self): try: cap = cv2.VideoCapture(0) self.thread_flag = True while(self.thread_flag): ret, frame = cap.read() cv2.imshow(&quot;video&quot;, frame) cv2.imwrite(self.temporary_path, frame) if ret != True: break c = cv2.waitKey(60) if c == 27: break cv2.destroyAllWindows() cap.release() except: messagebox.showerror(title=&quot;读取视频出错&quot;, message=&quot;读取出错或未检测到usb摄像头&quot;) def close_camera(self): self.thread_flag = False os._exit(0) def realtime_prediction(self): self.show_picture(self.temporary_path) pass def predict_picture(self): self.entry_predict_result.delete(0, &quot;end&quot;) self.entry_predict_result.insert(0, 0) pass def picture_capture(self): content = self.entry_input_label.get() if len(content) &gt; 0: time_stamp = &apos;&#123;:%Y-%m-%d-%H-%M-%S&#125;&apos;.format(datetime.now()) sub_class_folder = os.path.join(self.database, str(self.entry_input_label.get())) if not os.path.exists(sub_class_folder): os.mkdir(sub_class_folder) image_store_path = os.path.join(sub_class_folder, &apos;&#123;&#125;_&#123;&#125;.jpg&apos;.format(str(self.entry_input_label.get()), time_stamp)) if self.thread_flag: self.show_picture(self.temporary_path) shutil.copy(self.temporary_path, image_store_path) messagebox.showinfo(title=&quot;成功&quot;, message=&quot;成功保存图片&quot;) else: messagebox.showwarning(title=&quot;警告&quot;, message=&quot;未打开摄像头&quot;) else: messagebox.showwarning(title=&quot;警告&quot;, message=&quot;请输入类别号&quot;) def camera_threading(self): self.thread = threading.Thread(target=self.open_camera) self.thread.setDaemon(True) self.thread.start()if __name__ == &quot;__main__&quot;: app = AppUI()pyinstaller 打包 # 安装pyinstallsudo pip3 install pyinstaller# 切换到需要打包的目录，执行pyinstaller -F -W GUI.py# -F: 只生成耦合可执行的文件# -W: 表示窗口，无控制台# 生成的可执行文件就在目录dist中# 修改图标-i icon.ico 或者 --icon.ico# 图片放在需要打包的文件同目录中 参考本文参考以下网站、博客http://www.cnblogs.com/shwee/p/9427975.htmlhttps://blog.csdn.net/yingshukun/article/details/78838395http://www.cnblogs.com/kongzhagen/p/6144588.html","path":"2019/08/05/Tkinter使用指南/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"tkinter","slug":"tkinter","permalink":"https://litianbo243.github.io/tags/tkinter/"}]},{"title":"pytorch常用函数","text":"Tensor基本操作Tensor的基本数据类型torch.Tensor是一种包含单一数据类型元素的多维矩阵。Torch定义了七种CPU tensor类型和八种GPU tensor类型： Data type CPU tensor GPU tensor 32-bit floating point torch.FloatTensor torch.cuda.FloatTensor 64-bit floating point torch.DoubleTensor torch.cuda.DoubleTensor 16-bit floating point N/A torch.cuda.HalfTensor 8-bit integer (unsigned) torch.ByteTensor torch.cuda.ByteTensor 8-bit integer (signed) torch.CharTensor torch.cuda.CharTensor 16-bit integer (signed) torch.ShortTensor torch.cuda.ShortTensor 32-bit integer (signed) torch.IntTensor torch.cuda.IntTensor 64-bit integer (signed) torch.LongTensor torch.cuda.LongTensor import torchimport numpy as npt = torch.FloatTensor([[1, 2, 3], [4, 5, 6]])print(t.dtype)print(t) Tensor数据类型的转化import torchimport numpy as np# 默认数据类型为float32t = torch.Tensor(3, 5)print(t.dtype, &quot;\\n&quot;)# t.double()将该tensor投射为double类型double_t = t.double()print(double_t.dtype)# t.float()将该tensor投射为float类型float_t = t.float()print(float_t.dtype)# t.half()将tensor投射为半精度浮点类型half_t = t.half()print(half_t.dtype)# t.long() 将tensor投射为long类型long_t = t.long()print(long_t.dtype)# t.int()将该tensor投射为int类型int_t = t.int()print(int_t.dtype)# t.short()将该tensor投射为short类型short_t = t.short()print(short_t.dtype)# t.char()将该tensor投射为char类型char_t = t.char()print(char_t.dtype)# t.byte()将该tensor投射为byte类型byte_t = t.byte()print(byte_t.dtype)# t.cuda()将tensor投射为gputensorgpu_t = t.cuda()print(gpu_t.dtype) Tensor与numpy的相互转换import torchimport numpy as npa = np.array([1, 2, 3])t = torch.from_numpy(a)print(t)t[0] = -1a = t.numpy()print(a) Tensor拼接操作import torchimport numpy as npx = torch.randn(2, 3)print(x)x0 = torch.cat((x, x, x), 0)print(x0)x1 = torch.cat((x, x, x), 1)print(x1) Tensor进行分块import torchimport numpy as npx = torch.randn(2, 3)print(x)x = torch.chunk(x, 2, 0)print(x) Tensor进行挤压import torchimport numpy as npx = torch.zeros(2, 1, 2, 1, 2)print(x.size())y = torch.squeeze(x)print(y.size())y = torch.squeeze(x, 0)print(y.size())y = torch.squeeze(x, 1)print(y.size()) Tensor进行扩增import torchimport numpy as npx = torch.zeros(2, 2, 2)print(x.size())y = torch.unsqueeze(x, 0)print(y.size())y = torch.unsqueeze(x, 1)print(y.size()) Tensor进行转置import torchimport numpy as npx = torch.randn(2, 3)print(x)x = torch.transpose(x, 0, 1)print(x) Tensor进行view操作相当于numpy中resize（）的功能，但是用法可能不太一样。 把原先tensor中的数据按照行优先的顺序排成一个一维的数据（这里应该是因为要求地址是连续存储的），然后按照参数组合成其他维度的tensor。比如说是不管你原先的数据是[[[1,2,3],[4,5,6]]]还是[1,2,3,4,5,6]，因为它们排成一维向量都是6个元素，所以只要view后面的参数一致，得到的结果都是一样的。比如， a=torch.Tensor([[[1,2,3],[4,5,6]]])b=torch.Tensor([1,2,3,4,5,6])print(a.view(1,6))print(b.view(1,6)) 得到的结果都是tensor([[1., 2., 3., 4., 5., 6.]]) a=torch.Tensor([[[1,2,3],[4,5,6]]])print(a.view(3,2))&apos;&apos;&apos;tensor([[1., 2.], [3., 4.], [5., 6.]])&apos;&apos;&apos; 随机种子import torchimport numpy as nptorch.manual_seed(0)x = torch.randn(2, 3)print(x)torch.manual_seed(0)x = torch.randn(2, 3)print(x) 序列化当提到保存和加载模型时，有三个核心功能需要熟悉：1.torch.save：将序列化的对象保存到disk。这个函数使用Python的pickle实用程序进行序列化。使用这个函数可以保存各种对象的模型、张量和字典。2.torch.load：使用pickle unpickle工具将pickle的对象文件反序列化为内存。3.torch.nn.Module.load_state_dict:使用反序列化状态字典加载model’s参数字典。 什么是state_dictimport torchimport torch.nn as nnimport torch.nn.functional as F# Define modelclass TheModelClass(nn.Module): def __init__(self): super(TheModelClass, self).__init__() self.conv1 = nn.Conv2d(3, 6, 5) self.pool = nn.MaxPool2d(2, 2) self.conv2 = nn.Conv2d(6, 16, 5) self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def farward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16 * 5 * 5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x# Initialize modelmodel = TheModelClass()# Initialize optimizeroptimizer = torch.optim.SGD(model.parameters(), lr=1e-4, momentum=0.9)print(&quot;Model&apos;s state_dict:&quot;)# Print model&apos;s state_dictfor param_tensor in model.state_dict(): print(param_tensor, &quot;\\t&quot;, model.state_dict()[param_tensor].size())print(&quot;optimizer&apos;s state_dict:&quot;)# Print optimizer&apos;s state_dictfor var_name in optimizer.state_dict(): print(var_name, &quot;\\t&quot;, optimizer.state_dict()[var_name]) 保存读取模型# 只保存模型的学习参数torch.save(model.state_dict(), PATH)# 读取模型的可学习参数model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH))model.eval() # 保存整个模型torch.save(the_model, PATH)# 读取整个模型the_model = torch.load(PATH)model.eval() # 序列化字典# savetorch.save(&#123; &apos;epoch&apos;: epoch, &apos;model_state_dict&apos;: model.state_dict(), &apos;optimizer_state_dict&apos;: optimizer.state_dict(), &apos;loss&apos;: loss, ... &#125;, PATH) # loadmodel = TheModelClass(*args, **kwargs)optimizer = TheOptimizerClass(*args, **kwargs)checkpoint = torch.load(PATH)model.load_state_dict(checkpoint[&apos;model_state_dict&apos;])optimizer.load_state_dict(checkpoint[&apos;optimizer_state_dict&apos;])epoch = checkpoint[&apos;epoch&apos;]loss = checkpoint[&apos;loss&apos;]model.eval()# - or -model.train() 数学操作夹紧操作import torchimport numpy as npa = torch.randn(4)print(a)a = torch.clamp(a, min=-0.5, max=0.5)print(a) 沿维度计算和import torchimport numpy as npa = torch.randn(10)print(a)a = torch.cumsum(a, dim=0)print(a)print(a[-1]) 计算元素均值import torchimport numpy as npa = torch.randn(2, 2)print(a)b = torch.mean(a)print(b)b = torch.mean(a, 1)print(b) 计算元素标准差import torchimport numpy as npa = torch.randn(2, 2)print(a)b = torch.std(a)print(b)b = torch.std(a, dim=1)print(b) 计算所有元素和import torchimport numpy as npa = torch.randn(2, 2)print(a)b = torch.sum(a)print(b)b = torch.sum(a, dim=0)print(b) torch.nn容器torch.nn.Module是所有网络的基类。你的模型也应该继承这个类。Modules也可以包含其它Modules,允许使用树结构嵌入他们。你可以将子模块赋值给模型属性。 import torch.nn as nnimport torch.nn.functional as Fclass Model(nn.Module): def __init__(self): super(Model, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5) # submodule: Conv2d self.conv2 = nn.Conv2d(20, 20, 5) def forward(self, x): x = F.relu(self.conv1(x)) return F.relu(self.conv2(x)) 时序容器# Example of using Sequentialmodel = nn.Sequential( nn.Conv2d(1,20,5), nn.ReLU(), nn.Conv2d(20,64,5), nn.ReLU() ) # Example of using Sequential with OrderedDictmodel = nn.Sequential(OrderedDict([ (&apos;conv1&apos;, nn.Conv2d(1,20,5)), (&apos;relu1&apos;, nn.ReLU()), (&apos;conv2&apos;, nn.Conv2d(20,64,5)), (&apos;relu2&apos;, nn.ReLU()) ])) 卷积层Conv2dclass torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) 参数kernel_size，stride,padding，dilation也可以是一个int的数据，此时卷积height和width值相同;也可以是一个tuple数组，tuple的第一维度表示height的数值，tuple的第二维度表示width的数值。 in_channels(int) – 输入信号的通道 out_channels(int) – 卷积产生的通道 kerner_size(int or tuple) - 卷积核的尺寸 stride(int or tuple, optional) - 卷积步长 padding(int or tuple, optional) - 输入的每一条边补充0的层数 dilation(int or tuple, optional) – 卷积核元素之间的间距 groups(int, optional) – 从输入通道到输出通道的阻塞连接数 bias(bool, optional) - 如果bias=True，添加偏置import torch.nn as nnimport torchm = nn.Conv2d(16, 33, 3, stride=2)m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))input = torch.Tensor(torch.randn(20, 16, 50, 100))output = m(input)print(output) # 空洞卷积import torch.nn as nnimport torchm = nn.Conv2d(16, 33, kernel_size=3, stride=1, padding=2, dilation=2)input = torch.Tensor(torch.randn(20, 16, 100, 100))print(input.size())output = m(input)print(output.size()) ConvTranspose2dclass torch.nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True) 注意，这上面的stride、padding是争对于与原始卷积上的stride和padding2维的转置卷积操作（transposed convolution operator，注意改视作操作可视作解卷积操作，但并不是真正的解卷积操作） 该模块可以看作是Conv2d相对于其输入的梯度，有时（但不正确地）被称为解卷积操作。 由于内核的大小，输入的最后的一些列的数据可能会丢失。因为输入和输出是不是完全的互相关。因此，用户可以进行适当的填充（padding操作）。 in_channels(int) – 输入信号的通道数 out_channels(int) – 卷积产生的通道数 kerner_size(int or tuple) - 卷积核的大小 stride(int or tuple,optional) - 卷积步长 padding(int or tuple, optional) - 输入的每一条边补充0的层数 output_padding(int or tuple, optional) - 输出的每一条边补充0的层数 dilation(int or tuple, optional) – 卷积核元素之间的间距 groups(int, optional) – 从输入通道到输出通道的阻塞连接数 bias(bool, optional) - 如果bias=True，添加偏置import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 16, 64, 64))print(input.size())m = nn.ConvTranspose2d(16, 33, 3, stride=2, padding=1, output_padding=1)output = m(input)print(output.size()) 池化层Maxpool2dclass torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False) kernel_size(int or tuple) - max pooling的窗口大小 stride(int or tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size padding(int or tuple, optional) - 输入的每一条边补充0的层数 dilation(int or tuple, optional) – 一个控制窗口中元素步幅的参数 return_indices - 如果等于True，会返回输出最大值的序号，对于上采样操作会有帮助 ceil_mode - 如果等于True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 16, 64, 64))print(input.size())m = nn.MaxPool2d(3, stride=2)output = m(input)print(output.size())input = torch.Tensor(torch.randn(1, 3, 4, 4))print(input)m = nn.MaxPool2d(2, stride=2, return_indices=True)output, indices = m(input)print(indices) MaxUnpool2dclass torch.nn.MaxUnpool2d(kernel_size, stride=None, padding=0) Maxpool2d的逆过程，不过并不是完全的逆过程，因为在maxpool2d的过程中，一些最大值的已经丢失。 MaxUnpool2d的输入是MaxPool2d的输出，包括最大值的索引，并计算所有maxpool2d过程中非最大值被设置为零的部分的反向。 kernel_size(int or tuple) - max pooling的窗口大小 stride(int or tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size padding(int or tuple, optional) - 输入的每一条边补充0的层数import torch.nn as nnimport torchpool = nn.MaxPool2d(2, stride=2, return_indices=True)unpool = nn.MaxUnpool2d(2, stride=2)input = torch.Tensor([[[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]]])output, indices = pool(input)result = unpool(output, indices)print(result) AvgPool2dclass torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True) kernel_size(int or tuple) - 池化窗口大小 stride(int or tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size padding(int or tuple, optional) - 输入的每一条边补充0的层数 dilation(int or tuple, optional) – 一个控制窗口中元素步幅的参数 ceil_mode - 如果等于True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作 count_include_pad - 如果等于True，计算平均池化时，将包括padding填充的0import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 9, 9))m = nn.AvgPool2d(3, stride=2)output = m(input)print(output.size()) AdaptiveMaxPool2dclass torch.nn.AdaptiveMaxPool2d(output_size, return_indices=False) 对输入信号，提供2维的自适应最大池化操作 对于任何输入大小的输入，可以将输出尺寸指定为H*W，但是输入和输出特征的数目不会变化。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 9, 9))m = nn.AdaptiveMaxPool2d((3, 3))output = m(input)print(output.size()) 非线性激活函数ReLUclass torch.nn.ReLU(inplace=False) 对输入运用修正线性单元函数{ReLU}(x)= max(0, x) import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.ReLU(inplace=True)output = m(input)print(input)print(output) ELUclass torch.nn.ELU(alpha=1.0, inplace=False) 对输入的每一个元素运用函数f(x) = max(0,x) + min(0, alpha * (e^x - 1)) import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.ELU(inplace=False)output = m(input)print(output) PReLUclass torch.nn.PReLU(num_parameters=1, init=0.25)对输入的每一个元素运用函数PReLU(x) = max(0,x) + a * min(0,x)a是一个可学习参数。当没有声明时，nn.PReLU()在所有的输入中只有一个参数a；如果是nn.PReLU(nChannels)，a将应用到每个输入。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.PReLU()output = m(input)print(output) LeakyReLUclass torch.nn.LeakyReLU(negative_slope=0.01, inplace=False) 对输入的每一个元素运用f(x) = max(0, x) + {negative_slope} * min(0, x) import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.LeakyReLU()output = m(input)print(output) Thresholdclass torch.nn.Threshold(threshold, value, inplace=False) y=x,if x&gt;=threshold y=value,if x&lt;threshold import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Threshold(0.1, 20)output = m(input)print(output) Sigmoidclass torch.nn.Sigmoid import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Sigmoid()output = m(input)print(output) Tanhclass torch.nn.Tanh import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Tanh()output = m(input)print(output) Softmaxclass torch.nn.Softmax对n维输入张量运用Softmax函数，将张量的每个元素缩放到（0,1）区间且和为1。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 7))print(input)m = nn.Softmax(dim=1)output = m(input)print(output) 标准化层BatchNorm2dclass torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True) 对小批量(mini-batch)3d数据组成的4d输入进行批标准化(Batch Normalization)操作在每一个小批量（mini-batch）数据中，计算输入各个维度的均值和标准差。gamma与beta是可学习的大小为C的参数向量（C为输入大小）在训练时，该层计算每次输入的均值与方差，并进行移动平均。移动平均默认的动量值为0.1。在验证时，训练求得的均值/方差将用于标准化验证数据。 num_features： 来自期望输入的特征数，该期望输入的大小为’batch_size x num_features x height x width’ eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。 momentum： 动态均值和动态方差所使用的动量。默认为0.1。 affine： 一个布尔值，当设为true，给该层添加可学习的仿射变换参数。import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 100, 3, 3))print(input)m = nn.BatchNorm2d(100)output = m(input)print(output) 线性层Linearclass torch.nn.Linear(in_features, out_features, bias=True)对输入数据做线性变换：y=Ax+b in_features - 每个输入样本的大小 out_features - 每个输出样本的大小 bias - 若设置为False，这层不会学习偏置。默认值：Trueimport torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 20))print(input.size())m = nn.Linear(20, 30)output = m(input)print(output.size()) Dropout层Dropoutclass torch.nn.Dropout(p=0.5, inplace=False) 随机将输入张量中部分元素设置为0。对于每次前向调用，被置0的元素都是随机的。 p - 将元素置0的概率。默认值：0.5 in-place - 若设置为True，会在原地执行操作。默认值：Falseimport torch.nn as nnimport torchinput = torch.Tensor(torch.randn(3, 6))print(input)m = nn.Dropout(p=0.5)output = m(input)print(output) Droupout2dclass torch.nn.Dropout2d(p=0.5, inplace=False) 随机将输入张量中整个通道设置为0。对于每次前向调用，被置0的通道都是随机的。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Dropout2d(p=0.5)output = m(input)print(output) 损失函数基本用法： criterion = LossCriterion() #构造函数有自己的参数loss = criterion(x, y) #调用标准时也有参数 计算出来的结果已经对mini-batch取了平均。 MSELossclass torch.nn.MSELoss(size_average=True)创建一个衡量输入x(模型预测输出)和目标y之间均方误差标准。 import torch.nn as nnimport torchinput1 = torch.Tensor(torch.randn(1, 8))print(input1)input2 = torch.Tensor(torch.rand(1, 8))print(input2)criterion = nn.MSELoss()loss = criterion(input1, input2)print(loss) CrossEntropyLossclass torch.nn.CrossEntropyLoss(weight=None, size_average=True) 此标准将LogSoftMax和NLLLoss集成到一个类中。不需要再使用softmax。 weight(tensor): 1-D tensor，n个元素，分别代表n类的权重，如果你的训练样本很不均衡的话，是非常有用的。默认值为None。 input : 包含每个类的得分，３-D tensor,shape为 batchn样例数 target: 大小为 n 的 ２-D tensor，包含类别的索引(0到 n-1)，long型。 import torch.nn as nnimport torch# batchsize=3, 二分类, 8个样例input = torch.Tensor(torch.randn(2, 3, 3, 3))print(input)# target为long型target = torch.Tensor(torch.zeros(2, 3, 3)).long()target[0, 0, 0] = 2target[1, 1, 1] = 1target[1, 2, 2] = 1print(target)criterion = nn.CrossEntropyLoss()loss = criterion(input, target)print(loss) BCELossclass torch.nn.BCELoss(weight=None, size_average=True) 计算 target 与 output 之间的二进制交叉熵。 import torch.nn as nnimport torch# 二进制交叉商，用0和1来表示类别criterion = nn.BCELoss(reduction=&quot;none&quot;)input = torch.Tensor(torch.randn(2, 3, 3))m = nn.Sigmoid()input = m(input)print(input)target = torch.Tensor(torch.ones(2, 3, 3))target[0, 0, 0] = 0target[1, 1, 1] = 0target[1, 2, 2] = 0print(target)loss = criterion(input, target)print(loss.mean()) 视觉函数PixelShuffleclass torch.nn.PixelShuffle(upscale_factor) 将shape为$[N, Cr^2, H, W]$的Tensor重新排列为shape为$[N, C, Hr, W*r]$的Tensor。 当使用stride=1/r 的sub-pixel卷积的时候，这个方法是非常有用的。 import torch.nn as nnimport torchps = nn.PixelShuffle(3)input = torch.Tensor(torch.randn(1, 9, 4, 4))print(input.size())output = ps(input)print(output.size()) UpsamplingNearest2dclass torch.nn.UpsamplingNearest2d(size=None, scale_factor=None) 对于多channel 输入 进行 2-D 最近邻上采样。可以通过size或者scale_factor来指定上采样后的图片大小。当给定size时，size的值将会是输出图片的大小。 size (tuple, optional) – 一个包含两个整数的元组 (H_out, W_out)指定了输出的长宽 scale_factor (int, optional) – 长和宽的一个乘子import torch.nn as nnimport torchm = nn.UpsamplingNearest2d(scale_factor=2)input = torch.Tensor(torch.randn(1, 1, 2, 2))print(input)output = m(input)print(output) UpsamplingBilinear2dclass torch.nn.UpsamplingBilinear2d(size=None, scale_factor=None) import torch.nn as nnimport torchm = nn.UpsamplingBilinear2d(scale_factor=2)input = torch.Tensor(torch.randn(1, 1, 2, 2))print(input)output = m(input)print(output) 多GPU模块并行DataParallelclass torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0) 在模块级别上实现数据并行。此容器通过将mini-batch划分到不同的设备上来实现给定module的并行。在forward过程中，module会在每个设备上都复制一遍，每个副本都会处理部分输入。在backward过程中，副本上的梯度会累加到原始module上。batch的大小应该大于所使用的GPU的数量。还应当是GPU个数的整数倍，这样划分出来的每一块都会有相同的样本数量。 module – 要被并行的module device_ids – CUDA设备，默认为所有设备。 output_device – 输出设备（默认为device_ids[0]）net = torch.nn.DataParallel(model, device_ids=[0, 1, 2])output = net(input_var) 优化器为了构建一个Optimizer，你需要给它一个包含了需要优化的参数（必须都是Variable对象）的iterable。然后，你可以设置optimizer的参 数选项，比如学习率，权重衰减，等等。 optimizer = optim.SGD(model.parameters(), lr = 0.01, momentum=0.9)optimizer = optim.Adam([var1, var2], lr = 0.0001) 当我们想指定每一层的学习率时 optim.SGD([ &#123;&apos;params&apos;: model.base.parameters()&#125;, &#123;&apos;params&apos;: model.classifier.parameters(), &apos;lr&apos;: 1e-3&#125; ], lr=1e-2, momentum=0.9) 这意味着model.base的参数将会使用1e-2的学习率，model.classifier的参数将会使用1e-3的学习率，并且0.9的momentum将会被用于所有的参数。 所有的optimizer都实现了step()方法，这个方法会更新所有的参数。 optimizer.step()这是大多数optimizer所支持的简化版本。一旦梯度被如backward()之类的函数计算好后，我们就可以调用这个函数。 for input, target in dataset: optimizer.zero_grad() output = model(input) loss = loss_fn(output, target) loss.backward() optimizer.step() Optimizerclass torch.optim.Optimizer(params, defaults) [source] Base class for all optimizers. params (iterable) —— Variable 或者 dict的iterable。指定了什么参数应当被优化。 defaults —— (dict)：包含了优化选项默认值的字典（一个参数组没有指定的参数选项将会使用默认值）。 Adamclass torch.optim.Adam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0)[source] params (iterable) – 待优化参数的iterable或者是定义了参数组的dict lr (float, 可选) – 学习率（默认：1e-3） betas (Tuple[float, float], 可选) – 用于计算梯度以及梯度平方的运行平均值的系数（默认：0.9，0.999） eps (float, 可选) – 为了增加数值计算的稳定性而加到分母里的项（默认：1e-8） weight_decay (float, 可选) – 权重衰减（L2惩罚）（默认: 0） SGDclass torch.optim.SGD(params, lr=, momentum=0, dampening=0, weight_decay=0, nesterov=False)[source] 实现随机梯度下降算法（momentum可选） params (iterable) – 待优化参数的iterable或者是定义了参数组的dict lr (float) – 学习率 momentum (float, 可选) – 动量因子（默认：0） weight_decay (float, 可选) – 权重衰减（L2惩罚）（默认：0） dampening (float, 可选) – 动量的抑制因子（默认：0） nesterov (bool, 可选) – 使用Nesterov动量（默认：False）import torch.optim as optimoptimizer = optim.SGD(model.parameters(), lr=0.1, momentum=0.9)optimizer.zero_grad()loss_fn(model(input), target).backward()optimizer.step() 数据集抽象类torch.utils.dataclass torch.utils.data.Dataset表示Dataset的抽象类。所有其他数据集都应该进行子类化。所有子类应该override__len__和getitem，前者提供了数据集的大小，后者支持整数索引，范围从0到len(self)。 DataLoaderclass torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, num_workers=0, collate_fn=, pin_memory=False, drop_last=False) 数据加载器。组合数据集和采样器，并在数据集上提供单进程或多进程迭代器。 dataset (Dataset) – 加载数据的数据集。 batch_size (int, optional) – 每个batch加载多少个样本(默认: 1)。 shuffle (bool, optional) – 设置为True时会在每个epoch重新打乱数据(默认: False). sampler (Sampler, optional) – 定义从数据集中提取样本的策略。如果指定，则忽略shuffle参数。 num_workers (int, optional) – 用多少个子进程加载数据。0表示数据将在主进程中加载(默认: 0) collate_fn (callable, optional) – pin_memory (bool, optional) – drop_last (bool, optional) – 如果数据集大小不能被batch size整除，则设置为True后可删除最后一个不完整的batch。如果设为False并且数据集的大小不能被batch size整除，则最后一个batch将更小。(默认: False)torchvisiontorchvision.datasetstorchvision.datasets中包含了以下数据集 MNIST COCO（用于图像标注和目标检测）(Captioning and Detection) LSUN Classification ImageFolder Imagenet-12 CIFAR10 and CIFAR100 STL10 Datasets 拥有以下API:getitem len由于以上Datasets都是 torch.utils.data.Dataset的子类，所以，他们也可以通过torch.utils.data.DataLoader使用多线程（python的多进程）。 MNISTfrom torchvision import datasetsroot = &quot;/home/ltb/MNIST&quot;datasets.MNIST(root, train=True, transform=None, target_transform=None, download=True) 参数说明： root : processed/training.pt 和 processed/test.pt 的主目录 train : True = 训练集, False = 测试集 download : True = 从互联网上下载数据集，并把数据集放在root目录下. 如果数据集之前下载过，将处理过的数据（minist.py中有相关函数）放在processed文件夹下。 COCO需要安装COCO API # 图像标注dset.CocoCaptions(root=&quot;dir where images are&quot;, annFile=&quot;json annotation file&quot;, [transform, target_transform]) from torchvision import datasetsimport torchvision.transforms as transformscap = datasets.CocoCaptions(root=&apos;dir where images are&apos;, annFile=&apos;json annotation file&apos;, transform=transforms.ToTensor())print(&apos;Number of samples: &apos;, len(cap))img, target = cap[3] # load 4th sampleprint(&quot;Image Size: &quot;, img.size())print(target) # 检测dset.CocoDetection(root=&quot;dir where images are&quot;, annFile=&quot;json annotation file&quot;, [transform, target_transform]) ImageFolder一个通用的数据加载器，数据集中的数据以以下方式组织。 root/dog/xxx.pngroot/dog/xxy.pngroot/dog/xxz.pngroot/cat/123.pngroot/cat/nsdf3.pngroot/cat/asd932_.png 既其默认你的数据集已经自觉按照要分配的类型分成了不同的文件夹，一种类型的文件夹下面只存放一种类型的图片 import torchvision.datasets as dsetdset.ImageFolder(root=&quot;root folder path&quot;, [transform, target_transform])# root ： 指定图片存储的路径，在下面的例子中是&apos;./data/dogcat_2&apos;# transform： 一个函数，原始图片作为输入，返回一个转换后的图片。# target_transform - 一个函数，输入为target，输出对其的转换。例子，输入的是图片标注的string，输出为word的索引。 import torchvision.datasets as dsetdataset = dset.ImageFolder(&apos;./data/dogcat_2&apos;) #没有transform，先看看取得的原始图像数据print(dataset.classes) #根据分的文件夹的名字来确定的类别print(dataset.class_to_idx) #按顺序为这些类别定义索引为0,1...print(dataset.imgs) #返回从所有文件夹中得到的图片的路径以及其类别&apos;&apos;&apos;[&apos;cat&apos;, &apos;dog&apos;]&#123;&apos;cat&apos;: 0, &apos;dog&apos;: 1&#125;[(&apos;./data/dogcat_2/cat/cat.12484.jpg&apos;, 0), (&apos;./data/dogcat_2/cat/cat.12485.jpg&apos;, 0), (&apos;./data/dogcat_2/cat/cat.12486.jpg&apos;, 0), (&apos;./data/dogcat_2/cat/cat.12487.jpg&apos;, 0), (&apos;./data/dogcat_2/dog/dog.12496.jpg&apos;, 1), (&apos;./data/dogcat_2/dog/dog.12497.jpg&apos;, 1), (&apos;./data/dogcat_2/dog/dog.12498.jpg&apos;, 1), (&apos;./data/dogcat_2/dog/dog.12499.jpg&apos;, 1&apos;&apos;&apos; torchvision.modelstorchvision.models模块的 子模块中包含以下模型结构。 AlexNet VGG ResNet SqueezeNet DenseNet 你可以使用随机初始化的权重来创建这些模型。 from torchvision import modelsresnet18 = models.resnet18()alexnet = models.alexnet()squeezenet = models.squeezenet1_0()densenet = models.densenet161() 对于ResNet variants和AlexNet，我们也提供了预训练(pre-trained)的模型。 import torchvision.models as models# pretrained=True就可以使用预训练的模型resnet18 = models.resnet18(pretrained=True)alexnet = models.alexnet(pretrained=True) tansformCompose将多个transform组合起来使用。transforms： 由transform构成的列表. 例子： from PIL import Imagefrom torchvision import transformstransforms.Compose([ transforms.CenterCrop(10), transforms.ToTensor(), ])&apos;&apos;&apos;### class torchvision.transforms.Scale(size, interpolation=2)将输入的`PIL.Image`重新改变大小成给定的`size`，`size`是最小边的边长。举个例子，如果原图的`height&gt;width`,那么改变大小后的图片大小是`(size*height/width, size)`。**用例:**​```python&apos;&apos;&apos;crop = transforms.Scale(12)img = Image.open(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)print(type(img))print(img.size)croped_img = crop(img)print(type(croped_img))print(croped_img.size) CenterCropclass torchvision.transforms.CenterCrop(size)将给定的PIL.Image进行中心切割，得到给定的size，size可以是tuple，(target_height, target_width)。size也可以是一个Integer，在这种情况下，切出来的图片的形状是正方形。 RandomCropclass torchvision.transforms.RandomCrop(size, padding=0)切割中心点的位置随机选取。size可以是tuple也可以是Integer。 RandomHorizantalFlipclass torchvision.transforms.RandomHorizontalFlip随机水平翻转给定的PIL.Image,概率为0.5。即：一半的概率翻转，一半的概率不翻转。 RandomSizeCropclass torchvision.transforms.RandomSizedCrop(size, interpolation=2)先将给定的PIL.Image随机切，然后再resize成给定的size大小。 Padclass torchvision.transforms.Pad(padding, fill=0)将给定的PIL.Image的所有边用给定的pad value填充。 padding：要填充多少像素 fill：用什么值填充 例子： from torchvision import transformsfrom PIL import Imagepadding_img = transforms.Pad(padding=10, fill=0)img = Image.open(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)print(type(img))print(img.size)padded_img = padding_img(img)print(type(padded_img))print(padded_img.size) Normalizeclass torchvision.transforms.Normalize(mean, std)给定均值：(R,G,B) 方差：（R，G，B），将会把Tensor正则化。即：Normalized_image=(image-mean)/std。 ToTensor与ToPILImage把一个取值范围是[0,255]的PIL.Image或者shape为(H,W,C)的numpy.ndarray，转换成形状为[C,H,W]，取值范围是[0,1.0]的torch.FloadTensor import numpy as npfrom PIL import Imageimport cv2import torchfrom torchvision import transforms# opencv和PIL读取图片img1 = Image.open(&quot;/home/ltb/图片/cv2-tutorial/000001.jpg&quot;)img2 = cv2.imread(&quot;/home/ltb/图片/cv2-tutorial/000001.jpg&quot;)img1.show()cv2.imshow(&quot;img2&quot;, img2)cv2.waitKey(0)print(img1)print(img2)img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)# ToTensor,转化为tensor,[C, H, W],RGB,[0,1.0]t = transforms.ToTensor()img1_tensor = t(img1)img2_tensor = t(img2)print(img1_tensor)print(&quot;\\n&quot;*10)print(img2_tensor)# tensor转化为PILImaget = transforms.ToPILImage()img1 = t(img1_tensor)img2 = t(img2_tensor)img1.show()img2.show()","path":"2019/08/05/pytorch常用函数/","date":"08-05","excerpt":"","tags":[{"name":"deeplearning","slug":"deeplearning","permalink":"https://litianbo243.github.io/tags/deeplearning/"},{"name":"pytorch","slug":"pytorch","permalink":"https://litianbo243.github.io/tags/pytorch/"}]}]}