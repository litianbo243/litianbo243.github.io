{"meta":{"title":"pangzibo243's blog","subtitle":"a man can be destroyed, but not defeated.","description":"pangzibo243's blog","author":"pangzibo243","url":"https://litianbo243.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-03","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"08-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-03","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"08-05","excerpt":""}],"posts":[{"title":"Docker使用指南","text":"1. 查看docker服务器是否正常sudo docker info 2. 运行容器sudo docker run -i -t ubuntu /bin/bashsudo docker run -i -t 镜像名称 命令代码 3. 使用容器# 查看系统中存在的容器docker ps -a 4. 容器命名sudo docker run --name litianbo_test -i -t ubuntu /bin/bashsudo docker run --name 容器名称 -i -t 镜像名称 命令代码 5. 启动已停止的容器# 根据容器名称启动sudo docker start litianbo_test# 根据容器id启动sudo docker start 41225bc38698 6. 进行容器内部命令行sudo docker attach litianbo_test 7. 创建守护式容器sudo docker run --name litianbo_test -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 8. 查看容器日志sudo docker logs litianbo_testsudo docker logs -f litianbo_test 9. 查看容器内进程sudo docker top litianbo_test 10. 在容器内运行进程sudo docker exec -it litianbo_test /bin/bash 11. 停止守护式容器sudo docker stop litianbo_test 12. 自动重启容器sudo docker run --restart=always --name litianbo_test -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 13. 查看容器详细信息sudo docker inspect litianbo_test 14. 删除容器sudo docker rm litianbo_test 15. 查看镜像列表sudo docker images 16. 拉取镜像sudo docker pull ubuntu# 运行时指定tagsudo docker run -it ubuntu:16.04 /bin/bash# 对于一个仓库而言，完整的格式如下：[用户名称/]仓库名称:tag 17. 查找镜像sudo docker search keywords 18. 构建镜像 使用docker commit构建 使用docker build和Dockerfile文件来构建# 创建docker hub账号# 通过命令在本地绑定对应的Docker Hub账号sudo docker login# commit# 根据某个镜像创建一个容器# 对该容器进行一些修改# 提交该容器并生成一个新的镜像sudo docker run -it ubuntu /bin/bashroot@b3f9427a5039:/# apt-get -yqq updateroot@b3f9427a5039:/# apt-get -y install apache2root@b3f9427a5039:/# exitsudo docker commit b3f9427a5039 ltb/apache2sudo docker images# -m=”message” 可以用于对提交的镜像添加一些文本描述# –author=”person” 可以用于添加提交人信息# 提交时，我们可以设置tagsudo docker commit -m=&quot;install apache&quot; --author=&quot;ltb&quot; b3f9427a5039 ltb/apache:v1# 查看镜像详细信息sudo inspect ltb/apache2:v1# 用心镜像创建容器sudo docker run -it ltb/apache2:v1 /bin/bash# dockerfile# 先创建一个工作目录，并在目录中创建一个dockerfile文件mkdir workdircd ./workdirtouch dockerfile# 编辑dockerfile文件FROM ubuntu:14.04MAINTAINER Wangzhe0912 &quot;Wangzhe0912@tju.edu.cn&quot;RUN apt-get updateRUN apt-get install -y nginxRUN echo &quot;Hi, I am your contrainer&quot; &gt; /usr/share/nginx/html/index.htmlEXPOSE 80# 基于dockerfile构建新镜像# 写完dockerfile文件后，可以执行docker build命令生成一个新的镜像# 在本地当前目录下寻找dockerfile文件docker build -t=&quot;ltb/nginx:v1&quot;` .# 指定git仓库寻找dockfile文件docker build -t=&quot;wangzhe0912/nginx:v1&quot;` git@github.com:wangzhe0912/docker_web# dockerfile构建缓存# 希望强制忽略缓存时，可以额外添加--no-cache参数进行设置sudo docker build --no-cache -t=&quot;ltb/nginx:v1&quot;# 基于构建缓存的dockfile模板# 添加了一行环境变量ENVFROM ubuntu:14.04MAINTAINER Wangzhe0912 &quot;Wangzhe0912@tju.edu.cn&quot;ENV REFRESHED_AT 2018-01-28RUN apt-get update...# 查看新镜像构建过程docker history image_name/id# 从新镜像启动容器# -d表示后台程序进行运行# -p 80表示运行时公开80端口给宿主机docker run -d -p 80 --name ltb_nginx ltb/nginx:v1 nginx -g &quot;daemon off;&quot;# 端口查询docker port ltb_nginx 80# 访问地址curl localhost:32768 19. 将镜像推送至Docker Hubsudo docker push ltb/nginx 20. 删除镜像sudo docker rmi 镜像名称 21.登录DockerHubsudo docker login# 输入账号密码 22.Docker免sudo操作sudo groupadd dockercat /ect/groupsudo gpasswd -a $&#123;USER&#125; dockernewgrp - docker 23.管理网络# 创建自定义网络docker network create iccd# 删除自定义网络docker network rm iccd","path":"2019/08/05/docker使用指南/","date":"08-05","excerpt":"","tags":[{"name":"docker","slug":"docker","permalink":"https://litianbo243.github.io/tags/docker/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://litianbo243.github.io/tags/虚拟化/"}]},{"title":"visdom使用指南","text":"安装visdompip install visdom 打开visompython -m visdom.server# 然后打开浏览器 http://localhost:8097/ 指定端口vis = visdom.Visdom(env=&apos;名称&apos;, port=上面开启visdom服务的指定接口)# eg:vis = visdom.Visdom(env=&apos;faster rcnn&apos;, port=15024) 打印lossdef plot(self, name, y): &quot;&quot;&quot; self.plot(&apos;loss&apos;,1.00) &quot;&quot;&quot; x = self.index.get(name, 0) self.vis.line(Y=np.array([y]), X=np.array([x]), win=(name), opts=dict(title=name), update=None if x == 0 else &apos;append&apos; ) self.index[name] = x + 1 vis.plot(&apos;errord&apos;, error_d)vis.plot(&apos;errorg&apos;, error_g) 打印图片# (n, c, h, w)带batch，打印出一个batch里所有图片vis.images(fix_fake_imgs.detach().cpu().numpy()[:64] * 0.5 + 0.5, win=&apos;fixfake&apos;)vis.images(real_img.data.cpu().numpy()[:64] * 0.5 + 0.5, win=&apos;real&apos;)","path":"2019/08/05/visdom使用指南/","date":"08-05","excerpt":"","tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://litianbo243.github.io/tags/pytorch/"},{"name":"visdom","slug":"visdom","permalink":"https://litianbo243.github.io/tags/visdom/"},{"name":"可视化","slug":"可视化","permalink":"https://litianbo243.github.io/tags/可视化/"}]},{"title":"服务器管理指南","text":"1.给root用户设置一个密码sudo passwd root 2.查看所有用户和用户组cat /etc/passwdcat /etc/group 3.添加用户sudo suadduser ltb 4.删除用户deluser --remove-all-files ltb 5.添加用户到用户组sudo usermod -aG iccd ltb 6.创建用户组sudo groupadd iccd 7.删除用户组sudo groupdel iccd 8.修改用户组权限vim /etc/sudoers 9.nfs等操作# 下载nfssudo apt-get install nfs-kernal-server# 重启nfssudo /etc/init.d/nfs-kernal-server restart# 修改配置文件sudo vi /etc/export&quot;&quot;&quot;加上/amax-share *(rw,sync,no_root_squash,no_subtree_check)&quot;&quot;&quot;# mount操作sudo mount X.X.X.X：/amax-share /home/ltb/AMAX# umount操作sudo umount /home/ltb/AMAX","path":"2019/08/05/服务器管理指南/","date":"08-05","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"管理","slug":"管理","permalink":"https://litianbo243.github.io/tags/管理/"},{"name":"常用指令","slug":"常用指令","permalink":"https://litianbo243.github.io/tags/常用指令/"}]},{"title":"Ubuntu常用指令","text":"Ubuntu常用指令石墨版: Ubuntu指南. su和sudo：得到root权限sudo passwd [root] # 设定root密码su [root] # 切换到root用户sudo COMMAND # 切换到root用户，执行COMMAND，然后切换回当前用户su USER # 切换回普通用户USER apt和dpkg：用于安装软件包apt list # 根据名称列出软件包apt show PACKAGE # 显示软件包细节sudo apt-get install PACKAGE # 安装软件包sudo apt-get remove PACKAGE # 卸载软件包sudo apt-get check PACKAGE # 检查依赖sudo apt-get update # 更新可用软件包列表sudo apt upgrade # 通过升级来更新系统sudo apt-get install -f # 修复依赖sudo dpkg -i xxx.deb # 运行deb程序进行安装 pip：用于安装python模块（不是linux里的默认指令，需自行安装sudo apt-get install pip）sudo apt-get install python3-pip # 安装python3下的pip# 更新pip到指定版本python3 -m pip install --user --upgrade pip==9.0.3 # (换成你想要的版本编号)# pip临时加速pip 加参数-i https://pypi.tuna.tsinghua.edu.cn/simple # pip永久加速# Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\"\"\"[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com\"\"\"# windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。pip install PACKAGE # 安装包pip uninstall PACKAGE # 卸载包pip search PACKAGE # 搜索能安装的包pip list # 例出所有的已安装的包pip show PACKAGE # 展示已安装包的信息，可以指定单个包名展示 pip check PACKAGE # 检查依赖pip --version # 显示pip版本和位置pip help # 查看帮助pip help install # 查看install指令的相关option介绍 ssh和scp：用于主机间的通信ssh USERNAME@IP -p PORTNUM # 远程登录到主机scp LOCAL_FILE USERNAME@IP:REMOTE_DIRECTORY # 复制本地文件到远程主机scp -r LOCAL_FILE USERNAME@IP:REMOTE_DIRECTORY # 复制本地文件夹到远程主机sudo ufw dissable # 关闭防火墙sudo ufw enable # 开启防火墙sudo apt-get install vsftpd # 安装sftpservice vsftpd starrt # 启用sftp zip,unzip,tar,rar,unrar：压缩和解压gzip # gzip是Linux使用最广的压缩指令gzip [-cdtv#] FILENAME\"\"\"-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6\"\"\"bzip2 # 提供比gzip更高的压缩比bzip2 [-cdkzv#] FILENAME\"\"\"-k ：保留源文件\"\"\"xz2 # 提供比bzip2更佳的压缩比xz [-dtlkc#] FILENAMEtar 压缩打包tar [-z|-j|-J][cv][-f NEW_TAR_FILE] FILE # 打包压缩tar [-z|-j|-J][tv][-f TAR_FILE] # 查看tar [-z|-j|-J][xv][-f TAR_FILE] [-C DIR] # 解压\"\"\"-z ：使用 zip-j ：使用 bzip2-J ：使用 xz-c ：新建打包文件-t ：查看打包文件里面有哪些文件-x ：解打包或解压缩的功能-v ：在压缩/解压缩的过程中，显示正在处理的文件名-f : filename：要处理的文件-C DIR ： 在特定目录解压缩\"\"\"# 例1tar -jcv -f file.tar.bz2 file # 压缩tar -jxv -f file.tar.bz2 -C ./file # 解压tar -zcv -f dir.tar.gz dir1 dir2 ... # 多个文件压缩# 例2tar -zcv file | split -b 4000M -d -a 1 - file.tar.gz. # 压缩成多个压缩包# 使用split命令\"\"\"-b 4000M 表示设置每个分割包的大小，单位还是可以k-d 参数指定生成的分割包后缀为数字的形式-a x来设定序列的长度(默认值是2)\"\"\"cat file.tar.gz.* | tar -zxv file 多个压缩包解压 du和df：查看磁盘的存储占用和查看文件系统的存储占用du -s # 仅显示总计，只列出最后加的总值du -c # 除了显示个别文件或目录的大小外，还显示一行目录和文件的总和大小du -h # 以k,m,g为单位，提高信息的可读性du --max-depth=1 # 查看当前目录所有（一级）文件的大小du -sh *.mkv # 显示每个mkv文件的大小du -csh *.mkv # 显示每个mkv文件的大小和总和df -h # 以k,m,g为单位，提高信息的可读性df -T # 显示文件系统的类型 which,whereis,locate,find：查找命令#which在PATH变量制定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果#whereis只能用于程序名的搜索，而且只能搜索二进制文件（-b），man说明文件（-m），源代码文件（-s）。若省略，则返回所有信息#locate配合数据库查看文件位置。linux会将系统内所有文件记录在一个数据库文件中，电视该数据库并不是实时更新#find实际搜寻硬盘查询文件名称find . -name \"*.conf\" 当前目录查找扩展名为.conf的文件updatedb 更新数据库locate STRING 快速查找系统数据库中指定的内容which python 查询pythonwhereis python 查询python 文件权限chmod [ugoa][+-=][rwx] FILE|DIR # 改变指定目录或文件的权限# u代表该文件所有者，g代表该文件所有者的同组用户，o代表其他，a表示这三者皆是# r可读，w可写，x可执行chomd u+x test # 该文件的所有者增加可执行的权限# 用数字表示，规定r=4,w=2,x=1chmod 777 file # 三种用户都赋予可读可写可执行的权限chown -R 用户名[:组名] 文件名或目录 # 改变指定目录或文件的所属用户，-R代表递归地改变目录下的所有文件 文件和文本操作ls [-adl] FILE|DIR # 列出文件或者目录信息\"\"\"-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据\"\"\"cd DIR # 更换当前路径mkdir [-mp] DIR # 创建目录\"\"\"-m ：配置目录权限-p ：递归创建目录\"\"\"rmdir [-p] DIR # 删除目录，目录必须为空\"\"\"-p ：递归删除目录\"\"\"touch [-acdmt] FILENAME # 更新文件时间或者建立新文件\"\"\"-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=\"日期或时间\"-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]\"\"\"cp [-adfilprsu] SOURCE DESTINATION # 复制文件\"\"\"-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制\"\"\"rm [-fir] FILE|DIR # 删除文件或者目录\"\"\"-r ：递归删除\"\"\"mv [-fiu] SOURCE DESTINATION # 移动文件\"\"\"-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\"\"\"ln [-sf] SOURCE DESTINATION # 创建链接\"\"\"-s ：默认是 hard link，加 -s 为 symbolic link-f ：如果目标文件存在时，先删除目标文件\"\"\"cat [-n] FILENAME # 获取文件内容\"\"\"-n ：打印出行号，连同空白行也会有行号，-b 不会\"\"\"grep str /tmp/test # 在文件/tmp/test中查找strgrep ^str /tmp/test # 在文件/tmp/test中查找以str开始的行ls -ld */ # 显示当前目录的所有目录文件ls -l | grep '^d' # 显示当前目录的所有目录文件wc -l # 统计文件行数wc -w # 统计单词数量ls -l | wc -l # 统计当前目前的文件数量，注意要减去“总用量”那一行cp -a dir1 dir2 # 复制目录mv dir1 dir2 # 移动/重命名目录mkdir -p /tmp/dir1/dir2 # 创建一个目录树rm -f file1 # 删除文件rm -rf dir1 # 删除目录ln -s /real_file /soft_link # 创建软链接 进程ps -e # 显示所有进程ps -f # 全格式显示进程ps -u 'liaohuqiang' | grep 'tmux' # 显示指定用户执行的进程，并匹配出包含'tmux'的那一行进程ps -ef | grep 'python' | grep -v grep # 把grep命令排除掉ps -ef | grep 'python' | grep -v grep | awk '&#123;print $2&#125;' # 提取进程号pstree -A #查看进程树kill -2 PID # 类似ctrl+C，在程序结束之前能够保存相关数据，再退出kill -9 PID # 直接强制结束进程reboot # 重启shutdown -r now # 立刻重启shutdown -r 30 # 30分钟后重启shutdown -r 23:00 # 晚上11点重启halt # 立刻关机poweroff # 立刻关机shutdown -h now # 立刻关机shutdown -h 30 # 30分钟后关机shutdown -c # 取消shutdwon的重启或关机command &amp; # 使指令成为后台任务nohup # 不挂断地运行命令，通常和&amp;一起用，输出将附加到目录的nohup.outjobs -l # 列出任务列表，l表示显示进程号（只查看当前终端的，关闭终端后无法看到）fg # 把最近一个job切换到前台fg n # 把某个job切换到前台ctrl z # 挂起某个前台进程bg # 把作业放到后台运行top # 动态显示进程信息top -i # 不显示任何闲置或无用的进程\"\"\"k 杀死某进程n 改变显示的进程数量u 显示指定用户P 按CPU使用情况排序q 退出\"\"\"lscpu # 查看cpu信息概要# 监视cpu# 先安装matstatsudo apt install sysstat# 每两秒查看一次mpstat -P ALL 2 网络netstat # 显示网络情况netstat -a # 列出所有端口netstat -l # 只显示监听端口netstat -t # 列出所有tcp端口netstat -p # 显示使用该端口的pid和程序名称netstat -n # 直接使用ip地址，不通过域名服务器# 找出程序运行的端口 netstat -anp | grep ssh# 找出运行在指定端口的进程 netstat -anp | grep ':80'ifconfig # 查看网卡信息 查看电脑配置free -m # 查看内存使用情况df # 查看磁盘使用情况cat /proc/cpuinfo # 查看cpu信息lspci | grep VGA # 查看显卡nvidia-smi # 查看英伟达系列显卡的使用情况nvidia-smi -L # 查看显卡型号watch -n 1 -d nvidia-smi # 实时监控nvidia-smi，每隔一秒刷新一次，d表示高亮 cat /proc/driver/nvidia/version # 查看显卡驱动cat /etc/issue # 查看ubuntu版本 vim简单操作vim可以分为三种模式：命令模式（Command mode）、插入模式（Insert mode）和底线命令模式（Last line mode）Comand mode：控制屏幕光标的移动，字符或光标的删除，移动复制某区段及进入Insert mode下，或者到Last line mode。Insert mode：唯有在Insert mode下，才可做文字数据输入，按Esc等可回到Comand mode。Last line mode：将储存文件或离开编辑器，也可设置编辑环境，如寻找字符串、列出行号等。 在Command mode下按‘i’、‘a’或‘o’三键就可进入Insert mode。这时候您就可以开始输入文字了i: 插入，从目前光标所在之处插入所输入的文字a: 增加，目前光标所在的下一个字开始输入文字o: 插入新的一行，从行首开始输入文字Insert的切换→Command mode，按Esc键您目前处于Insert mode，您就只能一直打字。假如您发现打错字了，想用光标键往回移动，将该字删除，就要按ESC键转换回Command mode，再删除文字 在Command mode下，可按冒号“：”键入入Last line mode，例如：:w filename (输入“w filename”，将文章存入指定的文件名filename):wq (输入“wq”，因为进入之时已经指定文件名testfile，所以会写入testfile并离开vi):q! (输入“q!”，强制离开并放弃编辑的文件) x：每按一次删除光标所在位置的后面一个字符dd：删除光标所在行yy：复制光标所在行u：假如您误操作一个指令，可以马上按u，回复到上一个操作 其他date # 显示时间whoami # 显示当前用户名who # 目前登录系统的用户信息curl 'url' -O --progress # 下载文件,-O代表保存文件（如果没有则输出到屏幕）, --progress表示会显示进度条 # (curl不是linux的默认自行，需自行安装apt install curl)echo $SHELL # 查看系统使用的是哪种shellecho $PATH # 查看环境变量xdg-open filename # 用默认应用程序打开文件python run_generation.py | tee vggTrainResult # 重定向到文件 cat /usr/local/cuda/version.txt # 查看cuda版本cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 # 查看cudnn版本 参考https://www.cnblogs.com/liaohuiqiang/p/7191462.html","path":"2019/08/05/Ubuntu shell 常用指令 指南/","date":"08-05","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://litianbo243.github.io/tags/linux/"},{"name":"常用指令","slug":"常用指令","permalink":"https://litianbo243.github.io/tags/常用指令/"},{"name":"shell","slug":"shell","permalink":"https://litianbo243.github.io/tags/shell/"}]},{"title":"python 多线程、多进程","text":"导读真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。当然，真正地同时执行多线程需要多核CPU才可能实现。 我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。 多线程添加线程# 导入模块import threading# 获取已激活的线程数threading.active_count()# 查看所有线程信息threading.enumerate()# 查看现在正在运行的线程threading.current_thread()# 添加线程，threading.Thread()接收参数target代表这个线程要完成的任务def thread_job(): print(&apos;This is a thread of %s&apos; % threading.current_thread())def main(): thread = threading.Thread(target=thread_job,) # 定义线程 thread.start() # 让线程开始工作 if __name__ == &apos;__main__&apos;: main() join功能使用join对控制多个线程的执行顺序非常关键。join功能是等待调用线程完成再继续下面的操作。推荐如下这种1221的V型排布。示例代码 def T1_job(): print(&quot;T1 start\\n&quot;) for i in range(10): time.sleep(0.1) print(&quot;T1 finish\\n&quot;)def T2_job(): print(&quot;T2 start\\n&quot;) print(&quot;T2 finish\\n&quot;)thread_1 = threading.Thread(target=T1_job, name=&apos;T1&apos;)thread_2 = threading.Thread(target=T2_job, name=&apos;T2&apos;)----------------------------------------------------------------------thread_1.start() # start T1thread_2.start() # start T2thread_2.join() # join for T2thread_1.join() # join for T1print(&quot;all done\\n&quot;)&quot;&quot;&quot;T1 startT2 startT2 finishT1 finishall done&quot;&quot;&quot; setDaemon功能setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(),这个的意思是，把主线程A设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出.这就是setDaemon方法的含义，这基本和join是相反的。示例代码 import threading import time class MyThread(threading.Thread): def __init__(self,id): threading.Thread.__init__(self) def run(self): time.sleep(5) print &quot;This is &quot; + self.getName() if __name__ == &quot;__main__&quot;: t1=MyThread(999) t1.setDaemon(True) t1.start() print &quot;I am the father thread.&quot; &quot;&quot;&quot;I am the father thread.&quot;&quot;&quot;# 可以看出，子线程t1中的内容并未打出。 线程锁Locklock在不同线程使用同一共享内存时，能够确保线程之间互不影响，使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。示例代码 import threadingdef job1(): global A,lock lock.acquire() for i in range(10): A+=1 print(&apos;job1&apos;,A) lock.release()def job2(): global A,lock lock.acquire() for i in range(10): A+=10 print(&apos;job2&apos;,A) lock.release()if __name__== &apos;__main__&apos;: lock=threading.Lock() A=0 t1=threading.Thread(target=job1) t2=threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join() &quot;&quot;&quot;job1 1job1 2job1 3job1 4job1 5job1 6job1 7job1 8job1 9job1 10job2 20job2 30job2 40job2 50job2 60job2 70job2 80job2 90job2 100job2 110&quot;&quot;&quot; 其他常用操作import threading# 队列from queue import Queuedef job(i, q): print(&quot;i&apos;m thread &#123;&#125; &quot;.format(i)) i = i**2 # 将结果存入队列中，因为多线程函数不能有return q.put(i) q =Queue()threads = []for i in range(4): t = threading.Thread(target=job,args=(i, q)) t.start() # 将进程加入列表 threads.append(t)# 逐个joinfor thread in threads: thread.join() # 得到队列中元素，result# 测试后发现结果顺序有一定概率不准确。。。result = []for _ in range(4): result.append(q.get()) print(result) GILPython 的设计上, 有一个必要的环节, 就是 Global Interpreter Lock (GIL). 这个东西让 Python 还是一次性只能处理一个东西. GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。 所以Python的多线程就是假的。。。。 多进程Python提供多进程的原因很简单, 就是用来弥补 threading 的一些劣势, 比如在 GIL. 添加进程示例代码 # 多进程import multiprocessing as mpdef job(a,d): print(&apos;aaaaa&apos;) print(mp.current_process())if __name__==&apos;__main__&apos;: p1 = mp.Process(target=job,args=(1,2)) print(mp.current_process()) p1.start() p1.join() 进程池进程池就是我们将所要运行的东西，放到池子里，Python会自行解决多进程的问题示例代码 import multiprocessing as mpdef job(x): return x*x # 定义一个poolpool = mp.Pool()# 有了池子之后，就可以让池子对应某一个函数，我们向池子里丢数据，池子就会返回函数返回的值。Pool和之前的Process的不同点是丢向Pool的函数有返回值，而Process的没有返回值。# 接下来用map()获取结果，在map()中需要放入函数和需要迭代运算的值，然后它会自动分配给CPU核res = pool.map(job, range(10))print(res) 自定义核数量Pool默认大小是CPU的核数，我们也可以通过在Pool中传入processes参数即可自定义需要的核数量。示例代码 def multicore(): pool = mp.Pool(processes=3) # 定义CPU核数量为3 res = pool.map(job, range(10)) print(res) apply_async示例代码 import multiprocessing as mpdef job(x): return x*xpool = mp.Pool()multi_res = [pool.apply_async(job, (i,)) for i in range(10)]print([res.get() for res in multi_res])# 和map差不多 共享内存我们可以通过使用Value数据存储在一个共享的内存表中。 import multiprocessing as mpvalue1 = mp.Value(&apos;i&apos;, 0) value2 = mp.Value(&apos;d&apos;, 3.14) 其中d和i参数用来设置数据类型的，d表示一个双精浮点类型，i表示一个带符号的整型。更多的形式请查看此表. | Type code | C Type | Python Type | Minimum size in bytes || --------- | ------------------ | ----------------- | --------------------- || `&apos;b&apos;` | signed char | int | 1 || `&apos;B&apos;` | unsigned char | int | 1 || `&apos;u&apos;` | Py_UNICODE | Unicode character | 2 || `&apos;h&apos;` | signed short | int | 2 || `&apos;H&apos;` | unsigned short | int | 2 || `&apos;i&apos;` | signed int | int | 2 || `&apos;I&apos;` | unsigned int | int | 2 || `&apos;l&apos;` | signed long | int | 4 || `&apos;L&apos;` | unsigned long | int | 4 || `&apos;q&apos;` | signed long long | int | 8 || `&apos;Q&apos;` | unsigned long long | int | 8 || `&apos;f&apos;` | float | float | 4 || `&apos;d&apos;` | double | float | 8 | 在Python的mutiprocessing中，有还有一个Array类，可以和共享内存交互，来实现在进程之间共享数据。 array = mp.Array(&apos;i&apos;, [1, 2, 3, 4]) 这里的Array和numpy中的不同，它只能是一维的，不能是多维的。同样和Value 一样，需要定义数据形式，否则会报错。 进程锁为了解决不同进程抢共享资源的问题，我们可以用加进程锁来解决。示例代码 import multiprocessing as mpimport timedef job(v, num, l): l.acquire() # 锁住 for _ in range(5): time.sleep(0.1) v.value += num # 获取共享内存 print(v.value) l.release() # 释放def multicore(): l = mp.Lock() # 定义一个进程锁 v = mp.Value(&apos;i&apos;, 0) # 定义共享内存 p1 = mp.Process(target=job, args=(v,1,l)) # 需要将lock传入 p2 = mp.Process(target=job, args=(v,3,l)) p1.start() p2.start() p1.join() p2.join()if __name__ == &apos;__main__&apos;: multicore() &quot;&quot;&quot;12345811141720&quot;&quot;&quot;# 显然，进程锁保证了进程p1的完整运行，然后才进行了进程p2的运行","path":"2019/08/05/python 多线程、多进程/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"多线程","slug":"多线程","permalink":"https://litianbo243.github.io/tags/多线程/"},{"name":"多进程","slug":"多进程","permalink":"https://litianbo243.github.io/tags/多进程/"}]},{"title":"Git使用指南","text":"简介Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git安装配置Ubuntu$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2 Windows在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：安装包下载地址：https://gitforwindows.org/完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 Git工作流程一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 下图展示了 Git 的工作流程： Git工作区、暂存区和版本库基本概念我们先来理解下Git 工作区、暂存区和版本库概念 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git创建仓库git init# 先cd带制定目录$ git init# 就初始化成功了 git clone# 克隆仓库$ git clone &lt;repo&gt;# 克隆到制定目录$ git clone &lt;repo&gt; &lt;directory&gt;# repo:Git仓库# directory:本地目录 Git基本操作git add# 查看文件状态$ git status -s?? README?? hello.php$ git add README hello.php$ git status -sA READMEA hello.php# 在README中添加一些内容，保存后推出，再执行git status$ git status -sAM READMEA hello.php# &quot;AM&quot; 状态的意思是，这个文件在我们将它添加到缓存之后又有改动# 改动后我们再执行 git add 命令将其添加到缓存中$ git add .$ git status -sA READMEA hello.php# 当你要将你的修改包含在即将提交的缓存中的时候，需要执行git add git commit使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。 $ git config --global user.name &apos;ltb&apos;$ git config --global user.email 351526199@qq.com 接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。 $ git add hello.php$ git status -sA READMEA hello.php$ git commit -m &apos;第一次版本提交&apos;[master (root-commit) d32cf1f] 第一次版本提交 2 files changed, 4 insertions(+) create mode 100644 README create mode 100644 hello.php 现在我们已经记录了快照。如果我们再执行 git status: $ git status# On branch masternothing to comxmit (working directory clean) git reset HEADgit reset HEAD 命令用于取消已缓存的内容。我们先改动文件 README 文件，内容如下： # Runoob Git 测试# 菜鸟教程 hello.php 文件修改为： &lt;?phpecho &apos;菜鸟教程：www.runoob.com&apos;;echo &apos;菜鸟教程：www.runoob.com&apos;;echo &apos;菜鸟教程：www.runoob.com&apos;;?&gt; 现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下： $ git status -s M README M hello.php $ git add .$ git status -sM READMEM hello.php$ git reset HEAD hello.php Unstaged changes after reset:M hello.php$ git status -sM README M hello.php 现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。 $ git commit -m &apos;修改&apos;[master f50cfda] 修改 1 file changed, 1 insertion(+)$ git status -s M hello.php git rm如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作 $ git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f $ git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可 $ git rm --cached &lt;file&gt; 如我们删除 hello.php文件： $ git rm hello.php rm &apos;hello.php&apos;$ lsREADME 不从工作区中删除文件： $ git rm --cached README rm &apos;README&apos;$ lsREADME 可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件： git rm –r * 进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。 Git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。创建分支命令： $ git branch (branchname) 切换分支命令： # git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。合并分支命令: $ git merge 列出分支$ git branch* master$ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 $ lsREADME$ echo &apos;runoob.com&apos; &gt; test.txt$ git add .$ git commit -m &apos;add test.txt&apos;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch &apos;testing&apos;$ lsREADME 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。 $ git checkout masterSwitched to branch &apos;master&apos;$ lsREADME test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 $ git checkout -b newtestSwitched to a new branch &apos;newtest&apos;$ git rm test.txt rm &apos;test.txt&apos;$ lsREADME$ touch hello.php$ git add .$ git commit -am &apos;removed test.txt、add runoob.php&apos;[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php$ git checkout masterSwitched to branch &apos;master&apos;$ lsREADME test.txt 如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。 删除分支$ git branch* master testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 分支合并一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： $ git branch* master newtest$ lsREADME test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。合并完后就可以删除分支: $ git branch -d newtestDeleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了： $ git branch* master 合并冲突合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 $ git branch* master$ cat runoob.php 首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为: &lt;?phpecho &apos;runoob&apos;;?&gt; 创建 change_site 分支： $ git checkout -b change_siteSwitched to a new branch &apos;change_site&apos;$ vim runoob.php$ head -3 runoob.php&lt;?phpecho &apos;runoob&apos;;?&gt;$ git commit -am &apos;changed the runoob.php&apos;[change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+) 将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。 $ git checkout masterSwitched to branch &apos;master&apos;$ cat runoob.php$ vim runoob.php # 修改内容如下$ cat runoob.php&lt;?phpecho 1;?&gt;$ git diffdiff --git a/runoob.php b/runoob.phpindex e69de29..ac60739 100644--- a/runoob.php+++ b/runoob.php@@ -0,0 +1,3 @@+&lt;?php+echo 1;+?&gt;$ git commit -am &apos;修改代码&apos;[master c68142b] 修改代码 1 file changed, 3 insertions(+) 现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。 $ git merge change_siteAuto-merging runoob.phpCONFLICT (content): Merge conflict in runoob.phpAutomatic merge failed; fix conflicts and then commit the result.$ cat runoob.php # 代开文件，看到冲突内容&lt;?php&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADecho 1;=======echo &apos;runoob&apos;;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site?&gt; 我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 $ vim runoob.php $ cat runoob.php&lt;?phpecho 1;echo &apos;runoob&apos;;?&gt;$ git diffdiff --cc runoob.phpindex ac60739,b63d7d7..0000000--- a/runoob.php+++ b/runoob.php@@@ -1,3 -1,3 +1,4 @@@ &lt;?php +echo 1;+ echo &apos;runoob&apos;; ?&gt; 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -sUU runoob.php$ git add runoob.php$ git status -sM runoob.php$ git commit[master 88afe0e] Merge branch &apos;change_site&apos; Git查看提交历史我们可以用 –oneline 选项来查看历史记录的简洁的版本。 $ git log --oneline$ git log --onelined5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;c68142b 修改代码7774248 (change_site) changed the runoob.phpc1501a2 removed test.txt、add runoob.php3e92c19 add test.txt3b58100 第一次版本提交 这告诉我们的是，此项目的开发历史。我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项： * d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交 Git标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 $ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了： * d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 3b58100$ git log --oneline --decorate --graph* d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 (tag: v0.9) 第一次版本提交 如果我们要查看所有标签可以使用以下命令： $ git tagv0.9v1.0 Github要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下： $ git remote add [shortname] [url] 本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：使用以下命令生成 SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。回到 github 上，进入 Account =&gt; Settings（账户配置）。左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。添加成功后界面如下所示为了验证是否成功，输入以下命令： $ ssh -T git@github.comHi tianqixin! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 以下命令说明我们已成功连上 Github。之后登录后点击” New repository “ 如下图所示：创建成功后，显示如下信息：以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。现在，我们根据 GitHub 的提示，在本地的仓库下运行命令： $ mkdir runoob-git-test # 创建测试目录$ cd runoob-git-test/ # 进入测试目录$ echo &quot;# 菜鸟教程 Git 测试&quot; &gt;&gt; README.md # 创建 README.md 文件并写入内容$ ls # 查看目录下的文件README$ git init # 初始化$ git add README.md # 添加文件$ git commit -m &quot;添加 README.md 文件&quot; # 提交并备注信息[master (root-commit) 0205aab] 添加 README.md 文件 1 file changed, 1 insertion(+) create mode 100644 README.md# 提交到 Github$ git remote add origin git@github.com:tianqixin/runoob-git-test.git$ git push -u origin master 以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上： fork如上图所示找到想要pull request的项目，然后点击fork按钮，此时变会在你的仓库中多出来一个仓库，名字为：自己的账户名/想要pull request的项目的名称 clone通过运行命令：git clone https://github.com/fengyanWang/first-pr.git（后面的网址为你自己账户下刚刚生成的那个新的仓库的地址），将该仓库克隆到当前的开发环境中 branch通过在终端运行命令：git branch -a查看当前所在的分支，通常我们都是在查看分支后再进行代码的修改，这是一个好的习惯。在应用github修改代码时，我们常常采用的策略是在主分支下在创建一个特性分支，在该特性分支下进行代码的修改然后通过该分支执行pull request操作。通过命令：git checkout -b work master(其中work为你新建的特性分支，master为你当前坐在的分支)创建新的特性分支并自动切换 添加修改在刚刚新创建的分支下对fork下的工程进行修改 首先使用命令：git diff查看修改的内容是否正确，然后使用命令：git add readMe.md（其中readMe.md为要添加的文件）向仓库中添加文件，在执行命令：git commit -m “add readMe.md文件”提交说明 要从github发送pull request，github端的仓库中必须有一个包含了修改后的代码的分支，所以需要创建一个与刚刚创建的特性分支（修改所在的分支）相对应的远程分支，执行命令：git push origin work1(其中origin为当时fork的远程主分支的名称，一般默认为origin,work1为本地工作的特性分支)，然后执行：git branch -a进行查看是否创建成功 发送pull request进入到自己的github账户下，并切换到创建的特性分支下，然后点击create pull request后，确定没问题，填写相关内容，然后点击send pull requests","path":"2019/08/05/Git使用指南/","date":"08-05","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://litianbo243.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://litianbo243.github.io/tags/github/"}]},{"title":"opencv-python常用函数及其介绍","text":"读取图片、显示图片、写回图片# -*- coding: utf-8 -*-import numpy as npimport cv2print(cv2.__version__)img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_COLOR) #读入一副彩色图像。图像的透明度会被忽略 默认参数。# img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_GRAYSCALE) # Load an color image in grayscale 灰度# img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_UNCHANGED) # 包括图像的 alpha 通道img = cv2.resize(img, (640, 480))#rows, cols, ch = img.shapeprint(&apos;行/高:&apos;, rows, &apos;列/宽:&apos;, cols, &apos;通道:&apos;, ch)# 图像的宽对应的是列数, 高对应的是行数。cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_NORMAL) # 可以调整窗口大小# cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_AUTOSIZE)#自动调整# cv2.namedWindow(&apos;image&apos;, cv2.WINDOW_KEEPRATIO)#保持图片比例# cv2.resizeWindow(&apos;image&apos;, 200, 200) # 不起作用？cv2.imshow(&apos;image&apos;, img) # 窗口会自动调整为图像大小# 在窗口上按任意键退出cv2.waitKey(delay=0) # 返回按键的 ASCII 码值cv2.destroyAllWindows()# # cv2.imwrite(‘/home/ltb/图片/cv2-tutorial/000001.png’, img)颜色转化 # -*- coding: utf-8 -*-# @Time : 2018/1/20 17:15# @Author : play4fun# @File : 颜色转换.py# @Software: PyCharm&quot;&quot;&quot;颜色转换.py:&quot;&quot;&quot;import cv2img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, cv2.IMREAD_COLOR)cv2.imshow(&quot;BGR&quot;, img)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)cv2.imshow(&quot;GRAY&quot;, gray)temp = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 灰色转RGBcv2.imshow(&quot;RGB&quot;, temp)cv2.waitKey(0) 读取视频流（单摄像头）# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Fri Jan 3 21:06:22 2014@author: duan &quot;&quot;&quot;&apos;&apos;&apos; 注意 当你的程序报错时 你 先检查的是你的摄像头是否能够在其他程 序中正常工作 比如 linux 下的 Cheese 。&apos;&apos;&apos;import numpy as npimport cv2cap = cv2.VideoCapture(0) # 一般的笔 本电脑 有内置摄像头。所以参数就是 0。你可以 设置成 1 或 者其他的来 择别的摄像头&apos;&apos;&apos;你可以使用函数 cap.get(propId) 来获得 的一些参数信息。propId 可以是 0 到 18 之 的任何整数。其中的一些值可以使用 cap.set(propId,value) 来修改 value 就是 你想 置成的新值。例如 我可以使用 cap.get(3) cv2.CAP_PROP_FRAME_WIDTH和 cap.get(4) cv2.CAP_PROP_FRAME_HEIGHT来查看每一帧的宽和高。默认情况下得到的值是 640X480。但是我可以使用 ret=cap.set(3,320) 和 ret=cap.set(4,240) 来把宽和高改成 320X240。&apos;&apos;&apos;# ret=cap.set(3,320)# ret=cap.set(4,240)# ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, 480)#避免计算量过大# ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 270)## 等比缩放frame_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT) # 4 ，720frame_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH) # 3 ，1280frame_height = int(480 / frame_width * frame_height) # 270ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, frame_height) # 高ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, 480)# while (True):while cap.isOpened(): # 检查是否成功初始化，否则就 使用函数 cap.open() # Capture frame-by-frame ret, frame = cap.read() # ret 返回一个布尔值 True/False # print(&apos;frame shape:&apos;,frame.shape)#(720, 1280, 3) frame = cv2.flip(frame, flipCode=1) # 左右翻转,使用笔记本电脑摄像头才有用。 # flipCode：翻转方向：1：水平翻转；0：垂直翻转；-1：水平垂直翻转 # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow(&apos;frame&apos;, gray) cv2.setWindowTitle(&apos;frame&apos;, &apos;COLOR_BGR2GRAY&apos;) # Property=cv2.getWindowProperty(&apos;frame&apos;,0)#无用 # if cv2.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):#不行 # break key = cv2.waitKey(delay=10) if key == ord(&quot;q&quot;): break# When everything done, release the capturecap.release()cv2.destroyAllWindows() 读取视频流（双摄像头）# -*- coding: utf-8 -*-# @Time : 2017/8/15 00:19# @Author : play4fun# @File : two_camera.py# @Software: PyCharm&quot;&quot;&quot;two_camera.py:&quot;&quot;&quot;import cv2import numpy as npcap0 = cv2.VideoCapture(0)cap1 = cv2.VideoCapture(1)ret = cap0.set(3, 320)ret = cap0.set(4, 240)ret = cap1.set(3, 320)ret = cap1.set(4, 240)while cap0.isOpened() and cap1.isOpened(): ret0, frame0 = cap0.read() ret1, frame1 = cap1.read() if ret0: cv2.imshow(&apos;frame0&apos;, frame0) cv2.setWindowTitle(&apos;frame0&apos;, &apos;On Top&apos;) if ret1: cv2.imshow(&apos;frame1&apos;, frame1) # cv2.moveWindow(&apos;frame1&apos;, x=frame0.shape[1], y=0) cv2.moveWindow(&apos;frame1&apos;, x=320, y=40) key = cv2.waitKey(delay=2) if key == ord(&quot;q&quot;): break# When everything done, release the capturecap0.release()cap1.release()cv2.destroyAllWindows() 读取视频（影片）import numpy as npimport cv2cap = cv2.VideoCapture(&apos;/home/ltb/视频/simplescreenrecorder-2019-04-14_00.52.45.mkv&apos;)# cap = cv2.VideoCapture(&apos;output.avi&apos;)# cap = cv2.VideoCapture(&apos;Minions_banana.mp4&apos;)# 帧率fps = cap.get(cv2.CAP_PROP_FPS) # 25.0print(&quot;Frames per second using video.get(cv2.CAP_PROP_FPS) : &#123;0&#125;&quot;.format(fps))# 总共有多少帧num_frames = cap.get(cv2.CAP_PROP_FRAME_COUNT)print(&apos;共有&apos;, num_frames, &apos;帧&apos;)#frame_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)frame_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)print(&apos;高：&apos;, frame_height, &apos;宽：&apos;, frame_width)FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES) # 第0帧print(&apos;当前帧数&apos;, FRAME_NOW) # 当前帧数 0.0# 读取指定帧,对视频文件才有效，对摄像头无效？？frame_no = 121cap.set(1, frame_no) # Where frame_no is the frame you wantret, frame = cap.read() # Read the framecv2.imshow(&apos;frame_no&apos;+str(frame_no), frame)FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES)print(&apos;当前帧数&apos;, FRAME_NOW) # 当前帧数 122.0while cap.isOpened(): ret, frame = cap.read() FRAME_NOW = cap.get(cv2.CAP_PROP_POS_FRAMES) # 当前帧数 print(&apos;当前帧数&apos;, FRAME_NOW) gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imshow(&apos;frame&apos;, gray) key = cv2.waitKey(1) if key == ord(&quot;q&quot;): breakcap.release()cv2.destroyAllWindows() 写回视频import numpy as npimport cv2cap = cv2.VideoCapture(0)width = 640ret = cap.set(3, width)height = 480ret = cap.set(4, height)# Define the codec and create VideoWriter objectfourcc = cv2.VideoWriter_fourcc(*&apos;XVID&apos;) # opencv 3.0# Error: &apos;module&apos; object has no attribute &apos;VideoWriter_fourcc&apos;# fourcc=cv2.VideoWriter_fourcc(&apos;X&apos;, &apos;V&apos;, &apos;I&apos;, &apos;D&apos;)#jpeg,h263,&apos;m&apos;, &apos;p&apos;, &apos;4&apos;, &apos;v&apos;#out = cv2.VideoWriter(&apos;output.avi&apos;, fourcc, 20.0, (width, height))while cap.isOpened(): ret, frame = cap.read() if ret is True: frame = cv2.resize(frame, (640, 480)) # write the flipped frame out.write(frame) cv2.imshow(&apos;frame&apos;, frame) else: break key = cv2.waitKey(1) if key == ord(&quot;q&quot;): break# Release everything if job is finishedcap.release()out.release()cv2.destroyAllWindows() 绘图函数# -*- coding: utf-8 -*-import numpy as npimport cv2&apos;&apos;&apos;• img: 你想 绘制图形的 幅图像。• color: 形状的颜色。以RGB为例 需要传入一个元组BGR 例如 255,0,0 代表蓝色，第一个是蓝色通道，第二个是绿色通道，第三个是红色通道。对于灰度图只需要传入灰度值。• thickness 线条的粗细。如果给一个闭合图形 置为 -1 那么这个图形就会被填充。 默认值是 1.• linetype 线条的类型， 8 连接，抗锯齿等。 默认情况是8 连接。cv2.LINE_AA 为抗锯齿 这样看起来会非常平滑。&apos;&apos;&apos;# Create a black imageimg = np.zeros((512, 512, 3), np.uint8)# Draw a diagonal blue line with thickness of 5 pxcv2.line(img, pt1=(0, 0), pt2=(511, 511), color=(255, 0, 0), thickness=5) # pt1, pt2, color, thickness=# cv2.polylines() 可以 用来画很多条线。只需要把想 画的线放在一 个列表中， 将 列表传给函数就可以了。每条线 会被独立绘制。 这会比用 cv2.line() 一条一条的绘制 要快一些。# cv2.polylines(img, pts, isClosed, color, thickness=None, lineType=None, shift=None)cv2.arrowedLine(img, pt1=(21, 13), pt2=(151, 401), color=(255, 0, 0), thickness=5)cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)cv2.circle(img, center=(447, 63), radius=63, color=(0, 0, 255), thickness=-1) # center, radius, color, thickness=None# 一个参数是中心点的位置坐标。 下一个参数是长轴和短轴的长度。椭圆沿逆时针方向旋转的角度。# 椭圆弧演顺时针方向起始的角度和结束角度 如果是 0 很 360 就是整个椭圆cv2.ellipse(img, center=(256, 256), axes=(100, 50), angle=0, startAngle=0, endAngle=180, color=255, thickness=-1) # center, axes, angle, startAngle, endAngle, color, thickness=pts = np.array([[10, 5], [20, 30], [70, 20], [50, 10]], np.int32)pts = pts.reshape((-1, 1, 2))# 这里 reshape 的第一个参数为-1, 表明这一维的长度是根据后面的维度的计算出来的。# 注意 如果第三个参数是 False 我们得到的多边形是不闭合的 ，首 尾不相 连 。font = cv2.FONT_HERSHEY_SIMPLEX# org :Bottom-left corner of the text string in the image.左下角# 或使用 bottomLeftOrigin=True,文字会上下颠倒cv2.putText(img, text=&apos;bottomLeftOrigin&apos;, org=(10, 400), fontFace=font, fontScale=1, color=(255, 255, 255), thickness=1, bottomLeftOrigin=True) # text, org, fontFace, fontScale, color, thickness=cv2.putText(img, text=&apos;OpenCV&apos;, org=(10, 500), fontFace=font, fontScale=4, color=(255, 255, 255), thickness=2) # text, org, fontFace, fontScale, color, thickness=# 所有的绘图函数的返回值都是 None ，所以不能使用 img = cv2.line(img,(0,0),(5winname = &apos;example&apos;cv2.namedWindow(winname, 0)cv2.imshow(winname, img)cv2.imwrite(&quot;example.png&quot;, img)cv2.waitKey(0)cv2.destroyAllWindows() 拆分通道、合并通道# -*- coding: utf-8 -*-import cv2import numpy as np# 拆分及合并图像通道img = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)#b, g, r = cv2.split(img) # 比较耗时的操作，请使用numpy 索引img = cv2.merge((b, g, r))#b = img[:, :, 0]# 使所有像素的红色通道值都为 0,你不必先拆分再赋值。# 你可以 直接使用 Numpy 索引,这会更快。img[:, :, 2] = 0# 保存到文件，看下效果cv2.imwrite(filename=&apos;split_color2.jpg&apos;, img=img) 图像相加# -*- coding: utf-8 -*-import cv2import numpy as np# 学习图像上的算术运算 加法 减法 位运算等# 你可以使用函数 cv2.add() 将两幅图像进行加法运算 当然也可以直接使 用 numpy ，# res=img1+img# 两幅图像的大小 类型必须一致 ，或者第二个 图像可以使一个简单的标量值。x = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y)) # 250+10 = 260 =&gt; 255# [[255]]print(x + y) # 250+10=260%256=4# [4]# 图像混合img1 = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)img2 = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.png&apos;)dst = cv2.addWeighted(img1, 0.1, img2, 0.9, 0) # 第一幅图的权重是 0.7 第二幅图的权重是 0.3cv2.imshow(&apos;dst&apos;, dst)cv2.waitKey(0)cv2.destroyAllWindows() 图像扩展缩放# -*- coding: utf-8 -*-&apos;&apos;&apos;扩展缩放在缩放时我们推荐使用 cv2.INTER_AREA在扩展时我们推荐使用 v2.INTER_CUBIC 慢) 和 v2.INTER_LINEAR。默认情况下所有改变图像尺寸大小的操作使用的插值方法 是 cv2.INTER_LINEAR。Resize(src, dst, interpolation=CV_INTER_LINEAR)&apos;&apos;&apos;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)# 下面的 None 本应 是 出图像的尺寸 但是因为后边我们设置了缩放因子# 因此这里为 Noneres = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)# OR# 我们直接设置输出图像的尺寸 所以不用设置缩放因子# height, width = img.shape[:2]# res = cv2.resize(img, (2 * width, 2 * height), interpolation=cv2.INTER_CUBIC)cv2.imshow(&apos;resize&apos;, res)cv2.imshow(&apos;src img&apos;, img)cv2.waitKey(0)cv2.destroyAllWindows() Otsu二值化# -*- coding: utf-8 -*-&apos;&apos;&apos;Otsu&apos;s 二值化在第一 分中我们提到 retVal 当我们使用 Otsu 二值化时会用到它。 么它到底是什么呢在使用全局 值时 我们就是 便给了一个数来做 值 我们怎么知 我们 取的 个数的好坏呢? 答案就是不停的尝 。 如果是一副双峰图像 ，简 单来 双峰图像是指图像直方图中存在两个峰 呢 ？ 我们岂不是应 在两个峰 之 的峰 一个值作为阈值 。 就是 Otsu 二值化 做的。 简单来说，就是对一副双峰图像自动根据其直方图计算出一个阈值。 对于非双峰图像 这 种方法 得到的结果可能会不理想 。 这里 用到的函数 是 cv2.threshold() 但是 需要多传入一个参数 flag cv2.THRESH_OTSU。 这时 把 值 为 0。然后算法会找到最 优阈值 ，这 个最优 值就是 回值 retVal。 如果不使用 Otsu 二值化 返回的retVal 值与 设定的 阈值相等。下 的例子中 输入图像是一副带有噪声的图像。第一种方法 我们 设127 为全局 阈值。第二种方法 我们直接使用 Otsu 二值化。第三种方法 我 们 先使用一个 5x5 的 高斯核 去噪 然后再使用 Otsu 二值化。看看噪音 去除对结果的影响有多大吧。&apos;&apos;&apos;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)# global thresholdingret1, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# Otsu&apos;s thresholdingret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# Otsu&apos;s thresholding after Gaussian filtering# 5,5 为 斯核的大小 0 为标准差blur = cv2.GaussianBlur(img, (5, 5), 0)# 阀值一定为 0ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# plot all the images and their histogramsimages = [img, 0, th1, img, 0, th2, blur, 0, th3]titles = [&apos;Original Noisy Image&apos;, &apos;Histogram&apos;, &apos;Global Thresholding (v=127)&apos;, &apos;Original Noisy Image&apos;, &apos;Histogram&apos;, &quot;Otsu&apos;s Thresholding&quot;, &apos;Gaussian filtered Image&apos;, &apos;Histogram&apos;, &quot;Otsu&apos;s Thresholding&quot;]# 使用了 pyplot 中画直方图的方法 plt.hist,# 注意的是它的参数是一维数组# 所以使用了 numpy ravel 方法 将多维数组 换成一维 也可以使用 flatten 方法# ndarray.flat 1-D iterator over an array.# ndarray.flatten 1-D array copy of the elements of an array in row-major order.for i in range(3): plt.subplot(3, 3, i * 3 + 1), plt.imshow(images[i * 3], &apos;gray&apos;) plt.title(titles[i * 3]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 2), plt.hist(images[i * 3].ravel(), 256) plt.title(titles[i * 3 + 1]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 3), plt.imshow(images[i * 3 + 2], &apos;gray&apos;) plt.title(titles[i * 3 + 2]), plt.xticks([]), plt.yticks([])plt.show() 自适应二值化# -*- coding: utf-8 -*-&apos;&apos;&apos;自适应阈值Adaptive Method- 指定 算阈值的方法。– cv2.ADPTIVE_THRESH_MEAN_C 值取自相邻区域的平均值– cv2.ADPTIVE_THRESH_GAUSSIAN_C 值取值相邻区域 的加权和 ，权重为一个高斯窗口&apos;&apos;&apos;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)# 中值滤波img = cv2.medianBlur(img, 5)ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# 11 为 Block size 邻域大小 用来计算阈值的区域大小 ,# 2 为 C值，常数， 阈值就等于的平均值或者加权平均值减去这个常数。th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)titles = [&apos;Original Image&apos;, &apos;Global Thresholding (v = 127)&apos;, &apos;Adaptive Mean Thresholding&apos;, &apos;Adaptive Gaussian Thresholding&apos;]images = [img, th1, th2, th3]for i in range(4): plt.subplot(2, 2, i + 1), plt.imshow(images[i], &apos;gray&apos;) plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 简单二值化# -*- coding: utf-8 -*-&apos;&apos;&apos;简单阈值像素值高于阈值时 我们给这个像素 赋予一个新值， 可能是白色 ， 否则我们给它赋予另外一种颜色， 或是黑色 。 这个函数就是 cv2.threshhold()。 这个函数的第一个参数就是原图像 原图像应 是灰度图。 第二个参数就是用来对像素值进行分类的阈值。 第三个参数 就是当像素值高于， 有时是小于 阈值时应该被赋予的新的像素值。 OpenCV 提供了多种不同的阈值方法 ， 是由第四个参数来决定的。 些方法包括• cv2.THRESH_BINARY• cv2.THRESH_BINARY_INV • cv2.THRESH_TRUNC• cv2.THRESH_TOZERO• cv2.THRESH_TOZERO_INV&apos;&apos;&apos;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)titles = [&apos;Original Image&apos;, &apos;BINARY&apos;, &apos;BINARY_INV&apos;, &apos;TRUNC&apos;, &apos;TOZERO&apos;, &apos;TOZERO_INV&apos;]images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]for i in range(6): plt.subplot(2, 3, i + 1), plt.imshow(images[i], &apos;gray&apos;) plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 图像腐蚀# -*- coding: utf-8 -*-&apos;&apos;&apos;两个基本的形态学操作是腐蚀和膨胀。他们 的变体构成了开运算 ，闭运算， 梯度等。根据卷积核的大小 前景的所有像素 会 腐 掉 变为 0 ，所以前景物体会变小 整幅图像的白色区域会减少。对于去除白噪声很有用 也可以用来断开两个 在一块的物体等。&apos;&apos;&apos;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)cv2.imshow(&apos;Origin&apos;, img)print(img.shape)#您可以将内核看作是一个小矩阵，我们在图像上滑动以进行（卷积）操作，例如模糊，锐化，边缘检测或其他图像处理操作。kernel = np.ones((5, 5), np.uint8)erosion = cv2.erode(img, kernel, iterations=1)cv2.imshow(&apos;erode&apos;, erosion)cv2.moveWindow(&apos;erode&apos;, x=img.shape[1], y=0)cv2.waitKey(0)cv2.destroyAllWindows() 图像膨胀# -*- coding: utf-8 -*-&apos;&apos;&apos;与腐 相反 与卷积核对应的原图像的像素值中只 有一个是 1 中心元 素的像素值就是 1。所以 个操作会增加图像中的白色区域 前景 。一般在去 噪声时先用腐 再用膨胀。因为腐 在去掉白噪声的同时 也会使前景对 变 小。所以我们再对他 膨胀。 时噪声已经 去 了 不会再回来了 但是 前景 在并会增加。膨胀也可以用来 接两个分开的物体。&apos;&apos;&apos;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;, 0)cv2.imshow(&apos;Origin&apos;, img)print(img.shape)kernel = np.ones((5, 5), np.uint8)dilation = cv2.dilate(img, kernel, iterations=1)cv2.imshow(&apos;dilation&apos;, dilation)cv2.moveWindow(&apos;dilation&apos;, x=img.shape[1], y=0)cv2.waitKey(0)cv2.destroyAllWindows() 图像匹配# -*-coding:utf8-*-#__author__ = &apos;play4fun&apos;&quot;&quot;&quot;create time:15-10-24 下午5:46原理模板匹配是用来在一副大图中搜寻查找模版图像位置的方法。OpenCV 为 我们提供了函数 cv2.matchTemplate()。和 2D 卷积一样 它也是用模板图像在输入图像 大图 上滑动 并在每一个位置对模板图像和与其对应的 输入图像的子区域 比较。OpenCV 提供了几种不同的比较方法 细节 看 文档 。返回的结果是一个灰度图像 每一个像素值 示了此区域与模板的匹配 程度。如果输入图像的大小是 WxH模板的大小是 wxh 输出的结果 的大小就是 W-w+1 H-h+1 。当你得到这幅图之后 就可以使用函数 cv2.minMaxLoc() 来找到其中的最小值和最大值的位置了。第一个值为矩形左上角的点 位置w h 为 moban 模板矩形的宽和 。这个矩形就是 找到的模板区域了。&quot;&quot;&quot;import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&apos;../data/messi5.jpg&apos;, 0)img2 = img.copy()template = cv2.imread(&apos;../data/messi_face.jpg&apos;, 0)w, h = template.shape[::-1]# All the 6 methods for comparison in a listmethods = [&apos;cv2.TM_CCOEFF&apos;, &apos;cv2.TM_CCOEFF_NORMED&apos;, &apos;cv2.TM_CCORR&apos;, &apos;cv2.TM_CCORR_NORMED&apos;, &apos;cv2.TM_SQDIFF&apos;, &apos;cv2.TM_SQDIFF_NORMED&apos;]for meth in methods: img = img2.copy() # exec 语句用来执行储存在字符串或文件中的 Python 语句。 # 例如,我们可以在运行时生成一个包含 Python 代码的字符串, # 然后使用 exec 语句执行这些语句。 # eval 语句用来计算存储在字符串中的有效 Python 表达式 method = eval(meth) # Apply template Matching res = cv2.matchTemplate(img, template, method) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res) # 使用不同的比较方法,对结果的解释不同 # If the method is TM_SQDIFF or TM_SQDIFF_NORMED, take minimum if method in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]: top_left = min_loc else: top_left = max_loc bottom_right = (top_left[0] + w, top_left[1] + h) cv2.rectangle(img, top_left, bottom_right, 255, 2) plt.subplot(121), plt.imshow(res, cmap=&apos;gray&apos;) plt.title(&apos;Matching Result&apos;), plt.xticks([]), plt.yticks([]) plt.subplot(122), plt.imshow(img, cmap=&apos;gray&apos;) plt.title(&apos;Detected Point&apos;), plt.xticks([]), plt.yticks([]) plt.suptitle(&apos;method: &apos; + meth) plt.show() SIFT算法# -*- coding: utf-8 -*-# @Time : 2017/7/13 下午2:23# @Author : play4fun# @File : sift.py# @Software: PyCharm&quot;&quot;&quot;sift.py:尺度不变特征变换关键点 极值点 定位&quot;&quot;&quot;import cv2import numpy as npimg = cv2.imread(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)sift = cv2.xfeatures2d.SIFT_create()kp = sift.detect(gray, None)img = cv2.drawKeypoints(gray, kp, img)# 计算关键点描述符# 使用函数 sift.compute() 来 计算 些关键点的描述符。例如# kp, des = sift.compute(gray, kp)kp, des = sift.detectAndCompute(gray, None)cv2.imwrite(&apos;sift_keypoints.jpg&apos;, img)cv2.imshow(&apos;sift_keypoints.jpg&apos;, img)cv2.waitKey(0)","path":"2019/08/05/opencv-python常用函数及介绍/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"https://litianbo243.github.io/tags/opencv/"}]},{"title":"tkinter使用指南","text":"Tkinter模块元素简要说明 tkinter类 元素 Button 按钮 Canvas 画布 Checkbutton 复选框 Entry 单行文本框 Frame 框架 Label 标签 LabelFrame 容器控件 Listbox 列表框 Menu 菜单 Menubutton 菜单按钮 Message 消息框 OptionMenu 选择菜单 PanedWindow 窗口布局管理 Radiobutton 单选框 Scale 进度条 Scrollbar 滚动条 Spinbox 输入控件 Text 多行文本框 Toplevel 顶层 messageBox 消息框 Tkinter支持16个核心的窗口部件，这个16个核心窗口部件类简要描述如下：Button：一个简单的按钮，用来执行一个命令或别的操作。Canvas：组织图形。这个部件可以用来绘制图表和图，创建图形编辑器，实现定制窗口部件。Checkbutton：代表一个变量，它有两个不同的值。点击这个按钮将会在这两个值间切换。Entry：文本输入域。Frame：一个容器窗口部件。帧可以有边框和背景，当创建一个应用程序或dialog(对话）版面时，帧被用来组织其它的窗口部件。Label：显示一个文本或图象。Listbox：显示供选方案的一个列表。listbox能够被配置来得到radiobutton或checklist的行为。Menu：菜单条。用来实现下拉和弹出式菜单。Menubutton：菜单按钮。用来实现下拉式菜单。Message：显示一文本。类似label窗口部件，但是能够自动地调整文本到给定的宽度或比率。Radiobutton：代表一个变量，它可以有多个值中的一个。点击它将为这个变量设置值，并且清除与这同一变量相关的其它radiobutton。Scale：允许你通过滑块来设置一数字值。Scrollbar：为配合使用canvas, entry, listbox, and text窗口部件的标准滚动条。Text：格式化文本显示。允许你用不同的样式和属性来显示和编辑文本。同时支持内嵌图象和窗口。Toplevel：一个容器窗口部件，作为一个单独的、最上面的窗口显示。messageBox：消息框，用于显示你应用程序的消息框。(Python2中为tkMessagebox)注意在Tkinter中窗口部件类没有分级；所有的窗口部件类在树中都是兄弟关系。所有这些窗口部件提供了Misc和几何管理方法、配置管理方法和部件自己定义的另外的方法。此外，Toplevel类也提供窗口管理接口。这意味一个典型的窗口部件类提供了大约150种方法。 动手实践学习创建主窗口及Label部件的创建和使用示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定标签l = tk.Label(window, text=&apos;你好！this is Tkinter&apos;, bg=&apos;green&apos;, font=(&apos;Arial&apos;, 12), width=30, height=2)# 说明： bg为背景，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高 # 第5步，放置标签l.pack() # Label内容content区域放置位置，自动调节尺寸# 放置lable的方法有：1）l.pack(); 2)l.place(); # 第6步，主窗口循环显示window.mainloop()# 注意，loop因为是循环的意思，window.mainloop就会让window不断的刷新，如果没有mainloop,就是一个静态的window,传入进去的值就不会有循环，mainloop就相当于一个很大的while循环，有个while，每点击一次就会更新一次，所以我们必须要有循环 测试效果 Button窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定标签var = tk.StringVar() # 将label标签的内容设置为字符类型，用var来接收hit_me函数的传出内容用以显示在标签上l = tk.Label(window, textvariable=var, bg=&apos;green&apos;, fg=&apos;white&apos;, font=(&apos;Arial&apos;, 12), width=30, height=2)# 说明： bg为背景，fg为字体颜色，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高l.pack() # 定义一个函数功能（内容自己自由编写），供点击Button按键时调用，调用命令参数command=函数名on_hit = Falsedef hit_me(): global on_hit if on_hit == False: on_hit = True var.set(&apos;you hit me&apos;) else: on_hit = False var.set(&apos;&apos;) # 第5步，在窗口界面设置放置Button按键b = tk.Button(window, text=&apos;hit me&apos;, font=(&apos;Arial&apos;, 12), width=10, height=1, command=hit_me)b.pack() # 第6步，主窗口循环显示window.mainloop() 测试效果 Entry窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定输入框控件entry并放置控件e1 = tk.Entry(window, show=&apos;*&apos;, font=(&apos;Arial&apos;, 14)) # 显示成密文形式e2 = tk.Entry(window, show=None, font=(&apos;Arial&apos;, 14)) # 显示成明文形式e1.pack()e2.pack() # 第5步，主窗口循环显示window.mainloop() 测试效果 Text窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上设定输入框控件entry框并放置e = tk.Entry(window, show = None)#显示成明文形式e.pack() # 第5步，定义两个触发事件时的函数insert_point和insert_end（注意：因为Python的执行顺序是从上往下，所以函数一定要放在按钮的上面）def insert_point(): # 在鼠标焦点处插入输入内容 var = e.get() t.insert(&apos;insert&apos;, var)def insert_end(): # 在文本框内容最后接着插入输入内容 var = e.get() t.insert(&apos;end&apos;, var) # 第6步，创建并放置两个按钮分别触发两种情况b1 = tk.Button(window, text=&apos;insert point&apos;, width=10, height=2, command=insert_point)b1.pack()b2 = tk.Button(window, text=&apos;insert end&apos;, width=10, height=2, command=insert_end)b2.pack() # 第7步，创建并放置一个多行文本框text用以显示，指定height=3为文本框是三个字符高度t = tk.Text(window, height=3)t.pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 Listbox窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置var1 = tk.StringVar() # 创建变量，用var1用来接收鼠标点击具体选项的内容l = tk.Label(window, bg=&apos;green&apos;, fg=&apos;yellow&apos;,font=(&apos;Arial&apos;, 12), width=10, textvariable=var1)l.pack() # 第6步，创建一个方法用于按钮的点击事件def print_selection(): value = lb.get(lb.curselection()) # 获取当前选中的文本 var1.set(value) # 为label设置值 # 第5步，创建一个按钮并放置，点击按钮调用print_selection函数b1 = tk.Button(window, text=&apos;print selection&apos;, width=15, height=2, command=print_selection)b1.pack() # 第7步，创建Listbox并为其添加内容var2 = tk.StringVar()var2.set((1,2,3,4)) # 为变量var2设置值# 创建Listboxlb = tk.Listbox(window, listvariable=var2) #将var2的值赋给Listbox# 创建一个list并将值循环添加到Listbox控件中list_items = [11,22,33,44]for item in list_items: lb.insert(&apos;end&apos;, item) # 从最后一个位置开始加入值lb.insert(1, &apos;first&apos;) # 在第一个位置加入&apos;first&apos;字符lb.insert(2, &apos;second&apos;) # 在第二个位置加入&apos;second&apos;字符lb.delete(2) # 删除第二个位置的字符lb.pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 Radiobutton窗口控件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置var = tk.StringVar() # 定义一个var用来将radiobutton的值和Label的值联系在一起.l = tk.Label(window, bg=&apos;yellow&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义选项触发函数功能def print_selection(): l.config(text=&apos;you have selected &apos; + var.get()) # 第5步，创建三个radiobutton选项，其中variable=var, value=&apos;A&apos;的意思就是，当我们鼠标选中了其中一个选项，把value的值A放到变量var中，然后赋值给variabler1 = tk.Radiobutton(window, text=&apos;Option A&apos;, variable=var, value=&apos;A&apos;, command=print_selection)r1.pack()r2 = tk.Radiobutton(window, text=&apos;Option B&apos;, variable=var, value=&apos;B&apos;, command=print_selection)r2.pack()r3 = tk.Radiobutton(window, text=&apos;Option C&apos;, variable=var, value=&apos;C&apos;, command=print_selection)r3.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Checkbutton窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置l = tk.Label(window, bg=&apos;yellow&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义触发函数功能def print_selection(): if (var1.get() == 1) &amp; (var2.get() == 0): # 如果选中第一个选项，未选中第二个选项 l.config(text=&apos;I love only Python &apos;) elif (var1.get() == 0) &amp; (var2.get() == 1): # 如果选中第二个选项，未选中第一个选项 l.config(text=&apos;I love only C++&apos;) elif (var1.get() == 0) &amp; (var2.get() == 0): # 如果两个选项都未选中 l.config(text=&apos;I do not love either&apos;) else: l.config(text=&apos;I love both&apos;) # 如果两个选项都选中 # 第5步，定义两个Checkbutton选项并放置var1 = tk.IntVar() # 定义var1和var2整型变量用来存放选择行为返回值var2 = tk.IntVar()c1 = tk.Checkbutton(window, text=&apos;Python&apos;,variable=var1, onvalue=1, offvalue=0, command=print_selection) # 传值原理类似于radiobutton部件c1.pack()c2 = tk.Checkbutton(window, text=&apos;C++&apos;,variable=var2, onvalue=1, offvalue=0, command=print_selection)c2.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Scale窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签label用以显示并放置l = tk.Label(window, bg=&apos;green&apos;, fg=&apos;white&apos;, width=20, text=&apos;empty&apos;)l.pack() # 第6步，定义一个触发函数功能def print_selection(v): l.config(text=&apos;you have selected &apos; + v)# 第5步，创建一个尺度滑条，长度200字符，从0开始10结束，以2为刻度，精度为0.01，触发调用print_selection函数s = tk.Scale(window, label=&apos;try me&apos;, from_=0, to=10, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=2, resolution=0.01, command=print_selection)s.pack() # 第7步，主窗口循环显示window.mainloop() 测试效果 Canvas窗口部件示例代码 from PIL import Imagefrom PIL import ImageTkimport tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，在图形界面上创建 500 * 200 大小的画布并放置各种元素canvas = tk.Canvas(window, bg=&apos;green&apos;, height=200, width=500)# 说明图片位置，并导入图片到画布上image_file = Image.open(&quot;/home/ltb/timg.jpeg&quot;).resize((500, 300))image_file = ImageTk.PhotoImage(image_file)# image_file = tk.PhotoImage(file=&apos;/home/ltb/timg.gif&apos;) # 图片位置（相对路径，与.py文件同一文件夹下，也可以用绝对路径，需要给定图片具体绝对路径）image = canvas.create_image(250, 0, anchor=&apos;n&apos;, image=image_file) # 图片锚定点（n图片顶端的中间点位置）放在画布（250,0）坐标处# 定义多边形参数，然后在画布上画出指定图形x0, y0, x1, y1 = 100, 100, 150, 150line = canvas.create_line(x0 - 50, y0 - 50, x1 - 50, y1 - 50) # 画直线oval = canvas.create_oval(x0 + 120, y0 + 50, x1 + 120, y1 + 50, fill=&apos;white&apos;) # 画圆 用黄色填充arc = canvas.create_arc(x0, y0 + 50, x1, y1 + 50, start=0, extent=180) # 画扇形 从0度打开收到180度结束rect = canvas.create_rectangle(330, 30, 330 + 20, 30 + 20) # 画矩形正方形canvas.pack()# 第6步，触发函数，用来一定指定图形def moveit(): canvas.move(rect, 2, 2) # 移动正方形rect（也可以改成其他图形名字用以移动一起图形、元素），按每次（x=2, y=2）步长进行移动# 第5步，定义一个按钮用来移动指定图形的在画布上的位置b = tk.Button(window, text=&apos;move item&apos;, command=moveit).pack()# 第7步，主窗口循环显示window.mainloop()# 在一个类中创建Canvas需要把要显示再画布上的图片声明为全局变量，不然画布无法显示图片。 图像锚定点位置参数图测试效果 Menu窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，在图形界面上创建一个标签用以显示内容并放置l = tk.Label(window, text=&apos; &apos;, bg=&apos;green&apos;)l.pack()# 第10步，定义一个函数功能，用来代表菜单选项的功能，这里为了操作简单，定义的功能比较简单counter = 0def do_job(): global counter l.config(text=&apos;do &apos; + str(counter)) counter += 1# 第5步，创建一个菜单栏，这里我们可以把他理解成一个容器，在窗口的上方menubar = tk.Menu(window)# 第6步，创建一个File菜单项（默认不下拉，下拉内容包括New，Open，Save，Exit功能项）filemenu = tk.Menu(menubar, tearoff=0)# 将上面定义的空菜单命名为File，放在菜单栏中，就是装入那个容器中menubar.add_cascade(label=&apos;File&apos;, menu=filemenu)# 在File中加入New、Open、Save等小菜单，即我们平时看到的下拉菜单，每一个小菜单对应命令操作。filemenu.add_command(label=&apos;New&apos;, command=do_job)filemenu.add_command(label=&apos;Open&apos;, command=do_job)filemenu.add_command(label=&apos;Save&apos;, command=do_job)filemenu.add_separator() # 添加一条分隔线filemenu.add_command(label=&apos;Exit&apos;, command=window.quit) # 用tkinter里面自带的quit()函数# 第7步，创建一个Edit菜单项（默认不下拉，下拉内容包括Cut，Copy，Paste功能项）editmenu = tk.Menu(menubar, tearoff=0)# 将上面定义的空菜单命名为 Edit，放在菜单栏中，就是装入那个容器中menubar.add_cascade(label=&apos;Edit&apos;, menu=editmenu)# 同样的在 Edit 中加入Cut、Copy、Paste等小命令功能单元，如果点击这些单元, 就会触发do_job的功能editmenu.add_command(label=&apos;Cut&apos;, command=do_job)editmenu.add_command(label=&apos;Copy&apos;, command=do_job)editmenu.add_command(label=&apos;Paste&apos;, command=do_job)# 第8步，创建第二级菜单，即菜单项里面的菜单submenu = tk.Menu(filemenu) # 和上面定义菜单一样，不过此处实在File上创建一个空的菜单filemenu.add_cascade(label=&apos;Import&apos;, menu=submenu, underline=0) # 给放入的菜单submenu命名为Import# 第9步，创建第三级菜单命令，即菜单项里面的菜单项里面的菜单命令（有点拗口，笑~~~）submenu.add_command(label=&apos;Submenu_1&apos;, command=do_job) # 这里和上面创建原理也一样，在Import菜单项中加入一个小菜单命令Submenu_1# 第11步，创建菜单栏完成后，配置让菜单栏menubar显示出来window.config(menu=menubar)# 第12步，主窗口循环显示window.mainloop() 测试效果 Frame窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，在图形界面上创建一个标签用以显示内容并放置tk.Label(window, text=&apos;on the window&apos;, bg=&apos;red&apos;, font=(&apos;Arial&apos;, 16)).pack() # 和前面部件分开创建和放置不同，其实可以创建和放置一步完成 # 第5步，创建一个主frame，长在主window窗口上frame = tk.Frame(window)frame.pack() # 第6步，创建第二层框架frame，长在主框架frame上面frame_l = tk.Frame(frame)# 第二层frame，左frame，长在主frame上frame_r = tk.Frame(frame)# 第二层frame，右frame，长在主frame上frame_l.pack(side=&apos;left&apos;)frame_r.pack(side=&apos;right&apos;) # 第7步，创建三组标签，为第二层frame上面的内容，分为左区域和右区域，用不同颜色标识tk.Label(frame_l, text=&apos;on the frame_l1&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_l, text=&apos;on the frame_l2&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_l, text=&apos;on the frame_l3&apos;, bg=&apos;green&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r1&apos;, bg=&apos;yellow&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r2&apos;, bg=&apos;yellow&apos;).pack()tk.Label(frame_r, text=&apos;on the frame_r3&apos;, bg=&apos;yellow&apos;).pack() # 第8步，主窗口循环显示window.mainloop() 测试效果 messageBox窗口部件示例代码 import tkinter as tk # 使用Tkinter前需要先导入import tkinter.messagebox # 要使用messagebox先要导入模块 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第5步，定义触发函数功能def hit_me(): tkinter.messagebox.showinfo(title=&apos;Hi&apos;, message=&apos;你好！&apos;) # 提示信息对话窗 # tkinter.messagebox.showwarning(title=&apos;Hi&apos;, message=&apos;有警告！&apos;) # 提出警告对话窗 # tkinter.messagebox.showerror(title=&apos;Hi&apos;, message=&apos;出错了！&apos;) # 提出错误对话窗 # print(tkinter.messagebox.askquestion(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # 询问选择对话窗return &apos;yes&apos;, &apos;no&apos; # print(tkinter.messagebox.askyesno(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # return &apos;True&apos;, &apos;False&apos; # print(tkinter.messagebox.askokcancel(title=&apos;Hi&apos;, message=&apos;你好！&apos;)) # return &apos;True&apos;, &apos;False&apos; # 第4步，在图形界面上创建一个标签用以显示内容并放置tk.Button(window, text=&apos;hit me&apos;, bg=&apos;green&apos;, font=(&apos;Arial&apos;, 14), command=hit_me).pack() # 第6步，主窗口循环显示window.mainloop() 测试效果 窗口部件三种放置方式 pack/grid/placepack按上下左右的方式排列 示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，pack 放置方法tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;top&apos;) # 上tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;bottom&apos;) # 下tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;left&apos;) # 左tk.Label(window, text=&apos;P&apos;, fg=&apos;red&apos;).pack(side=&apos;right&apos;) # 右# 第5步，主窗口循环显示window.mainloop() 测试效果 grid所有的内容会被放在这些规律的方格中 示例代码 import tkinter as tk # 使用Tkinter前需要先导入# 第1步，实例化object，建立窗口windowwindow = tk.Tk()# 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;)# 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x# 第4步，grid 放置方法for i in range(3): for j in range(3): tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10, ipadx=10, ipady=10)# 第5步，主窗口循环显示window.mainloop() 测试效果 place给精确的坐标来定位 示例代码 import tkinter as tk # 使用Tkinter前需要先导入 # 第1步，实例化object，建立窗口windowwindow = tk.Tk() # 第2步，给窗口的可视化起名字window.title(&apos;My Window&apos;) # 第3步，设定窗口的大小(长 * 宽)window.geometry(&apos;500x300&apos;) # 这里的乘是小x # 第4步，place 放置方法（精准的放置到指定坐标点的位置上）tk.Label(window, text=&apos;Pl&apos;, font=(&apos;Arial&apos;, 20), ).place(x=50, y=100, anchor=&apos;nw&apos;) # 第5步，主窗口循环显示window.mainloop() 测试效果 Tkinter布局之pack我们使用pack函数的时候，默认先使用的放在上面，然后依次向下排，它会给我们的部件一个自认为合适的位置和大小，这是默认方式。 side 按钮停靠的位置left：左top：上right：右bottom：下 fill 填充x：水平方向填充y：竖直方向填充both：水平和竖直方向填充none：不填充 expand 扩展yes：扩展整个空白区no：不扩展 部件消除示例代码 # 销毁上一个布局的frame及其部件# 先销毁frame下的部件，再销毁framefor widget in self.last_frame.winfo_children(): widget.destroy()self.last_frame.destroy() 多线程按钮部件示例代码 # 打开摄像头button_open_camera = tk.Button(self.frame_3, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading)button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;)# 关闭摄像头button_close_camera = tk.Button(self.frame_3, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera)button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;)# 线程函数def camera_threading(self): self.thread = threading.Thread(target=self.open_camera) self.thread.setDaemon(True) self.thread.start() # 打开摄像头函数，被线程函数调用def open_camera(self): try: cap = cv2.VideoCapture(0) self.thread_flag = True while(self.thread_flag): ret, frame = cap.read() cv2.imshow(&quot;video&quot;, frame) cv2.imwrite(self.temporary_path, frame) if ret != True: break c = cv2.waitKey(60) if c == 27: break cv2.destroyAllWindows() cap.release() except: messagebox.showerror(title=&quot;读取视频出错&quot;, message=&quot;读取出错或未检测到usb摄像头&quot;) # 关闭摄像头函数，用全局变量控制def close_camera(self): self.thread_flag = False os._exit(0) 第一个Tkinter程序from PIL import Imagefrom PIL import ImageTkimport tkinter as tkfrom tkinter import filedialog, messageboximport threadingimport cv2import osimport shutilfrom datetime import datetimeclass AppUI(): def __init__(self): # 全局变量 self.first = True self.last_frame = None self.thread_flag = False self.temporary_path = &quot;/mnt/tkinter_pj1/temporary_picture.jpg&quot; self.database = &quot;/mnt/tkinter_pj1/Images/all&quot; # 存线程实例 self.thread_obj = [] # 创建窗口 self.window = tk.Tk() self.window.title(&quot;手术器械自动识别系统&quot;) self.window.geometry(&quot;500x200&quot;) # 参数 self.main_menu() self.main_layout() self.window.mainloop() # 主菜单 def main_menu(self): self.menu_bar = tk.Menu(self.window) self.start_menu = tk.Menu(self.menu_bar, tearoff=0) self.menu_bar.add_cascade(label=&quot;开始&quot;, menu=self.start_menu) self.start_menu.add_command(label=&quot;首页&quot;, command=self.main_layout) self.start_menu.add_command(label=&quot;单张图像预测&quot;, command=self.layout_2) self.start_menu.add_command(label=&quot;实时图像检测&quot;, command=self.layout_3) self.start_menu.add_command(label=&quot;图像采集&quot;, command=self.layout_4) self.window.config(menu=self.menu_bar) def main_layout(self): if self.first == False: # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;500x200&quot;) self.first = False self.main_frame = tk.Frame(self.window) self.main_frame.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.main_frame label_main_frame_title = tk.Label(self.main_frame, text=&apos;欢迎来到手术器械自动识别系统&apos;, font=(&apos;Arial&apos;, 17), height=3) label_main_frame_title.pack(side=&quot;top&quot;, fill=&quot;both&quot;) # 三个button button_single_predict = tk.Button(self.main_frame, text=&apos;单张图像识别&apos;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_2) button_single_predict.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) button_realtime_predict = tk.Button(self.main_frame, text=&quot;实时图像识别&quot;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_3) button_realtime_predict.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) button_catch_picture = tk.Button(self.main_frame, text=&quot;图像采集&quot;, font=(&apos;Arial&apos;, 15), width=10, height=3, command=self.layout_4) button_catch_picture.pack(side=&quot;left&quot;, expand=&quot;yes&quot;, fill=&quot;both&quot;) def layout_2(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) # 创建frame_2 self.frame_2 = tk.Frame(self.window) self.frame_2.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_2 label_frame_2_title = tk.Label(self.frame_2, text=&apos;单张图像识别&apos;, font=(&apos;Arial&apos;, 15), height=3, width=30) label_frame_2_title.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_2, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 选择路径 button_picture_path = tk.Button(self.frame_2, text=&quot;选择路径&quot;, height=3, command=self.select_picture_path) button_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 路径 label_picture_path = tk.Label(self.frame_2, text=&quot;图片路径&quot;, height=3) label_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_picture_path = tk.Entry(self.frame_2, show=None) self.entry_picture_path.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_predict_result = tk.Entry(self.frame_2, show=None) self.entry_predict_result.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) button_predict_picture = tk.Button(self.frame_2, text=&quot;图片预测&quot;, height=3, command=self.predict_picture) button_predict_picture.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def layout_3(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) self.frame_3 = tk.Frame(self.window) self.frame_3.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_3 label_frame_3_title = tk.Label(self.frame_3, text=&apos;实时图像识别&apos;, font=(&apos;Arial&apos;, 15), height=3, width=30) label_frame_3_title.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_3, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 打开摄像头 button_open_camera = tk.Button(self.frame_3, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading) button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 关闭摄像头 button_close_camera = tk.Button(self.frame_3, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera) button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) self.entry_realtime_result = tk.Entry(self.frame_3, show=None) self.entry_realtime_result.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) button_realtime_prediction = tk.Button(self.frame_3, text=&quot;实时检测&quot;, height=3, command=self.realtime_prediction) button_realtime_prediction.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def layout_4(self): # 销毁上一个layout的frame及其控件 for widget in self.last_frame.winfo_children(): widget.destroy() self.last_frame.destroy() self.window.geometry(&quot;800x555&quot;) self.frame_4 = tk.Frame(self.window) self.frame_4.pack(expand=&quot;yes&quot;, fill=&quot;both&quot;) self.last_frame = self.frame_4 label = tk.Label(self.frame_4, text=&apos;图像采集&apos;, font=(&apos;Arial&apos;, 15), width=30, height=3) label.pack(side=&quot;top&quot;) # 显示图片 self.canvas = tk.Canvas(self.frame_4, height=480, width=640) self.canvas.pack(side=&quot;left&quot;) # 打开摄像头 button_open_camera = tk.Button(self.frame_4, text=&quot;打开摄像头&quot;, height=3, command=self.camera_threading) button_open_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) # 关闭摄像头 button_close_camera = tk.Button(self.frame_4, text=&quot;关闭摄像头&quot;, height=3, command=self.close_camera) button_close_camera.pack(side=&quot;top&quot;, fill=&quot;x&quot;) button_picture_capture = tk.Button(self.frame_4, text=&quot;图片采集&quot;, height=3, command=self.picture_capture) button_picture_capture.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) self.entry_input_label = tk.Entry(self.frame_4, show=None, text=&quot;&quot;) self.entry_input_label.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) label_input_label = tk.Label(self.frame_4, text=&quot;输入类别&quot;) label_input_label.pack(side=&quot;bottom&quot;, fill=&quot;x&quot;) def select_picture_path(self): self.pic_path = filedialog.askopenfilename() self.entry_picture_path.delete(0, &quot;end&quot;) self.entry_picture_path.insert(0, self.pic_path) self.show_picture(self.pic_path) def show_picture(self, path): try: self.picture = Image.open(path).resize((640, 480)) self.picture = ImageTk.PhotoImage(self.picture) self.canvas.create_image(0, 0, anchor=&quot;nw&quot;, image=self.picture) except: messagebox.showerror(title=&quot;路径错误&quot;, message=&quot;路径输入错误或选中文件不是图片&quot;) def open_camera(self): try: cap = cv2.VideoCapture(0) self.thread_flag = True while(self.thread_flag): ret, frame = cap.read() cv2.imshow(&quot;video&quot;, frame) cv2.imwrite(self.temporary_path, frame) if ret != True: break c = cv2.waitKey(60) if c == 27: break cv2.destroyAllWindows() cap.release() except: messagebox.showerror(title=&quot;读取视频出错&quot;, message=&quot;读取出错或未检测到usb摄像头&quot;) def close_camera(self): self.thread_flag = False os._exit(0) def realtime_prediction(self): self.show_picture(self.temporary_path) pass def predict_picture(self): self.entry_predict_result.delete(0, &quot;end&quot;) self.entry_predict_result.insert(0, 0) pass def picture_capture(self): content = self.entry_input_label.get() if len(content) &gt; 0: time_stamp = &apos;&#123;:%Y-%m-%d-%H-%M-%S&#125;&apos;.format(datetime.now()) sub_class_folder = os.path.join(self.database, str(self.entry_input_label.get())) if not os.path.exists(sub_class_folder): os.mkdir(sub_class_folder) image_store_path = os.path.join(sub_class_folder, &apos;&#123;&#125;_&#123;&#125;.jpg&apos;.format(str(self.entry_input_label.get()), time_stamp)) if self.thread_flag: self.show_picture(self.temporary_path) shutil.copy(self.temporary_path, image_store_path) messagebox.showinfo(title=&quot;成功&quot;, message=&quot;成功保存图片&quot;) else: messagebox.showwarning(title=&quot;警告&quot;, message=&quot;未打开摄像头&quot;) else: messagebox.showwarning(title=&quot;警告&quot;, message=&quot;请输入类别号&quot;) def camera_threading(self): self.thread = threading.Thread(target=self.open_camera) self.thread.setDaemon(True) self.thread.start()if __name__ == &quot;__main__&quot;: app = AppUI()pyinstaller 打包 # 安装pyinstallsudo pip3 install pyinstaller# 切换到需要打包的目录，执行pyinstaller -F -W GUI.py# -F: 只生成耦合可执行的文件# -W: 表示窗口，无控制台# 生成的可执行文件就在目录dist中# 修改图标-i icon.ico 或者 --icon.ico# 图片放在需要打包的文件同目录中 参考本文参考以下网站、博客http://www.cnblogs.com/shwee/p/9427975.htmlhttps://blog.csdn.net/yingshukun/article/details/78838395http://www.cnblogs.com/kongzhagen/p/6144588.html","path":"2019/08/05/Tkinter使用指南/","date":"08-05","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://litianbo243.github.io/tags/python/"},{"name":"tkinter","slug":"tkinter","permalink":"https://litianbo243.github.io/tags/tkinter/"}]},{"title":"pytorch常用函数","text":"Tensor基本操作Tensor的基本数据类型torch.Tensor是一种包含单一数据类型元素的多维矩阵。Torch定义了七种CPU tensor类型和八种GPU tensor类型：| Data type | CPU tensor | GPU tensor ||:—-|:—-|:—-|| 32-bit floating point | torch.FloatTensor | torch.cuda.FloatTensor || 64-bit floating point | torch.DoubleTensor | torch.cuda.DoubleTensor || 16-bit floating point | N/A | torch.cuda.HalfTensor || 8-bit integer (unsigned) | torch.ByteTensor | torch.cuda.ByteTensor || 8-bit integer (signed) | torch.CharTensor | torch.cuda.CharTensor || 16-bit integer (signed) | torch.ShortTensor | torch.cuda.ShortTensor || 32-bit integer (signed) | torch.IntTensor | torch.cuda.IntTensor || 64-bit integer (signed) | torch.LongTensor | torch.cuda.LongTensor | import torchimport numpy as npt = torch.FloatTensor([[1, 2, 3], [4, 5, 6]])print(t.dtype)print(t) Tensor数据类型的转化import torchimport numpy as np# 默认数据类型为float32t = torch.Tensor(3, 5)print(t.dtype, &quot;\\n&quot;)# t.double()将该tensor投射为double类型double_t = t.double()print(double_t.dtype)# t.float()将该tensor投射为float类型float_t = t.float()print(float_t.dtype)# t.half()将tensor投射为半精度浮点类型half_t = t.half()print(half_t.dtype)# t.long() 将tensor投射为long类型long_t = t.long()print(long_t.dtype)# t.int()将该tensor投射为int类型int_t = t.int()print(int_t.dtype)# t.short()将该tensor投射为short类型short_t = t.short()print(short_t.dtype)# t.char()将该tensor投射为char类型char_t = t.char()print(char_t.dtype)# t.byte()将该tensor投射为byte类型byte_t = t.byte()print(byte_t.dtype)# t.cuda()将tensor投射为gputensorgpu_t = t.cuda()print(gpu_t.dtype) Tensor与numpy的相互转换import torchimport numpy as npa = np.array([1, 2, 3])t = torch.from_numpy(a)print(t)t[0] = -1a = t.numpy()print(a) Tensor拼接操作import torchimport numpy as npx = torch.randn(2, 3)print(x)x0 = torch.cat((x, x, x), 0)print(x0)x1 = torch.cat((x, x, x), 1)print(x1) Tensor进行分块import torchimport numpy as npx = torch.randn(2, 3)print(x)x = torch.chunk(x, 2, 0)print(x) Tensor进行挤压import torchimport numpy as npx = torch.zeros(2, 1, 2, 1, 2)print(x.size())y = torch.squeeze(x)print(y.size())y = torch.squeeze(x, 0)print(y.size())y = torch.squeeze(x, 1)print(y.size()) Tensor进行扩增import torchimport numpy as npx = torch.zeros(2, 2, 2)print(x.size())y = torch.unsqueeze(x, 0)print(y.size())y = torch.unsqueeze(x, 1)print(y.size()) Tensor进行转置import torchimport numpy as npx = torch.randn(2, 3)print(x)x = torch.transpose(x, 0, 1)print(x) Tensor进行view操作相当于numpy中resize（）的功能，但是用法可能不太一样。 把原先tensor中的数据按照行优先的顺序排成一个一维的数据（这里应该是因为要求地址是连续存储的），然后按照参数组合成其他维度的tensor。比如说是不管你原先的数据是[[[1,2,3],[4,5,6]]]还是[1,2,3,4,5,6]，因为它们排成一维向量都是6个元素，所以只要view后面的参数一致，得到的结果都是一样的。比如， a=torch.Tensor([[[1,2,3],[4,5,6]]])b=torch.Tensor([1,2,3,4,5,6])print(a.view(1,6))print(b.view(1,6)) 得到的结果都是tensor([[1., 2., 3., 4., 5., 6.]]) a=torch.Tensor([[[1,2,3],[4,5,6]]])print(a.view(3,2))&apos;&apos;&apos;tensor([[1., 2.], [3., 4.], [5., 6.]])&apos;&apos;&apos; 随机种子import torchimport numpy as nptorch.manual_seed(0)x = torch.randn(2, 3)print(x)torch.manual_seed(0)x = torch.randn(2, 3)print(x) 序列化当提到保存和加载模型时，有三个核心功能需要熟悉：1.torch.save：将序列化的对象保存到disk。这个函数使用Python的pickle实用程序进行序列化。使用这个函数可以保存各种对象的模型、张量和字典。2.torch.load：使用pickle unpickle工具将pickle的对象文件反序列化为内存。3.torch.nn.Module.load_state_dict:使用反序列化状态字典加载model’s参数字典。 什么是state_dictimport torchimport torch.nn as nnimport torch.nn.functional as F# Define modelclass TheModelClass(nn.Module): def __init__(self): super(TheModelClass, self).__init__() self.conv1 = nn.Conv2d(3, 6, 5) self.pool = nn.MaxPool2d(2, 2) self.conv2 = nn.Conv2d(6, 16, 5) self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def farward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16 * 5 * 5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x# Initialize modelmodel = TheModelClass()# Initialize optimizeroptimizer = torch.optim.SGD(model.parameters(), lr=1e-4, momentum=0.9)print(&quot;Model&apos;s state_dict:&quot;)# Print model&apos;s state_dictfor param_tensor in model.state_dict(): print(param_tensor, &quot;\\t&quot;, model.state_dict()[param_tensor].size())print(&quot;optimizer&apos;s state_dict:&quot;)# Print optimizer&apos;s state_dictfor var_name in optimizer.state_dict(): print(var_name, &quot;\\t&quot;, optimizer.state_dict()[var_name]) 保存读取模型# 只保存模型的学习参数torch.save(model.state_dict(), PATH)# 读取模型的可学习参数model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH))model.eval() # 保存整个模型torch.save(the_model, PATH)# 读取整个模型the_model = torch.load(PATH)model.eval() # 序列化字典# savetorch.save(&#123; &apos;epoch&apos;: epoch, &apos;model_state_dict&apos;: model.state_dict(), &apos;optimizer_state_dict&apos;: optimizer.state_dict(), &apos;loss&apos;: loss, ... &#125;, PATH) # loadmodel = TheModelClass(*args, **kwargs)optimizer = TheOptimizerClass(*args, **kwargs)checkpoint = torch.load(PATH)model.load_state_dict(checkpoint[&apos;model_state_dict&apos;])optimizer.load_state_dict(checkpoint[&apos;optimizer_state_dict&apos;])epoch = checkpoint[&apos;epoch&apos;]loss = checkpoint[&apos;loss&apos;]model.eval()# - or -model.train() 数学操作夹紧操作import torchimport numpy as npa = torch.randn(4)print(a)a = torch.clamp(a, min=-0.5, max=0.5)print(a) 沿维度计算和import torchimport numpy as npa = torch.randn(10)print(a)a = torch.cumsum(a, dim=0)print(a)print(a[-1]) 计算元素均值import torchimport numpy as npa = torch.randn(2, 2)print(a)b = torch.mean(a)print(b)b = torch.mean(a, 1)print(b) 计算元素标准差import torchimport numpy as npa = torch.randn(2, 2)print(a)b = torch.std(a)print(b)b = torch.std(a, dim=1)print(b) 计算所有元素和import torchimport numpy as npa = torch.randn(2, 2)print(a)b = torch.sum(a)print(b)b = torch.sum(a, dim=0)print(b) torch.nn容器torch.nn.Module是所有网络的基类。你的模型也应该继承这个类。Modules也可以包含其它Modules,允许使用树结构嵌入他们。你可以将子模块赋值给模型属性。 import torch.nn as nnimport torch.nn.functional as Fclass Model(nn.Module): def __init__(self): super(Model, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5) # submodule: Conv2d self.conv2 = nn.Conv2d(20, 20, 5) def forward(self, x): x = F.relu(self.conv1(x)) return F.relu(self.conv2(x)) 时序容器# Example of using Sequentialmodel = nn.Sequential( nn.Conv2d(1,20,5), nn.ReLU(), nn.Conv2d(20,64,5), nn.ReLU() ) # Example of using Sequential with OrderedDictmodel = nn.Sequential(OrderedDict([ (&apos;conv1&apos;, nn.Conv2d(1,20,5)), (&apos;relu1&apos;, nn.ReLU()), (&apos;conv2&apos;, nn.Conv2d(20,64,5)), (&apos;relu2&apos;, nn.ReLU()) ])) 卷积层Conv2dclass torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) 参数kernel_size，stride,padding，dilation也可以是一个int的数据，此时卷积height和width值相同;也可以是一个tuple数组，tuple的第一维度表示height的数值，tuple的第二维度表示width的数值。 in_channels(int) – 输入信号的通道 out_channels(int) – 卷积产生的通道 kerner_size(int or tuple) - 卷积核的尺寸 stride(int or tuple, optional) - 卷积步长 padding(int or tuple, optional) - 输入的每一条边补充0的层数 dilation(int or tuple, optional) – 卷积核元素之间的间距 groups(int, optional) – 从输入通道到输出通道的阻塞连接数 bias(bool, optional) - 如果bias=True，添加偏置import torch.nn as nnimport torchm = nn.Conv2d(16, 33, 3, stride=2)m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))input = torch.Tensor(torch.randn(20, 16, 50, 100))output = m(input)print(output) # 空洞卷积import torch.nn as nnimport torchm = nn.Conv2d(16, 33, kernel_size=3, stride=1, padding=2, dilation=2)input = torch.Tensor(torch.randn(20, 16, 100, 100))print(input.size())output = m(input)print(output.size()) ConvTranspose2dclass torch.nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True) 注意，这上面的stride、padding是争对于与原始卷积上的stride和padding2维的转置卷积操作（transposed convolution operator，注意改视作操作可视作解卷积操作，但并不是真正的解卷积操作） 该模块可以看作是Conv2d相对于其输入的梯度，有时（但不正确地）被称为解卷积操作。 由于内核的大小，输入的最后的一些列的数据可能会丢失。因为输入和输出是不是完全的互相关。因此，用户可以进行适当的填充（padding操作）。 in_channels(int) – 输入信号的通道数 out_channels(int) – 卷积产生的通道数 kerner_size(int or tuple) - 卷积核的大小 stride(int or tuple,optional) - 卷积步长 padding(int or tuple, optional) - 输入的每一条边补充0的层数 output_padding(int or tuple, optional) - 输出的每一条边补充0的层数 dilation(int or tuple, optional) – 卷积核元素之间的间距 groups(int, optional) – 从输入通道到输出通道的阻塞连接数 bias(bool, optional) - 如果bias=True，添加偏置import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 16, 64, 64))print(input.size())m = nn.ConvTranspose2d(16, 33, 3, stride=2, padding=1, output_padding=1)output = m(input)print(output.size()) 池化层Maxpool2dclass torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False) kernel_size(int or tuple) - max pooling的窗口大小 stride(int or tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size padding(int or tuple, optional) - 输入的每一条边补充0的层数 dilation(int or tuple, optional) – 一个控制窗口中元素步幅的参数 return_indices - 如果等于True，会返回输出最大值的序号，对于上采样操作会有帮助 ceil_mode - 如果等于True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 16, 64, 64))print(input.size())m = nn.MaxPool2d(3, stride=2)output = m(input)print(output.size())input = torch.Tensor(torch.randn(1, 3, 4, 4))print(input)m = nn.MaxPool2d(2, stride=2, return_indices=True)output, indices = m(input)print(indices) MaxUnpool2dclass torch.nn.MaxUnpool2d(kernel_size, stride=None, padding=0) Maxpool2d的逆过程，不过并不是完全的逆过程，因为在maxpool2d的过程中，一些最大值的已经丢失。 MaxUnpool2d的输入是MaxPool2d的输出，包括最大值的索引，并计算所有maxpool2d过程中非最大值被设置为零的部分的反向。 kernel_size(int or tuple) - max pooling的窗口大小 stride(int or tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size padding(int or tuple, optional) - 输入的每一条边补充0的层数import torch.nn as nnimport torchpool = nn.MaxPool2d(2, stride=2, return_indices=True)unpool = nn.MaxUnpool2d(2, stride=2)input = torch.Tensor([[[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]]])output, indices = pool(input)result = unpool(output, indices)print(result) AvgPool2dclass torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True) kernel_size(int or tuple) - 池化窗口大小 stride(int or tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size padding(int or tuple, optional) - 输入的每一条边补充0的层数 dilation(int or tuple, optional) – 一个控制窗口中元素步幅的参数 ceil_mode - 如果等于True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作 count_include_pad - 如果等于True，计算平均池化时，将包括padding填充的0import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 9, 9))m = nn.AvgPool2d(3, stride=2)output = m(input)print(output.size()) AdaptiveMaxPool2dclass torch.nn.AdaptiveMaxPool2d(output_size, return_indices=False) 对输入信号，提供2维的自适应最大池化操作 对于任何输入大小的输入，可以将输出尺寸指定为H*W，但是输入和输出特征的数目不会变化。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 9, 9))m = nn.AdaptiveMaxPool2d((3, 3))output = m(input)print(output.size()) 非线性激活函数ReLUclass torch.nn.ReLU(inplace=False) 对输入运用修正线性单元函数{ReLU}(x)= max(0, x) import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.ReLU(inplace=True)output = m(input)print(input)print(output) ELUclass torch.nn.ELU(alpha=1.0, inplace=False) 对输入的每一个元素运用函数f(x) = max(0,x) + min(0, alpha * (e^x - 1)) import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.ELU(inplace=False)output = m(input)print(output) PReLUclass torch.nn.PReLU(num_parameters=1, init=0.25)对输入的每一个元素运用函数PReLU(x) = max(0,x) + a * min(0,x)a是一个可学习参数。当没有声明时，nn.PReLU()在所有的输入中只有一个参数a；如果是nn.PReLU(nChannels)，a将应用到每个输入。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.PReLU()output = m(input)print(output) LeakyReLUclass torch.nn.LeakyReLU(negative_slope=0.01, inplace=False) 对输入的每一个元素运用f(x) = max(0, x) + {negative_slope} * min(0, x) import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.LeakyReLU()output = m(input)print(output) Thresholdclass torch.nn.Threshold(threshold, value, inplace=False) y=x,if x&gt;=threshold y=value,if x&lt;threshold import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Threshold(0.1, 20)output = m(input)print(output) Sigmoidclass torch.nn.Sigmoid import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Sigmoid()output = m(input)print(output) Tanhclass torch.nn.Tanh import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Tanh()output = m(input)print(output) Softmaxclass torch.nn.Softmax对n维输入张量运用Softmax函数，将张量的每个元素缩放到（0,1）区间且和为1。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 7))print(input)m = nn.Softmax(dim=1)output = m(input)print(output) 标准化层BatchNorm2dclass torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True) 对小批量(mini-batch)3d数据组成的4d输入进行批标准化(Batch Normalization)操作在每一个小批量（mini-batch）数据中，计算输入各个维度的均值和标准差。gamma与beta是可学习的大小为C的参数向量（C为输入大小）在训练时，该层计算每次输入的均值与方差，并进行移动平均。移动平均默认的动量值为0.1。在验证时，训练求得的均值/方差将用于标准化验证数据。 num_features： 来自期望输入的特征数，该期望输入的大小为’batch_size x num_features x height x width’ eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。 momentum： 动态均值和动态方差所使用的动量。默认为0.1。 affine： 一个布尔值，当设为true，给该层添加可学习的仿射变换参数。import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 100, 3, 3))print(input)m = nn.BatchNorm2d(100)output = m(input)print(output) 线性层Linearclass torch.nn.Linear(in_features, out_features, bias=True)对输入数据做线性变换：y=Ax+b in_features - 每个输入样本的大小 out_features - 每个输出样本的大小 bias - 若设置为False，这层不会学习偏置。默认值：Trueimport torch.nn as nnimport torchinput = torch.Tensor(torch.randn(20, 20))print(input.size())m = nn.Linear(20, 30)output = m(input)print(output.size()) Dropout层Dropoutclass torch.nn.Dropout(p=0.5, inplace=False) 随机将输入张量中部分元素设置为0。对于每次前向调用，被置0的元素都是随机的。 p - 将元素置0的概率。默认值：0.5 in-place - 若设置为True，会在原地执行操作。默认值：Falseimport torch.nn as nnimport torchinput = torch.Tensor(torch.randn(3, 6))print(input)m = nn.Dropout(p=0.5)output = m(input)print(output) Droupout2dclass torch.nn.Dropout2d(p=0.5, inplace=False) 随机将输入张量中整个通道设置为0。对于每次前向调用，被置0的通道都是随机的。 import torch.nn as nnimport torchinput = torch.Tensor(torch.randn(1, 3, 3, 3))print(input)m = nn.Dropout2d(p=0.5)output = m(input)print(output) 损失函数基本用法： criterion = LossCriterion() #构造函数有自己的参数loss = criterion(x, y) #调用标准时也有参数 计算出来的结果已经对mini-batch取了平均。 MSELossclass torch.nn.MSELoss(size_average=True)创建一个衡量输入x(模型预测输出)和目标y之间均方误差标准。 import torch.nn as nnimport torchinput1 = torch.Tensor(torch.randn(1, 8))print(input1)input2 = torch.Tensor(torch.rand(1, 8))print(input2)criterion = nn.MSELoss()loss = criterion(input1, input2)print(loss) CrossEntropyLossclass torch.nn.CrossEntropyLoss(weight=None, size_average=True) 此标准将LogSoftMax和NLLLoss集成到一个类中。不需要再使用softmax。 weight(tensor): 1-D tensor，n个元素，分别代表n类的权重，如果你的训练样本很不均衡的话，是非常有用的。默认值为None。 input : 包含每个类的得分，３-D tensor,shape为 batchn样例数 target: 大小为 n 的 ２-D tensor，包含类别的索引(0到 n-1)，long型。 import torch.nn as nnimport torch# batchsize=3, 二分类, 8个样例input = torch.Tensor(torch.randn(2, 3, 3, 3))print(input)# target为long型target = torch.Tensor(torch.zeros(2, 3, 3)).long()target[0, 0, 0] = 2target[1, 1, 1] = 1target[1, 2, 2] = 1print(target)criterion = nn.CrossEntropyLoss()loss = criterion(input, target)print(loss) BCELossclass torch.nn.BCELoss(weight=None, size_average=True) 计算 target 与 output 之间的二进制交叉熵。 import torch.nn as nnimport torch# 二进制交叉商，用0和1来表示类别criterion = nn.BCELoss(reduction=&quot;none&quot;)input = torch.Tensor(torch.randn(2, 3, 3))m = nn.Sigmoid()input = m(input)print(input)target = torch.Tensor(torch.ones(2, 3, 3))target[0, 0, 0] = 0target[1, 1, 1] = 0target[1, 2, 2] = 0print(target)loss = criterion(input, target)print(loss.mean()) 视觉函数PixelShuffleclass torch.nn.PixelShuffle(upscale_factor) 将shape为$[N, Cr^2, H, W]$的Tensor重新排列为shape为$[N, C, Hr, W*r]$的Tensor。 当使用stride=1/r 的sub-pixel卷积的时候，这个方法是非常有用的。 import torch.nn as nnimport torchps = nn.PixelShuffle(3)input = torch.Tensor(torch.randn(1, 9, 4, 4))print(input.size())output = ps(input)print(output.size()) UpsamplingNearest2dclass torch.nn.UpsamplingNearest2d(size=None, scale_factor=None) 对于多channel 输入 进行 2-D 最近邻上采样。可以通过size或者scale_factor来指定上采样后的图片大小。当给定size时，size的值将会是输出图片的大小。 size (tuple, optional) – 一个包含两个整数的元组 (H_out, W_out)指定了输出的长宽 scale_factor (int, optional) – 长和宽的一个乘子import torch.nn as nnimport torchm = nn.UpsamplingNearest2d(scale_factor=2)input = torch.Tensor(torch.randn(1, 1, 2, 2))print(input)output = m(input)print(output) UpsamplingBilinear2dclass torch.nn.UpsamplingBilinear2d(size=None, scale_factor=None) import torch.nn as nnimport torchm = nn.UpsamplingBilinear2d(scale_factor=2)input = torch.Tensor(torch.randn(1, 1, 2, 2))print(input)output = m(input)print(output) 多GPU模块并行DataParallelclass torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0) 在模块级别上实现数据并行。此容器通过将mini-batch划分到不同的设备上来实现给定module的并行。在forward过程中，module会在每个设备上都复制一遍，每个副本都会处理部分输入。在backward过程中，副本上的梯度会累加到原始module上。batch的大小应该大于所使用的GPU的数量。还应当是GPU个数的整数倍，这样划分出来的每一块都会有相同的样本数量。 module – 要被并行的module device_ids – CUDA设备，默认为所有设备。 output_device – 输出设备（默认为device_ids[0]）net = torch.nn.DataParallel(model, device_ids=[0, 1, 2])output = net(input_var) 优化器为了构建一个Optimizer，你需要给它一个包含了需要优化的参数（必须都是Variable对象）的iterable。然后，你可以设置optimizer的参 数选项，比如学习率，权重衰减，等等。 optimizer = optim.SGD(model.parameters(), lr = 0.01, momentum=0.9)optimizer = optim.Adam([var1, var2], lr = 0.0001) 当我们想指定每一层的学习率时 optim.SGD([ &#123;&apos;params&apos;: model.base.parameters()&#125;, &#123;&apos;params&apos;: model.classifier.parameters(), &apos;lr&apos;: 1e-3&#125; ], lr=1e-2, momentum=0.9) 这意味着model.base的参数将会使用1e-2的学习率，model.classifier的参数将会使用1e-3的学习率，并且0.9的momentum将会被用于所有的参数。 所有的optimizer都实现了step()方法，这个方法会更新所有的参数。 optimizer.step()这是大多数optimizer所支持的简化版本。一旦梯度被如backward()之类的函数计算好后，我们就可以调用这个函数。 for input, target in dataset: optimizer.zero_grad() output = model(input) loss = loss_fn(output, target) loss.backward() optimizer.step() Optimizerclass torch.optim.Optimizer(params, defaults) [source] Base class for all optimizers. params (iterable) —— Variable 或者 dict的iterable。指定了什么参数应当被优化。 defaults —— (dict)：包含了优化选项默认值的字典（一个参数组没有指定的参数选项将会使用默认值）。 Adamclass torch.optim.Adam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0)[source] params (iterable) – 待优化参数的iterable或者是定义了参数组的dict lr (float, 可选) – 学习率（默认：1e-3） betas (Tuple[float, float], 可选) – 用于计算梯度以及梯度平方的运行平均值的系数（默认：0.9，0.999） eps (float, 可选) – 为了增加数值计算的稳定性而加到分母里的项（默认：1e-8） weight_decay (float, 可选) – 权重衰减（L2惩罚）（默认: 0） SGDclass torch.optim.SGD(params, lr=, momentum=0, dampening=0, weight_decay=0, nesterov=False)[source] 实现随机梯度下降算法（momentum可选） params (iterable) – 待优化参数的iterable或者是定义了参数组的dict lr (float) – 学习率 momentum (float, 可选) – 动量因子（默认：0） weight_decay (float, 可选) – 权重衰减（L2惩罚）（默认：0） dampening (float, 可选) – 动量的抑制因子（默认：0） nesterov (bool, 可选) – 使用Nesterov动量（默认：False）import torch.optim as optimoptimizer = optim.SGD(model.parameters(), lr=0.1, momentum=0.9)optimizer.zero_grad()loss_fn(model(input), target).backward()optimizer.step() 数据集抽象类torch.utils.dataclass torch.utils.data.Dataset表示Dataset的抽象类。所有其他数据集都应该进行子类化。所有子类应该override__len__和getitem，前者提供了数据集的大小，后者支持整数索引，范围从0到len(self)。 DataLoaderclass torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, num_workers=0, collate_fn=, pin_memory=False, drop_last=False) 数据加载器。组合数据集和采样器，并在数据集上提供单进程或多进程迭代器。 dataset (Dataset) – 加载数据的数据集。 batch_size (int, optional) – 每个batch加载多少个样本(默认: 1)。 shuffle (bool, optional) – 设置为True时会在每个epoch重新打乱数据(默认: False). sampler (Sampler, optional) – 定义从数据集中提取样本的策略。如果指定，则忽略shuffle参数。 num_workers (int, optional) – 用多少个子进程加载数据。0表示数据将在主进程中加载(默认: 0) collate_fn (callable, optional) – pin_memory (bool, optional) – drop_last (bool, optional) – 如果数据集大小不能被batch size整除，则设置为True后可删除最后一个不完整的batch。如果设为False并且数据集的大小不能被batch size整除，则最后一个batch将更小。(默认: False)torchvisiontorchvision.datasetstorchvision.datasets中包含了以下数据集 MNIST COCO（用于图像标注和目标检测）(Captioning and Detection) LSUN Classification ImageFolder Imagenet-12 CIFAR10 and CIFAR100 STL10 Datasets 拥有以下API:getitem len由于以上Datasets都是 torch.utils.data.Dataset的子类，所以，他们也可以通过torch.utils.data.DataLoader使用多线程（python的多进程）。 MNISTfrom torchvision import datasetsroot = &quot;/home/ltb/MNIST&quot;datasets.MNIST(root, train=True, transform=None, target_transform=None, download=True) 参数说明： root : processed/training.pt 和 processed/test.pt 的主目录 train : True = 训练集, False = 测试集 download : True = 从互联网上下载数据集，并把数据集放在root目录下. 如果数据集之前下载过，将处理过的数据（minist.py中有相关函数）放在processed文件夹下。 COCO需要安装COCO API # 图像标注dset.CocoCaptions(root=&quot;dir where images are&quot;, annFile=&quot;json annotation file&quot;, [transform, target_transform]) from torchvision import datasetsimport torchvision.transforms as transformscap = datasets.CocoCaptions(root=&apos;dir where images are&apos;, annFile=&apos;json annotation file&apos;, transform=transforms.ToTensor())print(&apos;Number of samples: &apos;, len(cap))img, target = cap[3] # load 4th sampleprint(&quot;Image Size: &quot;, img.size())print(target) # 检测dset.CocoDetection(root=&quot;dir where images are&quot;, annFile=&quot;json annotation file&quot;, [transform, target_transform]) ImageFolder一个通用的数据加载器，数据集中的数据以以下方式组织。 root/dog/xxx.pngroot/dog/xxy.pngroot/dog/xxz.pngroot/cat/123.pngroot/cat/nsdf3.pngroot/cat/asd932_.png 既其默认你的数据集已经自觉按照要分配的类型分成了不同的文件夹，一种类型的文件夹下面只存放一种类型的图片 import torchvision.datasets as dsetdset.ImageFolder(root=&quot;root folder path&quot;, [transform, target_transform])# root ： 指定图片存储的路径，在下面的例子中是&apos;./data/dogcat_2&apos;# transform： 一个函数，原始图片作为输入，返回一个转换后的图片。# target_transform - 一个函数，输入为target，输出对其的转换。例子，输入的是图片标注的string，输出为word的索引。 import torchvision.datasets as dsetdataset = dset.ImageFolder(&apos;./data/dogcat_2&apos;) #没有transform，先看看取得的原始图像数据print(dataset.classes) #根据分的文件夹的名字来确定的类别print(dataset.class_to_idx) #按顺序为这些类别定义索引为0,1...print(dataset.imgs) #返回从所有文件夹中得到的图片的路径以及其类别&apos;&apos;&apos;[&apos;cat&apos;, &apos;dog&apos;]&#123;&apos;cat&apos;: 0, &apos;dog&apos;: 1&#125;[(&apos;./data/dogcat_2/cat/cat.12484.jpg&apos;, 0), (&apos;./data/dogcat_2/cat/cat.12485.jpg&apos;, 0), (&apos;./data/dogcat_2/cat/cat.12486.jpg&apos;, 0), (&apos;./data/dogcat_2/cat/cat.12487.jpg&apos;, 0), (&apos;./data/dogcat_2/dog/dog.12496.jpg&apos;, 1), (&apos;./data/dogcat_2/dog/dog.12497.jpg&apos;, 1), (&apos;./data/dogcat_2/dog/dog.12498.jpg&apos;, 1), (&apos;./data/dogcat_2/dog/dog.12499.jpg&apos;, 1&apos;&apos;&apos; torchvision.modelstorchvision.models模块的 子模块中包含以下模型结构。 AlexNet VGG ResNet SqueezeNet DenseNet 你可以使用随机初始化的权重来创建这些模型。 from torchvision import modelsresnet18 = models.resnet18()alexnet = models.alexnet()squeezenet = models.squeezenet1_0()densenet = models.densenet161() 对于ResNet variants和AlexNet，我们也提供了预训练(pre-trained)的模型。 import torchvision.models as models# pretrained=True就可以使用预训练的模型resnet18 = models.resnet18(pretrained=True)alexnet = models.alexnet(pretrained=True) tansformCompose将多个transform组合起来使用。transforms： 由transform构成的列表. 例子： from PIL import Imagefrom torchvision import transformstransforms.Compose([ transforms.CenterCrop(10), transforms.ToTensor(), ])&apos;&apos;&apos;### class torchvision.transforms.Scale(size, interpolation=2)将输入的`PIL.Image`重新改变大小成给定的`size`，`size`是最小边的边长。举个例子，如果原图的`height&gt;width`,那么改变大小后的图片大小是`(size*height/width, size)`。**用例:**​```python&apos;&apos;&apos;crop = transforms.Scale(12)img = Image.open(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)print(type(img))print(img.size)croped_img = crop(img)print(type(croped_img))print(croped_img.size) CenterCropclass torchvision.transforms.CenterCrop(size)将给定的PIL.Image进行中心切割，得到给定的size，size可以是tuple，(target_height, target_width)。size也可以是一个Integer，在这种情况下，切出来的图片的形状是正方形。 RandomCropclass torchvision.transforms.RandomCrop(size, padding=0)切割中心点的位置随机选取。size可以是tuple也可以是Integer。 RandomHorizantalFlipclass torchvision.transforms.RandomHorizontalFlip随机水平翻转给定的PIL.Image,概率为0.5。即：一半的概率翻转，一半的概率不翻转。 RandomSizeCropclass torchvision.transforms.RandomSizedCrop(size, interpolation=2)先将给定的PIL.Image随机切，然后再resize成给定的size大小。 Padclass torchvision.transforms.Pad(padding, fill=0)将给定的PIL.Image的所有边用给定的pad value填充。 padding：要填充多少像素 fill：用什么值填充 例子： from torchvision import transformsfrom PIL import Imagepadding_img = transforms.Pad(padding=10, fill=0)img = Image.open(&apos;/home/ltb/图片/cv2-tutorial/000001.jpg&apos;)print(type(img))print(img.size)padded_img = padding_img(img)print(type(padded_img))print(padded_img.size) Normalizeclass torchvision.transforms.Normalize(mean, std)给定均值：(R,G,B) 方差：（R，G，B），将会把Tensor正则化。即：Normalized_image=(image-mean)/std。 ToTensor与ToPILImage把一个取值范围是[0,255]的PIL.Image或者shape为(H,W,C)的numpy.ndarray，转换成形状为[C,H,W]，取值范围是[0,1.0]的torch.FloadTensor import numpy as npfrom PIL import Imageimport cv2import torchfrom torchvision import transforms# opencv和PIL读取图片img1 = Image.open(&quot;/home/ltb/图片/cv2-tutorial/000001.jpg&quot;)img2 = cv2.imread(&quot;/home/ltb/图片/cv2-tutorial/000001.jpg&quot;)img1.show()cv2.imshow(&quot;img2&quot;, img2)cv2.waitKey(0)print(img1)print(img2)img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)# ToTensor,转化为tensor,[C, H, W],RGB,[0,1.0]t = transforms.ToTensor()img1_tensor = t(img1)img2_tensor = t(img2)print(img1_tensor)print(&quot;\\n&quot;*10)print(img2_tensor)# tensor转化为PILImaget = transforms.ToPILImage()img1 = t(img1_tensor)img2 = t(img2_tensor)img1.show()img2.show()","path":"2019/08/05/pytorch常用函数/","date":"08-05","excerpt":"","tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://litianbo243.github.io/tags/pytorch/"},{"name":"deeplearning","slug":"deeplearning","permalink":"https://litianbo243.github.io/tags/deeplearning/"}]}]}